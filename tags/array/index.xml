<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Array on Geek Think</title>
    <link>http://xmruibi.github.io/tags/array/</link>
    <description>Recent content in Array on Geek Think</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Sat, 14 Nov 2015 22:43:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/tags/array/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Balanced Point in Array</title>
      <link>http://xmruibi.github.io/2015/11/14/balanced-point-in-array/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/balanced-point-in-array/</guid>
      <description>

&lt;p&gt;Balanced index of an array is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes.&lt;/p&gt;

&lt;h3 id=&#34;example:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;In an arrya A:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A[0] = -7, A[1] = 1, A[2] = 5, A[3] = 2, A[4] = -4, A[5] = 3, A[6]=0
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;3&lt;/code&gt; is an Balanced index, because: &lt;code&gt;A[0] + A[1] + A[2] = A[4] + A[5] + A[6]&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;6&lt;/code&gt; is also an Balanced index, because sum of zero elements is zero, i.e., &lt;code&gt;A[0] + A[1] + A[2] + A[3] + A[4] + A[5]=0&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;7&lt;/code&gt; is not an Balanced index, because it is not a valid index of array A.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Write a function int &lt;code&gt;balancedPoint(int[] arr)&lt;/code&gt;; that given a sequence arr[] of size n, returns an Balanced index (if any) or -1 if no Balanced indexes exist.&lt;/p&gt;

&lt;h2 id=&#34;think:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;The idea is to get total sum of array first. Then Iterate through the array and keep updating the left sum which is initialized as zero. In the loop, we can get right sum by subtracting the elements one by one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1) Initialize leftsum  as 0
2) Get the total sum of the array as sum
3) Iterate through the array and for each index i, do following.
    a)  Update sum to get the right sum.  
           sum = sum - arr[i] 
       // sum is now right sum
    b) If leftsum is equal to sum, then return current index. 
    c) leftsum = leftsum + arr[i] // update leftsum for next iteration.
4) return -1 // If we come out of loop without returning then
             // there is no equilibrium index
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	// find all balance point in an array return balanced index
	public List&amp;lt;Integer&amp;gt; findBalancedPoint(int[] arr) {
		int leftsum = 0, rightsum = 0;
		List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

		for (int i = 0; i &amp;lt; arr.length; i++) 
			leftsum += arr[i];
		
		for (int i = arr.length - 1; i&amp;gt;=0; i--) {
			leftsum -= arr[i];
			if(leftsum == rightsum)
				res.add(i);
			rightsum+=arr[i];
		}
		return -1;
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Maximum Subarray of Sum / Product</title>
      <link>http://xmruibi.github.io/2015/11/14/maximum-subarray-of-sum-/-product/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/maximum-subarray-of-sum-/-product/</guid>
      <description>

&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest sum.&lt;/p&gt;

&lt;p&gt;For example, given the array &lt;code&gt;[−2,1,−3,4,−1,2,1,−5,4]&lt;/code&gt;,
the contiguous subarray &lt;code&gt;[4,−1,2,1]&lt;/code&gt; has the largest sum = &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int maxSubArray(int[] arr) {
        int maxSum = Integer.MIN_VALUE;
		int curSum = 0;
		for (int i = 0; i &amp;lt; arr.length; i++) {
			curSum += arr[i];
			maxSum = Math.max(maxSum, curSum);
			if (curSum &amp;lt; 0)
				curSum = 0;
		}
		return maxSum;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-record-index:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution #Record Index&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int[] maxSubArray(int[] arr) {
        int maxSum = Integer.MIN_VALUE;
		int curSum = 0;
		int prev = 0, l = 0, r = 0;
		for (int i = 0; i &amp;lt; arr.length; i++) {
			curSum += arr[i];
			if(curSum &amp;gt; maxSum) {
				maxSum = curSum;
				l = prev;
				r = i;
			}
			if (curSum &amp;lt; 0) {
				curSum = 0;
				prev = i + 1;
			}
		}
		return new int[]{l, r};
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest product.&lt;/p&gt;

&lt;p&gt;For example, given the array &lt;code&gt;[2,3,-2,4]&lt;/code&gt;,
the contiguous subarray &lt;code&gt;[2,3]&lt;/code&gt; has the largest product = &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution-1:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int maxProduct(int[] nums) {
        int glMax = Integer.MIN_VALUE;
        
        int localMin = 1; // record the current max
        int localMax = 1; // record the current min, since the negative number multiply with current number may leads to next product as the positive max
        for(int i = 0; i &amp;lt; nums.length; i++) {
            int tmp = localMax;
            localMax = Math.max(localMax*nums[i], Math.max(localMin*nums[i], nums[i]));
            localMin = Math.min(tmp*nums[i], Math.min(localMin*nums[i], nums[i]));
            glMax = Math.max(glMax, localMax);
        }
        
        return glMax;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Product of Array Except Self</title>
      <link>http://xmruibi.github.io/2015/11/14/product-of-array-except-self/</link>
      <pubDate>Sat, 14 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/product-of-array-except-self/</guid>
      <description>

&lt;p&gt;Given an array of &lt;code&gt;n&lt;/code&gt; integers where &lt;code&gt;n&lt;/code&gt; &amp;gt; 1, nums, return an array output such that &lt;code&gt;output[i]&lt;/code&gt; is equal to the product of all the elements of nums except &lt;code&gt;nums[i]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Solve it &lt;strong&gt;without division&lt;/strong&gt; and in &lt;code&gt;O(n)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, given &lt;code&gt;[1,2,3,4]&lt;/code&gt;, return &lt;code&gt;[24,12,8,6]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Follow up:
Could you solve it with constant space complexity? (Note: The &lt;strong&gt;output array does not count&lt;/strong&gt; as extra space for the purpose of space complexity analysis.)&lt;/p&gt;

&lt;h2 id=&#34;think-1:475ac2d302270bdb12a33bec7e726fb7&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;$$O(n)$$ Space and Two pass, recording the left part or right part product.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:475ac2d302270bdb12a33bec7e726fb7&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int[] productExceptSelf(int[] input) {
        int[] res = new int[input.length];
        int tmp = 1;
        for (int i = 0; i &amp;lt; input.length; i++) {
            res[i] = tmp;
            tmp *= input[i];
        }
        tmp = 1;
        for (int i = input.length - 1; i &amp;gt;= 0; i--) {
            res[i] *= tmp;
            tmp *= input[i];
        }
        return res;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Constant Time Random Picker</title>
      <link>http://xmruibi.github.io/2015/11/14/constant-time-random-picker/</link>
      <pubDate>Sat, 14 Nov 2015 00:30:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/constant-time-random-picker/</guid>
      <description>

&lt;p&gt;Design a data structure that supports insert, delete, search and getRandom in constant time.&lt;/p&gt;

&lt;p&gt;Design a data structure that supports following operations in Θ(1) time.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;insert(x)&lt;/code&gt;: Inserts an item x to the data structure if not already present.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove(x)&lt;/code&gt;: Removes an item x from the data structure if present.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;search(x)&lt;/code&gt;: Searches an item x in the data structure.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getRandom()&lt;/code&gt;: Returns a random element from current set of elements&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;think:fbe9fdf4f7686b0780359874c12ae63a&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;We can use hashing to support first 3 operations in Θ(1) time. How to do the 4th operation? The idea is to use a resizable array (ArrayList in Java, vector in C) together with hashing. Resizable arrays support insert in Θ(1) amortized time complexity. To implement getRandom(), we can simply pick a random number from 0 to size-1 (size is number of current elements) and return the element at that index. The hash map stores array values as keys and array indexes as values.&lt;/p&gt;

&lt;p&gt;Following are detailed operations.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;insert(x)&lt;/li&gt;
&lt;li&gt;Check if x is already present by doing a hash map lookup.&lt;/li&gt;
&lt;li&gt;If not present, then insert it at the end of the array.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add in hash table also, x is added as key and last array index as index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;remove(x)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check if x is present by doing a hash map lookup.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If present, then find its index and remove it from hash map.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swap the last element with this element in array and remove the last element.
Swapping is done because the last element can be removed in O(1) time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Update index of last element in hash map.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getRandom()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generate a random number from 0 to last index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Return the array element at the randomly generated index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;search(x)
Do a lookup for x in hash map.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:fbe9fdf4f7686b0780359874c12ae63a&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ConstantTimeRandomPicker {
	
	private final ArrayList&amp;lt;Integer&amp;gt; arr;
	private final HashMap&amp;lt;Integer, Integer&amp;gt; map; // value - index
    Random r;
	
	public ConstantTimeRandomPicker() {
		this.arr = new ArrayList&amp;lt;Integer&amp;gt;();
		this.map = new HashMap&amp;lt;Integer, Integer&amp;gt;();
	}
	
	public void add(int val) {
		arr.add(val);
		map.put(arr.size() - 1, val);
	}
	
	public void remove(int val) {
		remove(map.get(val), val);
	}
	
	public void removeRandom() {
		int val = arr.get(r.nextInt(arr.size()));
		remove(map.get(val), val);
	}
	
	public int getRandom() {
		return arr.get(r.nextInt(arr.size()));
	}
	
	public int search(int val) {
		return arr.get(map.get(val));
	}

	private void remove(int idx, int val) {
		
		// swap with the last element
		int last = arr.get(arr.size() - 1);
		// put the last element to the current index
		arr.set(idx, last);
		// remove the last element
		arr.remove(arr.size() - 1);
				
		// update the last element&#39;s index in hashmap
		map.put(last, idx);		
		// remove the removal value
		map.remove(val);
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Nested List</title>
      <link>http://xmruibi.github.io/2015/11/13/nested-list/</link>
      <pubDate>Fri, 13 Nov 2015 13:13:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/nested-list/</guid>
      <description>

&lt;p&gt;Given a nested list of integers, returns the sum of all integers in the list weighted by their depth.&lt;/p&gt;

&lt;h3 id=&#34;partial-code:cd5432d5a5299bdbe44a28444996274a&#34;&gt;Partial Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 
 * This is the interface that represents nested lists. 
 * You should not implement it, or speculate about its implementation. 
 */ 
public interface NestedInteger { 
    // Returns true if this NestedInteger holds a single integer, rather than a nested list 
    public boolean isInteger(); 

    // Returns the single integer that this NestedInteger holds, if it holds a single integer 
    // Returns null if this NestedInteger holds a nested list 
    public Integer getInteger(); 

    // Returns the nested list that this NestedInteger holds, if it holds a nested list 
    // Returns null if this NestedInteger holds a single integer 
    public List getList(); 
}

public class Solution {
	public int depthSum(List&amp;lt;NestedInteger&amp;gt; input) {
        //Implement this function
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;example:cd5432d5a5299bdbe44a28444996274a&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given the list &lt;code&gt;{{1,1},2,{1,1}}&lt;/code&gt; the function should return &lt;code&gt;10&lt;/code&gt; (four 1&amp;rsquo;s at depth 2, one 2 at depth 1);
Given the list &lt;code&gt;{1,{4,{6}}}&lt;/code&gt; the function should return &lt;code&gt;27&lt;/code&gt; (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3);&lt;/p&gt;

&lt;h2 id=&#34;think:cd5432d5a5299bdbe44a28444996274a&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Recursion with DFS&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:cd5432d5a5299bdbe44a28444996274a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
	public int depthSum(List&amp;lt;NestedInteger&amp;gt; input) {
		return dfsHelper(input, 1);
    }

    private int dfsHelper(List&amp;lt;NestedInteger&amp;gt; input, int depth) {
    	int sum = 0;
    	for(NestedInteger cur : input) {
    		if(cur.isInteger())
    			sum += (cur.getInteger() * depth);
    		else
    			sum += dfsHelper(cur.getList(), depth + 1);
    	}
    	return sum;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;followup-1:cd5432d5a5299bdbe44a28444996274a&#34;&gt;Followup #1&lt;/h2&gt;

&lt;p&gt;Get the sum by reversed level.&lt;/p&gt;

&lt;h4 id=&#34;think-1:cd5432d5a5299bdbe44a28444996274a&#34;&gt;Think&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Should get depth at first and then recursively reduce the depth for DFS&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public static int reversedDepthSum(List&amp;lt;NestedInteger&amp;gt; input) {
		int depth = getDepth(input);
		return dfsReverseHelper(input, depth);
	}

	private static int dfsReverseHelper(List&amp;lt;NestedInteger&amp;gt; input, int depth) {
		int sum = 0;
		for (NestedInteger cur : input) {
			if (cur.isInteger())
				sum += (cur.getInteger() * depth);
			else
				sum += dfsReverseHelper(cur.getList(), depth - 1);
		}
		return sum;
	}
	
	private static int getDepth(List&amp;lt;NestedInteger&amp;gt; input) {
		int depth = 0;
		for (NestedInteger cur : input) {
			if (!cur.isInteger())
				depth = Math.max(depth, getDepth(cur.getList()));
		}
		return depth + 1;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;followup-2:cd5432d5a5299bdbe44a28444996274a&#34;&gt;Followup #2&lt;/h2&gt;

&lt;p&gt;Implement the Nested Integer interface&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NestedIntImpl implements NestedInteger {
	Object obj;

	public NestedIntegerImpl(Object obj) {
		this.obj = obj;
	}

	@Override
	public boolean isInteger() {	
		return obj instanceof Integer;
	}

	@Override
	public Integer getInteger() {
		if(obj instanceof Integer)
			return (Integer)obj;
		return null;
	}

	@Override
	public List&amp;lt;NestedInteger&amp;gt; getList() {
		if(obj instanceof List)
			return (List&amp;lt;NestedInteger&amp;gt;)obj;
		return null;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find the Celebrity</title>
      <link>http://xmruibi.github.io/2015/11/12/find-the-celebrity/</link>
      <pubDate>Thu, 12 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/12/find-the-celebrity/</guid>
      <description>

&lt;p&gt;Suppose you are at a party with &lt;code&gt;n&lt;/code&gt; people (labeled from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n - 1&lt;/code&gt;) and among them, there may exist one celebrity. The definition of a celebrity is that all the other &lt;code&gt;n - 1&lt;/code&gt; people know him/her but &lt;strong&gt;he/she does not know any of them&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: &amp;ldquo;Hi, A. Do you know B?&amp;rdquo; to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).&lt;/p&gt;

&lt;p&gt;You are given a helper function &lt;code&gt;bool knows(a, b)&lt;/code&gt; which tells you whether A knows B. Implement a function &lt;code&gt;int findCelebrity(n)&lt;/code&gt;, your function should minimize the number of calls to &lt;code&gt;knows&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note:987915e63763fb778a6682d4a9f26f85&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;There will be exactly one celebrity if he/she is in the party. Return the celebrity&amp;rsquo;s label if there is a celebrity in the party. If there is no celebrity, return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think-1:987915e63763fb778a6682d4a9f26f85&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Based graph, check the node with &lt;code&gt;n-1&lt;/code&gt; in-degree and &lt;code&gt;0&lt;/code&gt; out-degree.&lt;/li&gt;
&lt;li&gt;Becuase other &lt;code&gt;n - 1&lt;/code&gt; people know him/her but &lt;strong&gt;he/she does not know any of them&lt;/strong&gt; (&lt;code&gt;0&lt;/code&gt; out-degree)&lt;/li&gt;
&lt;li&gt;Call times: $$O(n^2)$$&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:987915e63763fb778a6682d4a9f26f85&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public int findCelebrity(int n) {
		if (n &amp;lt;= 1)
			return -1;

		int[] inDegree = new int[n];
		int[] outDegree = new int[n];

		// call n^2 times
		for (int i = 0; i &amp;lt; n; i++) {
			for (int j = 0; j &amp;lt; n; j++) {
				if (i != j &amp;amp;&amp;amp; knows(i, j)) {
					outDegree[i]++;
					inDegree[j]++;
				}
			}
		}

		for (int i = 0; i &amp;lt; n; i++) {
			if (inDegree[i] == n - 1 &amp;amp;&amp;amp; outDegree[i] == 0) {
				return i;
			}
		}

		return -1;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2:987915e63763fb778a6682d4a9f26f85&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Iterations from head and rear to the middle(l -&amp;gt; m &amp;lt;- r).&lt;/li&gt;
&lt;li&gt;Two cases when check if [l] knows [r].

&lt;ul&gt;
&lt;li&gt;Left shouldn&amp;rsquo;t be celebrity since he knows someone.&lt;/li&gt;
&lt;li&gt;Right shouldn&amp;rsquo;t be celebrity because one of people doesn&amp;rsquo;t know him.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2:987915e63763fb778a6682d4a9f26f85&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public int findCelebrityII(int n) {
		if (n &amp;lt;= 1)
			return -1;
		
		int left = 0, right = n - 1;
		while (left &amp;lt; right) {
			if (knows(left, right))
				left++; // left shouldn&#39;t be celebrity since he knows someone
			else
				right--; // right shouldn&#39;t be celebrity because one of people doesn&#39;t know him
		}

		// check the potential candidate is celebrity
		for (int i = 0; i &amp;lt; n; i++) {
			if (i == right)
				continue;
			if (knows(right, i))
				return -1;
		}
		return right;
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find the Duplicate Number</title>
      <link>http://xmruibi.github.io/2015/11/12/find-the-duplicate-number/</link>
      <pubDate>Thu, 12 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/12/find-the-duplicate-number/</guid>
      <description>

&lt;p&gt;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.&lt;/p&gt;

&lt;h3 id=&#34;note:51072b7754d767e44ab1a140653d075f&#34;&gt;Note&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;You must not modify the array (assume the array is read only).&lt;/li&gt;
&lt;li&gt;You must use only constant, O(1) extra space.&lt;/li&gt;
&lt;li&gt;Your runtime complexity should be less than $$O(n^2)$$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is only one duplicate number in the array, but it could be repeated more than once.&lt;/p&gt;

&lt;h2 id=&#34;think-1:51072b7754d767e44ab1a140653d075f&#34;&gt;Think #1&lt;/h2&gt;

&lt;h5 id=&#34;pigeonhole-principle:51072b7754d767e44ab1a140653d075f&#34;&gt;Pigeonhole Principle&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Split the array into two pieces by the middle point.&lt;/li&gt;
&lt;li&gt;NOTE: an array nums containing &lt;code&gt;n + 1&lt;/code&gt; integers where each integer is between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; (inclusive).&lt;/li&gt;
&lt;li&gt;Let&amp;rsquo;s say if there is &lt;code&gt;10&lt;/code&gt; elements in array. The index of middle point is &lt;code&gt;4&lt;/code&gt;. Check the all elements and count how many element has the value less or equal to that index. If the counter larger than index value and according to Pigeonhole Priciple,  that means there must have number duplicated in the first half of searching range. So next time we search the first half. Otherwise, we check the last half part.&lt;/li&gt;
&lt;li&gt;NOTICE: each time we decrease the search range but still check the number in entire array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:51072b7754d767e44ab1a140653d075f&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int findDuplicate(int[] nums) {
        int l = 0, r = nums.length - 1;
        while(l &amp;lt; r) {
            int m = l + ((r - l) &amp;gt;&amp;gt; 1);
            int cnt = 0;
            for(int i : nums)
                if(i &amp;lt;= m)
                    cnt++;
            if(cnt &amp;lt;= m)
                l = m + 1;
            else
                r = m;
        }
        return l;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>H-Index</title>
      <link>http://xmruibi.github.io/2015/11/11/h-index/</link>
      <pubDate>Wed, 11 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/11/h-index/</guid>
      <description>

&lt;p&gt;Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher&amp;rsquo;s h-index.&lt;/p&gt;

&lt;p&gt;According to the definition of h-index on Wikipedia: &amp;ldquo;A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;For example, given citations = &lt;code&gt;[3, 0, 6, 1, 5]&lt;/code&gt;, which means the researcher has &lt;code&gt;5&lt;/code&gt; papers in total and each of them had received &lt;code&gt;3, 0, 6, 1, 5&lt;/code&gt; citations respectively. Since the researcher has &lt;code&gt;3&lt;/code&gt; papers with at least &lt;code&gt;3&lt;/code&gt; citations each and the remaining two with no more than &lt;code&gt;3&lt;/code&gt; citations each, his h-index is &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;If there are several possible values for h, the maximum one is taken as the h-index.&lt;/p&gt;

&lt;h3 id=&#34;hint:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Hint&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;An easy approach is to sort the array first.&lt;/li&gt;
&lt;li&gt;What are the possible values of h-index?&lt;/li&gt;
&lt;li&gt;A faster approach is to use extra space.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;think-1:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Sort first (takes $$O(n \times log{n})$$)&lt;/li&gt;
&lt;li&gt;Set a &lt;code&gt;h&lt;/code&gt; variable, increase &lt;code&gt;h&lt;/code&gt; to &lt;code&gt;length - currentIdx&lt;/code&gt; when current element&amp;rsquo;s value is equals or larger than &lt;code&gt;length - currentIdx&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int hIndex(int[] citations) {
        if(citations == null || citations.length == 0)
            return 0;
        Arrays.sort(citations);
        int h = 0;
        for(int i = 0; i &amp;lt; citations.length; i++) {
            if(citations[i] &amp;gt;= citations.length - i)
                h = Math.max(h, citations.length - i);
        }
        return h;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Extra Space&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int hIndex(int[] citations) {
        if(citations == null || citations.length == 0)
            return 0;
        int[] memo = new int[citations.length + 1];
        for(int i = 0; i &amp;lt; citations.length; i++) {
            if(citations[i] &amp;gt;= memo.length)
                memo[memo.length - 1] ++;
            else
                memo[citations[i]]++;
        }

        for(int i = memo.length - 1; i &amp;gt;= 0; i--) {
            if(i &amp;lt; memo.length - 1)
                memo[i] += memo[i+1];
            if(memo[i] &amp;gt;= i)
                return i;
        }
        return 0;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-3:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Think #3&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Sort and Binary Search&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-3:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Solution #3&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int hIndex(int[] citations) {
        if(citations == null || citations.length == 0)
            return 0;
        int l = 0, r = citations.length - 1;
        while(l + 1 &amp;lt; r) {
            int m = l + ((r - l) &amp;gt;&amp;gt; 1);
            if(citations[m] == citations.length - m)
                return citations.length - m;
            else if(citations[m] &amp;lt; citations.length - m)
                l = m;
            else
                r = m;
        }
        if(citations[l] &amp;gt;= citations.length - l)
            return citations.length - l;   // this is larger
        if(citations[r] &amp;gt;= citations.length - r)
            return citations.length - r;
    
        return 0;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Move Zeroes</title>
      <link>http://xmruibi.github.io/2015/11/11/move-zeroes/</link>
      <pubDate>Wed, 11 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/11/move-zeroes/</guid>
      <description>

&lt;p&gt;Given an array nums, write a function to move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;

&lt;p&gt;For example, given nums = &lt;code&gt;[0, 1, 0, 3, 12]&lt;/code&gt;, after calling your function, nums should be &lt;code&gt;[1, 3, 12, 0, 0]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note:48a830997c7d9feb48b62c53bd2152a6&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;You must do this in-place without making a copy of the array.
Minimize the total number of operations.&lt;/p&gt;

&lt;h2 id=&#34;think:48a830997c7d9feb48b62c53bd2152a6&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Mark an index for nonzero element&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:48a830997c7d9feb48b62c53bd2152a6&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public void moveZeroes(int[] nums) {
        int nonzeroIdx = 0;
        int idx = 0;
        while(idx &amp;lt; nums.length) {
            if(idx &amp;gt;= nonzeroIdx &amp;amp;&amp;amp; nums[idx] != 0) {
                int tmp = nums[idx];
                nums[idx--] = nums[nonzeroIdx];
                nums[nonzeroIdx++] = tmp;
            }
            idx++;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Query Range Sum on Array</title>
      <link>http://xmruibi.github.io/2015/11/11/query-range-sum-on-array/</link>
      <pubDate>Wed, 11 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/11/query-range-sum-on-array/</guid>
      <description>

&lt;p&gt;Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.&lt;/p&gt;

&lt;h3 id=&#34;example:26e685b3d16b25a213adc00d0a48995a&#34;&gt;Example:&lt;/h3&gt;

&lt;p&gt;Given nums = [-2, 0, 3, -5, 2, -1]&lt;/p&gt;

&lt;p&gt;sumRange(0, 2) -&amp;gt; 1
sumRange(2, 5) -&amp;gt; -1
sumRange(0, 5) -&amp;gt; -3
Note:
You may assume that the array does not change.
There are many calls to sumRange function.&lt;/p&gt;

&lt;h2 id=&#34;think:26e685b3d16b25a213adc00d0a48995a&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Save the prefix sum in extra array.&lt;/li&gt;
&lt;li&gt;Be aware to the &lt;code&gt;sum[0]&lt;/code&gt; means nothing before the first element of input array &lt;code&gt;nums&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;return the the difference on prefix index &lt;code&gt;[high] - [low - 1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:26e685b3d16b25a213adc00d0a48995a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NumArray {
    int[] sum;
    
    public NumArray(int[] nums) {
        sum = new int[nums.length + 1];
        for(int i = 1; i &amp;lt;= nums.length; i++) {
            sum[i] = nums[i-1] + sum[i-1];
        }
    }

    public int sumRange(int i, int j) {
        return sum[j+1]-sum[i];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Bull and Cows</title>
      <link>http://xmruibi.github.io/2015/11/10/bull-and-cows/</link>
      <pubDate>Tue, 10 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/10/bull-and-cows/</guid>
      <description>

&lt;p&gt;You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called &lt;code&gt;&amp;quot;bulls&amp;quot;&lt;/code&gt;) and how many digits match the secret number but locate in the wrong position (called &lt;code&gt;&amp;quot;cows&amp;quot;&lt;/code&gt;). Your friend will use successive guesses and hints to eventually derive the secret number.&lt;/p&gt;

&lt;h3 id=&#34;example:3db9a7391ad6c01d56b4bb1ec63fc398&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Secret number:  &amp;quot;1807&amp;quot;
Friend&#39;s guess: &amp;quot;7810&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;1&lt;/code&gt; bull and &lt;code&gt;3&lt;/code&gt; cows. (The bull is &lt;code&gt;8&lt;/code&gt;, the cows are &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;7&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Write a function to return a hint according to the secret number and friend&amp;rsquo;s guess, use &lt;code&gt;A&lt;/code&gt; to indicate the bulls and &lt;code&gt;B&lt;/code&gt; to indicate the cows. In the above example, your function should return &lt;code&gt;&amp;quot;1A3B&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Please note that both secret number and friend&amp;rsquo;s guess may contain duplicate digits, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Secret number:  &amp;quot;1123&amp;quot;
Friend&#39;s guess: &amp;quot;0111&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the 1st 1 in friend&amp;rsquo;s &lt;code&gt;guess&lt;/code&gt; is a bull, the 2nd or 3rd 1 is a cow, and your function should return &lt;code&gt;&amp;quot;1A1B&amp;quot;&lt;/code&gt;.
You may assume that the secret number and your friend&amp;rsquo;s guess only contain digits, and their lengths are always equal.&lt;/p&gt;

&lt;h2 id=&#34;think:3db9a7391ad6c01d56b4bb1ec63fc398&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s pretty tricky to think about one pass solution without HashMap.&lt;br /&gt;
Here are some pattern we should notice.
    1. Every character in string is number &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt;
    2. Number in &lt;code&gt;guess&lt;/code&gt; and &lt;code&gt;secret&lt;/code&gt; should also be recorded during the pass
    3. Avoid duplicate is tough&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Solve it by set a int array with length of 10 for counting&lt;/li&gt;
&lt;li&gt;meet a number in &lt;code&gt;guess&lt;/code&gt; do a minus on &lt;code&gt;arr[guess_digit]&lt;/code&gt; while meet a number in &lt;code&gt;secrett&lt;/code&gt; do a addition on &lt;code&gt;arr[secret_digit]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;check &lt;code&gt;arr[secret_digit]&lt;/code&gt; if it is negative, which means that number should existed in &lt;code&gt;guess&lt;/code&gt; number&lt;/li&gt;
&lt;li&gt;check &lt;code&gt;arr[guess_digit]&lt;/code&gt; if it is negative, which means that number should existed in &lt;code&gt;secret&lt;/code&gt; number&lt;/li&gt;
&lt;li&gt;when iteration on number is the same from &lt;code&gt;guess&lt;/code&gt; and &lt;code&gt;secret&lt;/code&gt; numbers, that should be the &lt;code&gt;bull&lt;/code&gt; but without any modification on counting array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:3db9a7391ad6c01d56b4bb1ec63fc398&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public String getHint(String secret, String guess) {
        int cntA = 0;
        int cntB = 0;
        int[] valIdx = new int[10];
        for(int i = 0; i &amp;lt; secret.length(); i++) {
            int sIdx = secret.charAt(i) - &#39;0&#39;;
            int gIdx = guess.charAt(i) - &#39;0&#39;;
            if(gIdx == sIdx)
                cntA++;
            else{ 
                if(valIdx[sIdx] &amp;lt; 0) 
                    cntB++;
                if(valIdx[gIdx] &amp;gt; 0) 
                    cntB++;
            }
            valIdx[sIdx]++;
            valIdx[gIdx]--;
        }
        return &amp;quot;&amp;quot; + cntA + &amp;quot;A&amp;quot; + cntB + &amp;quot;B&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>House Robber</title>
      <link>http://xmruibi.github.io/2015/11/06/house-robber/</link>
      <pubDate>Fri, 06 Nov 2015 13:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/06/house-robber/</guid>
      <description>

&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and &lt;strong&gt;it will automatically contact the police if two adjacent houses were broken into on the same night&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;

&lt;h3 id=&#34;example:42c51eb58b3d0e3a2ea215cbd70d5181&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;[3, 8, 4]&lt;/code&gt;, return 8.&lt;/p&gt;

&lt;h3 id=&#34;challenge:42c51eb58b3d0e3a2ea215cbd70d5181&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;$O(n)$ time and $O(1)$ memory.&lt;/p&gt;

&lt;h2 id=&#34;think:42c51eb58b3d0e3a2ea215cbd70d5181&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;When Rob meet a house, he has two choices: taken or not taken, but if he had stolen the previous house, it cannnot taken.&lt;/li&gt;
&lt;li&gt;Set two variable: &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include&lt;/code&gt; means it has taken the previous house, while the &lt;code&gt;exclude&lt;/code&gt; means it didn&amp;rsquo;t take in previous house.&lt;/li&gt;
&lt;li&gt;So each time we consider about the &lt;code&gt;exclude + cur_value&lt;/code&gt; and &lt;code&gt;include&lt;/code&gt;, the max of them should be new &lt;code&gt;include&lt;/code&gt; while the new &lt;code&gt;exclude&lt;/code&gt; come from the max value of original &lt;code&gt;include&lt;/code&gt; (last taken, current not taken) and original &lt;code&gt;exclude&lt;/code&gt; (not taken in both last and current house)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:42c51eb58b3d0e3a2ea215cbd70d5181&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param A: An array of non-negative integers.
     * return: The maximum amount of money you can rob tonight
     */
    public long houseRobber(int[] A) {
        if(A == null)
            return 0L;
        long exclude = 0L;
        long include = 0L;
        
        for(int i = 0; i &amp;lt; A.length; i++) {
            long tmp = include;
            include = Math.max(include, exclude + A[i]);
            exclude = Math.max(tmp, exclude);
        }
        
        return Math.max(include, exclude);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;follow-up:42c51eb58b3d0e3a2ea215cbd70d5181&#34;&gt;Follow Up&lt;/h2&gt;

&lt;p&gt;After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.&lt;/p&gt;

&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;

&lt;h3 id=&#34;think-1:42c51eb58b3d0e3a2ea215cbd70d5181&#34;&gt;Think&lt;/h3&gt;

&lt;p&gt;The houses are in a cycle,so that when pick up the first element we cannot pick the last element because they are adjacent. So just seperate two parts for calculating: &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;last second element&lt;/code&gt;, and &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;last element&lt;/code&gt;, find the maximum from them.&lt;/p&gt;

&lt;h3 id=&#34;solution-1:42c51eb58b3d0e3a2ea215cbd70d5181&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int rob(int[] nums) {
        if(nums==null||nums.length==0)
            return 0;
        if(nums.length==1)
            return nums[0];
        return Math.max(helper(0, nums.length-2, nums), helper(1,nums.length-1,nums));
    }
    
    private int helper(int l, int r, int[] nums){
        if(nums==null||nums.length==0)
            return 0;
        int incl = 0;
        int excl = 0;
        for(int i = l;i&amp;lt;=r;i++){
            int tmp = incl;
            incl = excl+nums[i];
            excl = Math.max(excl, tmp);
        }
        return Math.max(incl, excl);
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Coins in a Line</title>
      <link>http://xmruibi.github.io/2015/11/05/coins-in-a-line/</link>
      <pubDate>Thu, 05 Nov 2015 13:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/05/coins-in-a-line/</guid>
      <description>

&lt;h2 id=&#34;problem-i:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Problem I&lt;/h2&gt;

&lt;p&gt;There are n coins in a line. Two players take turns to take one or two coins from right side until there are no more coins left. The player who take the last coin wins.&lt;/p&gt;

&lt;p&gt;Could you please decide the first play will win or lose?&lt;/p&gt;

&lt;h4 id=&#34;example:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;n = &lt;code&gt;1&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;n = &lt;code&gt;2&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;n = &lt;code&gt;3&lt;/code&gt;, return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;n = &lt;code&gt;4&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;n = &lt;code&gt;5&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;challenge:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Challenge&lt;/h4&gt;

&lt;p&gt;$O(n)$ time and $$O(1)$$ memory&lt;/p&gt;

&lt;h3 id=&#34;think:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Only if the amount of coin is the multiply of &lt;code&gt;3&lt;/code&gt;, first player cannot win.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param n: an integer
     * @return: a boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int n) {
        return n%3!=0;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;There are n coins with different value in a line. Two players take turns to take one or two coins from left side until there are no more coins left. The player who take the coins with the most value wins.&lt;/p&gt;

&lt;p&gt;Could you please decide the first player will win or lose?&lt;/p&gt;

&lt;h4 id=&#34;example-1:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;Given values array A = &lt;code&gt;[1,2,2]&lt;/code&gt;, return true.&lt;/p&gt;

&lt;p&gt;Given A = &lt;code&gt;[1,2,4]&lt;/code&gt;, return false.&lt;/p&gt;

&lt;h3 id=&#34;think-1:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Think&lt;/h3&gt;

&lt;h5 id=&#34;state:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;State&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;dp[i]&lt;/code&gt; represent the max value it can get from &lt;code&gt;i&lt;/code&gt; to the end&lt;/p&gt;

&lt;h5 id=&#34;function:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Function&lt;/h5&gt;

&lt;p&gt;Each time when iterate &lt;code&gt;i&lt;/code&gt;, we have two choice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;takes &lt;code&gt;values[i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;takes &lt;code&gt;values[i] + values[i+1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are what we need to think:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.If we took &lt;code&gt;values[i]&lt;/code&gt;, opposite has two choice:  &lt;code&gt;values[i+1]&lt;/code&gt; or &lt;code&gt;values[i+1] + values[i+2]&lt;/code&gt; so the rest values for our own sides are &lt;code&gt;DP[i+2]&lt;/code&gt; or &lt;code&gt;DP[i+3]&lt;/code&gt;, however it should choose the minimum so that the opposite can get the maximum.&lt;/p&gt;

&lt;p&gt;$$value1 = values[i] + min(DP[i+2], DP[i+3])$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2.If we took  &lt;code&gt;values[i] + values[i+1]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;$$value2 = values[i] + values[i+1] + min(DP[i+3], DP[i+4])$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;3.&lt;/p&gt;

&lt;p&gt;$$dp[I] = max(value1, value2)$$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-1:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param values: an array of integers
     * @return: a boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int[] values) {
        if (values == null || values.length &amp;lt;= 2) {
            return true;
        }
        int dp[] = new int[values.length];
        
        dp[values.length-1] = values[values.length-1];
        dp[values.length-2] = values[values.length-1] + values[values.length-2];
        int total = dp[values.length-2];
        
        for(int i = values.length - 3; i &amp;gt;= 0; i--) {
            total += values[i];
            int value1 = values[i] + Math.min(dp[i+2], i+3&amp;lt;values.length?dp[i+3]:0);
            int value2 = values[i] + values[i+1] + Math.min(i+3&amp;lt;values.length?dp[i+3]:0, i+4&amp;lt;values.length?dp[i+4]:0);
            dp[i] = Math.max(value1, value2);
        }
        
        return dp[0] &amp;gt; (total - dp[0]);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-iii:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Problem III&lt;/h2&gt;

&lt;p&gt;There are n coins in a line. Two players take turns to take a coin from one of the ends of the line until there are no more coins left. The player with the larger amount of money wins.&lt;/p&gt;

&lt;p&gt;Could you please decide the first player will win or lose?&lt;/p&gt;

&lt;h4 id=&#34;example-2:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;Given array A = &lt;code&gt;[3,2,2]&lt;/code&gt;, return true.&lt;/p&gt;

&lt;p&gt;Given array A = &lt;code&gt;[1,2,4]&lt;/code&gt;, return true.&lt;/p&gt;

&lt;p&gt;Given array A = &lt;code&gt;[1,20,4]&lt;/code&gt;, return false.&lt;/p&gt;

&lt;h4 id=&#34;challenge-1:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Challenge&lt;/h4&gt;

&lt;p&gt;Follow Up Question: If &lt;code&gt;n&lt;/code&gt; is even. Is there any hacky algorithm that can decide whether first player will win or lose in $$O(1)$$ memory and $O(n)$ time?&lt;/p&gt;

&lt;h3 id=&#34;think-2:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Think&lt;/h3&gt;

&lt;h5 id=&#34;state-1:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;State&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;dp[i][j]&lt;/code&gt; represent the max value it can get from &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sum[i][j]&lt;/code&gt; represent the sum value from &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;function-1:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Function&lt;/h5&gt;

&lt;p&gt;Each time when taken coins, we have two choice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;takes &lt;code&gt;values[i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;takes &lt;code&gt;values[j]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$dp[i][j]=max(values[i]+sum[i+1][j]-dp[i+1][j], values[j]+sum[i][j-1]-dp[i][j-1])$$&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;values[i]+sum[i+1][j]&lt;/code&gt; or &lt;code&gt;values[j]+sum[i][j-1]&lt;/code&gt; equals to &lt;code&gt;sum[i][j]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So the equation can be $dp[i][j] = sum[i][j] - min(dp[i+1][j],dp[i][j-1])$&lt;/p&gt;

&lt;h3 id=&#34;solution-2:55c5f52fdeb28cdc1ad9a0690da63696&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param values: an array of integers
     * @return: a boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int[] values) {
        if (values == null || values.length &amp;lt;= 2) {
            return true;
        }
        
        int[][] dp = new int[values.length][values.length];
        int[][] sum = new int[values.length][values.length];
        // get the sum of i to j
        for(int i = 0; i &amp;lt; values.length; i++){
            for(int j  = i; j &amp;lt; values.length; j++) {
                if(i == j)
                    sum[i][j] = values[i];
                else
                    sum[i][j] = values[j] + sum[i][j-1];
            }
        }
        
        // to do the dp 
        for(int i = values.length - 1; i &amp;gt;= 0; i--){
            for(int j  = i; j &amp;lt; values.length; j++) {
                if(i == j)
                    dp[i][j] = values[i];
                else
                    dp[i][j] = sum[i][j] - Math.min(dp[i+1][j],dp[i][j-1]);
            }
        }
        
        return dp[0][values.length - 1] &amp;gt; sum[0][values.length - 1] - dp[0][values.length - 1];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Minimum Adjustment Cost</title>
      <link>http://xmruibi.github.io/2015/11/04/minimum-adjustment-cost/</link>
      <pubDate>Wed, 04 Nov 2015 17:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/04/minimum-adjustment-cost/</guid>
      <description>

&lt;p&gt;Given an integer array, adjust each integers so that the difference of every adjacent integers are not greater than a given number target.&lt;/p&gt;

&lt;p&gt;If the array before adjustment is A, the array after adjustment is &lt;code&gt;B&lt;/code&gt;, you should minimize the sum of &lt;code&gt;|A[i]-B[i]|&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;example:fef08796d6332d5577bb4ec050c22c2e&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;[1,4,2,3]&lt;/code&gt; and target = 1, one of the solutions is &lt;code&gt;[2,3,2,3]&lt;/code&gt;, the adjustment cost is 2 and it&amp;rsquo;s minimal.&lt;/p&gt;

&lt;p&gt;Return &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note
You can assume each number in the array is a positive integer and not greater than &lt;code&gt;100&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think:fef08796d6332d5577bb4ec050c22c2e&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;There is invisible condition on Note part: each number in the array is a positive integer and not greater than &lt;code&gt;100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;So the above condition giving the memorized data structure a length on enumeration.&lt;/li&gt;
&lt;li&gt;memo data should be &lt;code&gt;memo[arr.size() + 1][100]&lt;/code&gt;, which means the minimum cost on modify the ith num in A to &lt;code&gt;j&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Pass each element in input array&lt;/li&gt;
&lt;li&gt;Then enumeration &lt;code&gt;j&lt;/code&gt; on 0 to 99, so that we can consider the previous number &lt;code&gt;p&lt;/code&gt; should inside the range between &lt;code&gt;j + target&lt;/code&gt; and &lt;code&gt;j-target&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;So the previous cost should be &lt;code&gt;memo[i-1][p]&lt;/code&gt;and for current, it should be &lt;code&gt;memo[i-1][p] + Math.abs(j-A.get(i-1))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;After arrived the last element and got all possible cost, the minimum total cost should come from &lt;code&gt;memo[last element][i]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:fef08796d6332d5577bb4ec050c22c2e&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param A: An integer array.
     * @param target: An integer.
     */
    public int MinAdjustmentCost(ArrayList&amp;lt;Integer&amp;gt; A, int target) {
        // the minimum cost on modify the ith num in A to j 
        int[][] memo = new int[A.size() + 1][100];
        
        for(int i = 1; i &amp;lt;= A.size(); i++) {
            // enumeration on 0 to 99 
            for(int j=0; j&amp;lt;=99; j++) {
                // initial the minimum cost on ith as the Integer.MAX
                memo[i][j] = Integer.MAX_VALUE;
                // get the range by target based on j 
                int lowerRange = Math.max(0, j-target);
                int upperRange = Math.min(99, j+target);
                // p is the possible num based on previous index
                // check all cost between current index on A and j
                for (int p=lowerRange; p&amp;lt;=upperRange; p++) {
                    
                    memo[i][j] = Math.min(memo[i][j], memo[i-1][p]+Math.abs(j-A.get(i-1)));
                }
            }
        }
        int minCost = Integer.MAX_VALUE;
        // check all minimum cost on index equal to A&#39;s last element
        for(int i = 0; i &amp;lt;= 99; i++)
            minCost = Math.min(minCost, memo[A.size()][i]);
        return minCost;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sort Colors</title>
      <link>http://xmruibi.github.io/2015/11/02/sort-colors/</link>
      <pubDate>Mon, 02 Nov 2015 09:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/02/sort-colors/</guid>
      <description>

&lt;p&gt;Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.&lt;/p&gt;

&lt;p&gt;Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.&lt;/p&gt;

&lt;p&gt;Have you met this question in a real interview? Yes&lt;/p&gt;

&lt;h3 id=&#34;example:907bac6eb6d7ead7afb50e858cadaebd&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given [1, 0, 1, 2], return [0, 1, 1, 2].&lt;/p&gt;

&lt;h3 id=&#34;note:907bac6eb6d7ead7afb50e858cadaebd&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;You are not suppose to use the library&amp;rsquo;s sort function for this problem.&lt;/p&gt;

&lt;h3 id=&#34;challenge:907bac6eb6d7ead7afb50e858cadaebd&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0&amp;rsquo;s, 1&amp;rsquo;s, and 2&amp;rsquo;s, then overwrite array with total number of 0&amp;rsquo;s, then 1&amp;rsquo;s and followed by 2&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;Could you come up with an one-pass algorithm using only constant space?&lt;/p&gt;

&lt;h2 id=&#34;think:907bac6eb6d7ead7afb50e858cadaebd&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Index mark O&amp;rsquo;s first position from head and 2&amp;rsquo;s first position from the rear.&lt;/li&gt;
&lt;li&gt;Exchange the two values.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:907bac6eb6d7ead7afb50e858cadaebd&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void sortColors(int[] nums) {
    if(nums == null || nums.length == 0)
        return;
    int zero = 0;
    int two = nums.length - 1;
    for(int i = 0; i &amp;lt; nums.length; i++){
        if(i &amp;gt; zero &amp;amp;&amp;amp; nums[i] == 0){
            int tmp = nums[zero];
            nums[zero++] = nums[i];
            nums[i--] = tmp;
        }else if(i &amp;lt; two &amp;amp;&amp;amp; nums[i] == 2){
            int tmp = nums[two];
            nums[two--] = nums[i];
            nums[i--] = tmp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>