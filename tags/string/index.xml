<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>String on Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/tags/string/</link>
    <description>Recent content in String on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Mon, 09 Nov 2015 20:43:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/tags/string/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Alien Dictionary</title>
      <link>http://xmruibi.github.io/2015/11/09/alien-dictionary/</link>
      <pubDate>Mon, 09 Nov 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/09/alien-dictionary/</guid>
      <description>

&lt;p&gt;There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given the following words in dictionary,
&lt;code&gt;[
  &amp;quot;wrt&amp;quot;,
  &amp;quot;wrf&amp;quot;,
  &amp;quot;er&amp;quot;,
  &amp;quot;ett&amp;quot;,
  &amp;quot;rftt&amp;quot;
]&lt;/code&gt;
The correct order is: &lt;code&gt;&amp;quot;wertf&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;You may assume all letters are in lowercase.&lt;/li&gt;
&lt;li&gt;If the order is invalid, return an empty string.&lt;/li&gt;
&lt;li&gt;There may be multiple valid order of letters, return any one of them is fine.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Typical topological problem&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static String alienOrder(String[] words) {
        // build up the node map, find node according to the char
        HashMap&amp;lt;Character, Node&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        // iterate through all provided words
        for (String str : words) {
            // read each word and learn their order
            map.put(str.charAt(0),
                    map.containsKey(str.charAt(0)) ? map.get(str.charAt(0))
                            : new Node(str.charAt(0)));
            for (int i = 1; i &amp;lt; str.length(); i++) {
                char cur = str.charAt(i);
                // ignore the adjacent equal characters
                if(cur == str.charAt(i-1))
                    continue;
                Node node = map.containsKey(cur) ? map.get(cur) : new Node(cur);
                Node prev = map.get(str.charAt(i - 1));
                // make current node indegree plus one only if the previous node doesn&#39;t have current node in its neighborhood list 
                if (!prev.neighbors.contains(node) ) {
                    node.indegree++;
                    map.get(str.charAt(i - 1)).neighbors.add(node);
                }
                map.put(cur, node);
            }
        }

        // find the node with zero indegree
        Queue&amp;lt;Node&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
        for (Node node : map.values())
            if (node.indegree == 0)
                queue.offer(node);
        // build the final string,
        StringBuilder sb = new StringBuilder();
        // each time pop the node with zero indegree 
        // reduce their neighbor&#39;s indegree and push node when it has zero indegree
        while (!queue.isEmpty()) {
            Node node = queue.remove();
            sb.append(node.c);
            map.remove(node.c);
            for (Node nb : node.neighbors) {
                nb.indegree--;
                if (nb.indegree == 0 &amp;amp;&amp;amp; map.containsKey(nb.c))
                    queue.offer(nb);
            }
        }
        // if map has any entry means the cycle existed
        if (map.size() &amp;gt; 0)
            return &amp;quot;&amp;quot;;

        return sb.toString();
    }

    private static class Node {
        char c;
        int indegree;
        List&amp;lt;Node&amp;gt; neighbors;

        public Node(char c) {
            this.c = c;
            this.indegree = 0;
            this.neighbors = new ArrayList&amp;lt;&amp;gt;();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Delete Digits</title>
      <link>http://xmruibi.github.io/2015/11/09/delete-digits/</link>
      <pubDate>Mon, 09 Nov 2015 19:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/09/delete-digits/</guid>
      <description>

&lt;p&gt;Given string A representative a positive integer which has N digits, remove any k digits of the number, the remaining digits are arranged according to the original order to become a new positive integer.&lt;/p&gt;

&lt;p&gt;Find the smallest integer after remove k digits.&lt;/p&gt;

&lt;p&gt;N &amp;lt;= &lt;code&gt;240&lt;/code&gt; and k &amp;lt;= N,&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given an integer A = &lt;code&gt;&amp;quot;178542&amp;quot;&lt;/code&gt;, k = &lt;code&gt;4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;return a string &lt;code&gt;&amp;quot;12&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Setup a Stack.&lt;/li&gt;
&lt;li&gt;Iterate through input number&lt;/li&gt;
&lt;li&gt;If current digit is less than the peek of stack, pop out the stack until the peek is not larger than current digit.&lt;/li&gt;
&lt;li&gt;Push current digit&lt;/li&gt;
&lt;li&gt;Limit the pop out times by K. That means the pop action is regarded as remove digit. So when the pop out times is not less than K, keep push the digit even if it is less than peek element.&lt;/li&gt;
&lt;li&gt;Rebuild the output string by reading elements in stack.&lt;/li&gt;
&lt;li&gt;Two corner case should be careful:

&lt;ul&gt;
&lt;li&gt;When the iterate through digits finished, the remove(pop out) counter still less than K, we should ignore the first  &lt;code&gt;k-count&lt;/code&gt; element in stack.&lt;/li&gt;
&lt;li&gt;When the output result has the zero on first element, remove the zero.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     *@param A: A positive integer which has N digits, A is a string.
     *@param k: Remove k digits.
     *@return: A string
     */
    public String DeleteDigits(String A, int k) {
        if(A == null || A.length() == 0)
            return &amp;quot;&amp;quot;;
        // setup stack
        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        // read digits from input string
        int removeCnt = 0;
        for(char c : A.toCharArray()) {
            int cur = c - &#39;0&#39;;
            // pop out the digit larger than current digit
            while(!stack.isEmpty() &amp;amp;&amp;amp; removeCnt &amp;lt; k &amp;amp;&amp;amp; stack.peek() &amp;gt; cur) {
                stack.pop();
                removeCnt ++;
            }
            stack.push(cur);
        }
        
        StringBuilder sb = new StringBuilder();
        while(!stack.isEmpty()) {
            // corner case one:
            if(removeCnt &amp;lt; k) {
                stack.pop();
                removeCnt ++;
            }else
                sb.insert(0, &amp;quot;&amp;quot; + stack.pop());
        }
        // corner case two:
        while(sb.charAt(0) == &#39;0&#39;)
            sb.deleteCharAt(0);
        
        return sb.toString();
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Palindrome Permutation</title>
      <link>http://xmruibi.github.io/2015/11/09/palindrome-permutation/</link>
      <pubDate>Mon, 09 Nov 2015 19:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/09/palindrome-permutation/</guid>
      <description>

&lt;p&gt;Given a string, determine if a permutation of the string could form a palindrome.&lt;/p&gt;

&lt;h2 id=&#34;problem-i&#34;&gt;Problem I&lt;/h2&gt;

&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;code&amp;quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;&amp;quot;aab&amp;quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;&amp;quot;carerac&amp;quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;think&#34;&gt;Think&lt;/h3&gt;

&lt;p&gt;The problem can be easily solved by count the frequency of each character using a hash map. The only thing need to take special care is consider the length of the string to be even or odd.
- If the length is even. Each character should appear exactly times of 2, e.g. 2, 4, 6, etc..
- If the length is odd. One and only one character could appear odd times.&lt;/p&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public boolean canPermutePalindrome(String s) {
		if (s == null || s.length() == 0)
			return true;
		HashMap&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
		for (char c : s.toCharArray())
			map.put(c, map.containsKey(c) ? map.get(c) + 1 : 1);

		int tolerent = 0;
		for (Map.Entry&amp;lt;Character, Integer&amp;gt; entry : map.entrySet()) {
			if (entry.getValue() % 2 != 0) {
				tolerent++;
			}
		}
		if (s.length() % 2 != 0)
			return tolerent == 1;
		else
			return tolerent == 0;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;problem-ii&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;Given a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.&lt;/p&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;Given s = &lt;code&gt;&amp;quot;aabb&amp;quot;&lt;/code&gt;, return &lt;code&gt;[&amp;quot;abba&amp;quot;, &amp;quot;baab&amp;quot;]&lt;/code&gt;.
Given s = &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt;, return &lt;code&gt;[]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;think-1&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Similar with the last problem, check if the input String can form any valid palindrome&lt;/li&gt;
&lt;li&gt;Address the case when the length is odd

&lt;ul&gt;
&lt;li&gt;Record the character with odd frequency&lt;/li&gt;
&lt;li&gt;Initialize the generation String with the Odd character&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Backtracking to generate the symmetry characters on the generation String&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-1&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static List&amp;lt;String&amp;gt; generatePalindromes(String s) {
        HashSet&amp;lt;String&amp;gt; res = new HashSet&amp;lt;&amp;gt;();
        if (s == null || s.length() == 0)
            return new ArrayList&amp;lt;String&amp;gt;(res);
        HashMap&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for (char c : s.toCharArray())
            map.put(c, map.containsKey(c) ? map.get(c) + 1 : 1);
        
        // check if it is odd length, increase the tolerance when it is odd length
        int tolerent = 0;
        if (s.length() % 2 != 0)
            tolerent++;
        
        // record the odd item to set as the base of generate String
        char odd = &#39;\u0000&#39;;
        for (Map.Entry&amp;lt;Character, Integer&amp;gt; entry : map.entrySet()) {
            if (entry.getValue() % 2 != 0) {
                if (tolerent &amp;gt; 0) {
                    tolerent--;
                    odd = entry.getKey(); // set it
                } else
                    return new ArrayList&amp;lt;String&amp;gt;(res);
            }
        }
        // set the base String when the odd case
        String cur = &amp;quot;&amp;quot;;
        if (odd != &#39;\u0000&#39;) {
            map.put(odd, map.get(odd) - 1);
            if (map.get(odd) == 0)
                map.remove(odd);
            cur = &amp;quot;&amp;quot; + odd;
        }
        
        // generate the palindrome
        helper(res, map, cur, s);
        return new ArrayList&amp;lt;String&amp;gt;(res);
    }

    private static void helper(Set&amp;lt;String&amp;gt; res,
            HashMap&amp;lt;Character, Integer&amp;gt; map, String cur, String origin) {
        if (map.size() == 0) {
            res.add(new String(cur));
            return;
        }

        for (int i = 0; i &amp;lt; origin.length(); i++) {
            char c = origin.charAt(i);
            if (!map.containsKey(c))
                continue;
            cur = (c + cur + c);
            map.put(c, map.get(c) - 2);
            if (map.get(c) == 0)
                map.remove(c);
            helper(res, map, cur, origin);
            cur = cur.substring(1, cur.length() - 1);
            map.put(c, map.containsKey(c) ? map.get(c) + 2 : 2);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Group Shifted Strings</title>
      <link>http://xmruibi.github.io/2015/11/09/group-shifted-strings/</link>
      <pubDate>Mon, 09 Nov 2015 09:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/09/group-shifted-strings/</guid>
      <description>

&lt;p&gt;Given a string, we can “shift” each of its letter to its successive letter, for example: &lt;code&gt;“abc”&lt;/code&gt; -&amp;gt; &lt;code&gt;“bcd”&lt;/code&gt;. We can keep “shifting” which forms the sequence:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;abc&amp;quot; -&amp;gt; &amp;quot;bcd&amp;quot; -&amp;gt; ... -&amp;gt; &amp;quot;xyz&amp;quot;&lt;/code&gt;
Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example,&lt;/h3&gt;

&lt;p&gt;given: [&amp;laquo;abc&amp;raquo;, &amp;laquo;bcd&amp;raquo;, &amp;laquo;acef&amp;raquo;, &amp;laquo;xyz&amp;raquo;, &amp;laquo;az&amp;raquo;, &amp;laquo;ba&amp;raquo;, &amp;laquo;a&amp;raquo;, &amp;laquo;z&amp;raquo;], Return:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [&amp;quot;abc&amp;quot;,&amp;quot;bcd&amp;quot;,&amp;quot;xyz&amp;quot;],
  [&amp;quot;az&amp;quot;,&amp;quot;ba&amp;quot;],
  [&amp;quot;acef&amp;quot;],
  [&amp;quot;a&amp;quot;,&amp;quot;z&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##Note
For the return value, each inner list’s elements must follow the lexicographic order.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;There is a regular pattern: if two words are shifted, the distance between two adjacent characters are the same.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    2   3        2   3
    /\ /\        /\ /\
   a  c  f - &amp;gt;  e  g  j 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;So all we need to do is figure out the distance between each character in each word and make these distance as a code to represent the word.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class GroupShiftedString {
    public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; groupStrings(String[] strings) {
        List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for (String str : strings) {
            String code = getCode(str);
            List&amp;lt;String&amp;gt; val;
            if (!map.containsKey(code)) {
                val = new ArrayList&amp;lt;&amp;gt;();
            } else {
                val = map.get(code);
            }
            val.add(str);
            map.put(code, val);
        }

        for (Map.Entry&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; entry : map.entrySet()) {
            List&amp;lt;String&amp;gt; val = entry.getValue();
            Collections.sort(val);
            res.add(val);
        }
        return res;
    }

    private String getCode(String s) {
        StringBuilder sb = new StringBuilder();
        sb.append(&amp;quot;#&amp;quot;);
        for (int i = 1; i &amp;lt; s.length(); i++) {
            int tmp = ((s.charAt(i) - s.charAt(i - 1)) + 26) % 26;
            sb.append(tmp).append(&amp;quot;#&amp;quot;);
        }
        return sb.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Shortest Word Distance</title>
      <link>http://xmruibi.github.io/2015/11/09/shortest-word-distance/</link>
      <pubDate>Mon, 09 Nov 2015 09:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/09/shortest-word-distance/</guid>
      <description>

&lt;p&gt;Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.&lt;/p&gt;

&lt;h2 id=&#34;problem-i&#34;&gt;Problem I&lt;/h2&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Assume that words = &lt;code&gt;[&amp;quot;practice&amp;quot;, &amp;quot;makes&amp;quot;, &amp;quot;perfect&amp;quot;, &amp;quot;coding&amp;quot;, &amp;quot;makes&amp;quot;]&lt;/code&gt;.
Given word1 = &lt;code&gt;“coding”&lt;/code&gt;, word2 = &lt;code&gt;“practice”&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;.
Given word1 = &lt;code&gt;&amp;quot;makes&amp;quot;&lt;/code&gt;, word2 = &lt;code&gt;&amp;quot;coding&amp;quot;&lt;/code&gt;, return &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.&lt;/p&gt;

&lt;h3 id=&#34;think&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The problem can be solved by one-pass of the array.&lt;/li&gt;
&lt;li&gt;Iterate through the array, use two pointers pointing to the index of the word1 and word2, maintain the minimum distance.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	 public int shortestDistance(String[] words, String word1, String word2) {
		 if(words == null)
		    throw new IllegalArgumentException(&amp;quot;Invalid Input!&amp;quot;);
		 int w1Idx = -1, w2Idx = -1;
		 int min = Integer.MAX_VALUE;
		 for(int i = 0; i &amp;lt; words.length; i++) {
			 if(words[i].equals(word1))
				 w1Idx = i;
			 else if(words[i].equals(word2))
				 w2Idx = i;
			 if(w1Idx!=-1 &amp;amp;&amp;amp; w2Idx!=-1){
				 min = Math.min(min, Math.abs(w2Idx-w1Idx));
			 }
		 }
		 return min;
	 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;This is a follow up of Problem I.The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?
Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.&lt;/p&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example,&lt;/h3&gt;

&lt;p&gt;Assume that words = &lt;code&gt;[&amp;quot;practice&amp;quot;, &amp;quot;makes&amp;quot;, &amp;quot;perfect&amp;quot;, &amp;quot;coding&amp;quot;, &amp;quot;makes&amp;quot;]&lt;/code&gt;.
Given word1 = &lt;code&gt;&amp;quot;coding&amp;quot;&lt;/code&gt;, word2 = &lt;code&gt;&amp;quot;practice&amp;quot;&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;.
Given word1 = &lt;code&gt;&amp;quot;makes&amp;quot;&lt;/code&gt;, word2 = &lt;code&gt;&amp;quot;coding&amp;quot;&lt;/code&gt;, return &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;think-1&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Since the calls are from different words, we have to save the index for each word. So HashMap is a good choice.&lt;/li&gt;
&lt;li&gt;Save the word and its indexes as key and value in constructor.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-1&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ShortestWordDistance {
    // here is thread safe, since only constructor contains writing method
    private final HashMap&amp;lt;String, List&amp;lt;Integer&amp;gt;&amp;gt; map;

	public ShortestWordDistance(String[] words) {
		map = new HashMap&amp;lt;&amp;gt;();
		for (int i = 0; i &amp;lt; words.length; i++) {
			List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
			if (map.containsKey(words[i]))
				list = map.get(words[i]);
			list.add(i);
			map.put(words[i], list);
		}
	}

	public int shortestDistanceII(String word1, String word2) {
		int min = Integer.MAX_VALUE;
		if (!map.containsKey(word1) || !map.containsKey(word2))
			return min;
		for (int i : map.get(word1)) {
			for (int j : map.get(word2)) {
				min = Math.min(min, Math.abs(i - j));
			}
		}
		return min;
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-iii&#34;&gt;Problem III&lt;/h2&gt;

&lt;p&gt;This is a follow up of Problem I. The only difference is &lt;strong&gt;now word1 could be the same as word2&lt;/strong&gt;.
Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.
word1 and word2 may be the same and they represent two individual words in the list.&lt;/p&gt;

&lt;h3 id=&#34;example-2&#34;&gt;Example,&lt;/h3&gt;

&lt;p&gt;Assume that words = &lt;code&gt;[&amp;quot;practice&amp;quot;, &amp;quot;makes&amp;quot;, &amp;quot;perfect&amp;quot;, &amp;quot;coding&amp;quot;, &amp;quot;makes&amp;quot;]&lt;/code&gt;.
Given word1 = &lt;code&gt;&amp;quot;makes&amp;quot;&lt;/code&gt;, word2 = &lt;code&gt;&amp;quot;coding&amp;quot;&lt;/code&gt;, return &lt;code&gt;1&lt;/code&gt;.
Given word1 = &lt;code&gt;&amp;quot;makes&amp;quot;&lt;/code&gt;, word2 = &lt;code&gt;&amp;quot;makes&amp;quot;&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;think-2&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Most code should remain the same as the Problem I. But need to deal with the situation that word1 and word2 are the same.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w1Idx&lt;/code&gt; always record the index when &lt;code&gt;word[i].equals(word1)&lt;/code&gt; but &lt;code&gt;w2Idx&lt;/code&gt; should be assigned as the value from &lt;code&gt;w1Idx&lt;/code&gt; when &lt;code&gt;word1 == word2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-2&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	 public int shortestDistance(String[] words, String word1, String word2) {
		 if(words == null)
		    throw new IllegalArgumentException(&amp;quot;Invalid Input!&amp;quot;);
		 int w1Idx = -1, w2Idx = -1;
		 int min = Integer.MAX_VALUE;
		 for(int i = 0; i &amp;lt; words.length; i++) {
			 if(words[i].equals(word1))
				 w1Idx = i;
			 else if(words[i].equals(word2)) // else if to avoid w2Idx be recorded whrn word1==word2
				 w2Idx = i;
			 if(w1Idx!=-1 &amp;amp;&amp;amp; w2Idx!=-1 &amp;amp;&amp;amp; w1Idx != w2Idx){
				 min = Math.min(min, Math.abs(w2Idx-w1Idx));
			 }
			 if(word2.equals(word1))
			    w2Idx = w1Idx; // update previous index record
		 }
		 return min;
	 }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Strobogrammatic Number</title>
      <link>http://xmruibi.github.io/2015/11/08/strobogrammatic-number/</link>
      <pubDate>Sun, 08 Nov 2015 22:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/08/strobogrammatic-number/</guid>
      <description>

&lt;p&gt;A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).&lt;/p&gt;

&lt;h2 id=&#34;problem-i&#34;&gt;Problem I&lt;/h2&gt;

&lt;p&gt;Write a function to determine if a number is strobogrammatic. The number is represented as a string.&lt;/p&gt;

&lt;p&gt;For example, the numbers &lt;code&gt;&amp;quot;69&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;88&amp;quot;&lt;/code&gt;, and &lt;code&gt;&amp;quot;818&amp;quot;&lt;/code&gt; are all strobogrammatic.&lt;/p&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Strobogrammatic {
	public boolean isStrobogrammatic(String num) {
		if (num == null || num.length() == 0)
			return true;
		int l = 0, r = num.length() - 1;
		while (l &amp;lt; r) {
			if (isEqual(num.charAt(l), num.charAt(r))) {
				l++;
				r--;
			} else
				return false;
		}
		return true;
	}

	private boolean isEqual(char l, char r) {
		if ((l == &#39;9&#39; &amp;amp;&amp;amp; r == &#39;6&#39;) || (l == &#39;6&#39; &amp;amp;&amp;amp; r == &#39;9&#39;)
				|| (l == &#39;1&#39; &amp;amp;&amp;amp; r == &#39;1&#39;) || (l == &#39;8&#39; &amp;amp;&amp;amp; r == &#39;8&#39;)
				|| (l == &#39;0&#39; &amp;amp;&amp;amp; r == &#39;0&#39;))
			return true;
		else
			return false;
	}
	
    // Use HashMap
	public boolean isStrobogrammatic(String num) {
        if(num == null || num.length() == 0) {
            return true;
        }
         
        Map&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&#39;0&#39;, &#39;0&#39;);
        map.put(&#39;1&#39;, &#39;1&#39;);
        map.put(&#39;8&#39;, &#39;8&#39;);
        map.put(&#39;6&#39;, &#39;9&#39;);
        map.put(&#39;9&#39;, &#39;6&#39;);
         
        int lo = 0;
        int hi = num.length() - 1;
         
        while (lo &amp;lt;= hi) {
            char c1 = num.charAt(lo);
            char c2 = num.charAt(hi);
             
            if (!map.containsKey(c1) || map.get(c1) != c2) {
                return false;
            }
             
            lo++;
            hi--;
        }
         
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Find all strobogrammatic numbers that are of length = n.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example,&lt;/h3&gt;

&lt;p&gt;Given n = 2, return &lt;code&gt;[&amp;quot;11&amp;quot;,&amp;quot;69&amp;quot;,&amp;quot;88&amp;quot;,&amp;quot;96&amp;quot;]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;think&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Typical backtracking to generate something question&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-1&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public static List&amp;lt;String&amp;gt; findStrobogrammatic(int n) {
        Map&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&#39;0&#39;, &#39;0&#39;);
        map.put(&#39;1&#39;, &#39;1&#39;);
        map.put(&#39;8&#39;, &#39;8&#39;);
        map.put(&#39;6&#39;, &#39;9&#39;);
        map.put(&#39;9&#39;, &#39;6&#39;);
        List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        // two cases: even or odd
        if(n%2==0)
        		generate(res, map, &amp;quot;&amp;quot;, n);
        else{
            // the central digit can be any number
        	for(int i = 0; i &amp;lt;= 9; i++)
        		generate(res, map, &amp;quot;&amp;quot;+i, n);
        }
        return res;
	}
	
	private static void generate(List&amp;lt;String&amp;gt; res, Map&amp;lt;Character, Character&amp;gt; map, String cur, int n) {
		if(cur.length() == n) {
			res.add(new String(cur));
			return;
		}
		
		for(Map.Entry&amp;lt;Character, Character&amp;gt; entry : map.entrySet()) {
			String origin = new String(cur);
			cur = entry.getKey() + cur + entry.getValue();
			generate(res, map, cur, n);
			cur = origin;
		}
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-iii&#34;&gt;Problem III&lt;/h2&gt;

&lt;p&gt;A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).&lt;/p&gt;

&lt;p&gt;Write a function to count the total strobogrammatic numbers that exist in the range of low &amp;lt;= num &amp;lt;= high.&lt;/p&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given low = &amp;laquo;50&amp;raquo;, high = &amp;laquo;100&amp;raquo;, return 3. Because 69, 88, and 96 are three strobogrammatic numbers.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;Because the range might be a large number, the low and high numbers are represented as string.&lt;/p&gt;

&lt;h3 id=&#34;solution-2&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static int strobogrammaticInRange(String low, String high) {
		Map&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
		map.put(&#39;0&#39;, &#39;0&#39;);
		map.put(&#39;1&#39;, &#39;1&#39;);
		map.put(&#39;8&#39;, &#39;8&#39;);
		map.put(&#39;6&#39;, &#39;9&#39;);
		map.put(&#39;9&#39;, &#39;6&#39;);
		int[] cnt = new int[1];
		for (int n = low.length(); n &amp;lt;= high.length(); n++) {
			if (n % 2 == 0)
				generateII(cnt, map, &amp;quot;&amp;quot;, n, low, high);
			else {
				for (int i = 0; i &amp;lt;= 9; i++)
					generateII(cnt, map, &amp;quot;&amp;quot; + i, n, low, high);
			}
		}
		return cnt[0];
	}

	private static void generateII(int[] cnt,
			Map&amp;lt;Character, Character&amp;gt; map, String cur, int n, String low,
			String high) {
		if (cur.length() == n) {
			if (cur.charAt(0) != &#39;0&#39; &amp;amp;&amp;amp; compare(low, cur) &amp;lt; 0
					&amp;amp;&amp;amp; compare(cur, high) &amp;lt; 0)
				cnt[0]++;
			return;
		}

		for (Map.Entry&amp;lt;Character, Character&amp;gt; entry : map.entrySet()) {
			String origin = new String(cur);
			cur = entry.getKey() + cur + entry.getValue();
			generateII(cnt, map, cur, n, low, high);
			cur = origin;
		}
	}

	private static int compare(String s1, String s2) {
		return Integer.compare(Integer.parseInt(s1), Integer.parseInt(s2));
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Scramble String</title>
      <link>http://xmruibi.github.io/2015/11/06/scramble-string/</link>
      <pubDate>Fri, 06 Nov 2015 22:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/06/scramble-string/</guid>
      <description>

&lt;p&gt;Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.&lt;/p&gt;

&lt;p&gt;Below is one possible representation of s1 = &lt;code&gt;&amp;quot;great&amp;quot;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To scramble the string, we may choose any non-leaf node and swap its two children.&lt;/p&gt;

&lt;p&gt;For example, if we choose the node &amp;laquo;gr&amp;raquo; and swap its two children, it produces a scrambled string &lt;code&gt;&amp;quot;rgeat&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We say that &lt;code&gt;&amp;quot;rgeat&amp;quot;&lt;/code&gt; is a scrambled string of &lt;code&gt;&amp;quot;great&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Similarly, if we continue to swap the children of nodes &amp;laquo;eat&amp;raquo; and &amp;laquo;at&amp;raquo;, it produces a scrambled string &lt;code&gt;&amp;quot;rgtae&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We say that &lt;code&gt;&amp;quot;rgtae&amp;quot;&lt;/code&gt; is a scrambled string of &lt;code&gt;&amp;quot;great&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think-dp-version&#34;&gt;Think - DP Version&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Ignore two situations: both length not equal and the characters not the same&lt;/li&gt;
&lt;li&gt;Two sequence but 3-D memorized array&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memo[i][j][k]&lt;/code&gt; means state: for s1.substring(i, i + k) and s2.substring(j, j + k), if they are scramble string&lt;/li&gt;
&lt;li&gt;Two conditions we can regard as scramble, for range of &lt;code&gt;word1(i -&amp;gt; i+k)&lt;/code&gt; or &lt;code&gt;word2(j -&amp;gt; j+k)&lt;/code&gt;:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i -&amp;gt; i + split&lt;/code&gt; = &lt;code&gt;j -&amp;gt; j + split&lt;/code&gt; (len = split) and &lt;code&gt;split + i -&amp;gt; i + k&lt;/code&gt; = &lt;code&gt;split + i -&amp;gt; j + k&lt;/code&gt; (len = k - split)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i -&amp;gt; i + split&lt;/code&gt; = &lt;code&gt;j + (k - split) -&amp;gt; j+k&lt;/code&gt; [len = split] and &lt;code&gt;i + split -&amp;gt; i+k&lt;/code&gt; = &lt;code&gt;j -&amp;gt; j + (k - split)&lt;/code&gt;(len = k - split)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Consider about the initialization:

&lt;ul&gt;
&lt;li&gt;for &lt;code&gt;k == 1&lt;/code&gt;, we only check if &lt;code&gt;word1[i] == word2[j]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param s1 A string
     * @param s2 Another string
     * @return whether s2 is a scrambled string of s1
     */
    public boolean isScramble(String s1, String s2) {
        // check length
        if(s1==null||s2==null||s1.length()!=s2.length())
            return false;
        // check anagram
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        Arrays.sort(c1);
        Arrays.sort(c2);
        if (!Arrays.equals(c1, c2))
			return false;
			
        if(s1.length() != s2.length())
            return false;
        int len = s1.length();
        
        // state: for s1.substring(i, i + k) and s2.substring(j, j + k), if they are scramble string
        boolean[][][] memo = new boolean[len][len][len+1];
        
        // initial, only check if s1[i] == s2[j] 
        for(int i=0;i&amp;lt;s1.length();i++)
            for(int j=0;j&amp;lt;s2.length();j++)
                memo[i][j][1] = (s1.charAt(i) == s2.charAt(j));
                
        for(int k = 2; k &amp;lt;= len; k++) {
            
            for(int i = 0; i &amp;lt;= len - k; i++) {
                for(int j = 0; j &amp;lt;= len - k; j++) {
                    // split point should start from 1 to k - 1
                    for(int split = 1; split &amp;lt; k; split++) {
                        memo[i][j][k] |= (memo[i][j][split]&amp;amp;&amp;amp;memo[i+split][j+split][k-split])||(memo[i][j+(k - split)][split]&amp;amp;&amp;amp;memo[i+split][j][k-split]);
                    }
                }
            }
        }
        return memo[0][0][len];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Word Break</title>
      <link>http://xmruibi.github.io/2015/11/06/word-break/</link>
      <pubDate>Fri, 06 Nov 2015 20:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/06/word-break/</guid>
      <description>

&lt;p&gt;Given a string s and a dictionary of words dict, determine if s can be break into a space-separated sequence of one or more dictionary words.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given s = &lt;code&gt;&amp;quot;lintcode&amp;quot;&lt;/code&gt;, dict = &lt;code&gt;[&amp;quot;lint&amp;quot;, &amp;quot;code&amp;quot;]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Return true because &amp;laquo;lintcode&amp;raquo; can be break as &amp;laquo;lint code&amp;raquo;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;One sequence DP, a 1-D boolean array.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memo[i]&lt;/code&gt; means from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;i&lt;/code&gt; has valid word break or not.&lt;/li&gt;
&lt;li&gt;Tricky part is when we pass at &lt;code&gt;i&lt;/code&gt; position, we don&amp;rsquo;t need to use &lt;code&gt;j&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;i&lt;/code&gt; for checking word existed in dictionary. We can use the length of word in dictionary as an length evaluation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param s: A string s
     * @param dict: A dictionary of words dict
     */
    public boolean wordBreak(String s, Set&amp;lt;String&amp;gt; dict) {
    
        if(s == null || s.length() == 0){
            if(dict == null || dict.size() == 0)
                return true;
            return false;
        }
        
        boolean[] memo = new boolean[s.length() + 1];
        memo[0] = true;
        for(int i = 1; i &amp;lt;= s.length(); i ++) {
            for(String ss : dict){
                int start = i - ss.length();
                if( start &amp;gt;= 0 &amp;amp;&amp;amp; memo[start]){
                    String str = s.substring(start, i);
                    if(dict.contains(str))
                         memo[i] = true;
                }
            }
        }
        return memo[s.length()];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Palindrome Partitioning</title>
      <link>http://xmruibi.github.io/2015/11/05/palindrome-partitioning/</link>
      <pubDate>Thu, 05 Nov 2015 20:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/05/palindrome-partitioning/</guid>
      <description>

&lt;h2 id=&#34;problem-i&#34;&gt;Problem I&lt;/h2&gt;

&lt;p&gt;Given a string s, partition s such that every substring of the partition is a palindrome.&lt;/p&gt;

&lt;p&gt;Return all possible palindrome partitioning of &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;Given s = &lt;code&gt;&amp;quot;aab&amp;quot;&lt;/code&gt;, return:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;],
  [&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;think&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Set a boolean matrix for check word segment is prlindrome or not. &lt;code&gt;[i][j]&lt;/code&gt; -&amp;gt; &lt;code&gt;word(i, j)&lt;/code&gt; is palindrome&lt;/li&gt;
&lt;li&gt;DFS to build up all palindrome partition solutions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param s: A string
     * @return: A list of lists of string
     */
    public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; partition(String s) {
        List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(s == null || s.length() == 0)
            return res;
        // get palindrome boolean matrix [i][j] -&amp;gt; word(i, j) is palindrome
        boolean[][] memo = new boolean[s.length()][s.length()];
        for(int i = s.length() - 1; i &amp;gt;= 0; i--) 
            for(int j = i; j &amp;lt; s.length(); j++) 
                memo[i][j] |= (j - i &amp;lt; 2 || memo[i+1][j-1]) &amp;amp;&amp;amp; s.charAt(i) == s.charAt(j);
        
        // setup dfs method     
        helper(res, new ArrayList&amp;lt;String&amp;gt;(), memo, s, 0);
        return res;
    }
    
    private void helper(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res, List&amp;lt;String&amp;gt; list, boolean[][] memo, String s, int idx) {
        if(idx &amp;gt;= s.length()) {
            res.add(new ArrayList&amp;lt;&amp;gt;(list));
            return;
        }
        
        for(int i = idx; i &amp;lt; s.length(); i++) {
            if(memo[idx][i]) {
                String substr = s.substring(idx,i+1);
                list.add(substr);
                helper(res, list, memo, s, i+1);
                list.remove(list.size() - 1);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;Given a string s, cut s into some substrings such that every substring is a palindrome.&lt;/p&gt;

&lt;p&gt;Return the &lt;strong&gt;minimum cuts&lt;/strong&gt; needed for a palindrome partitioning of s.&lt;/p&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;For example, given s = &lt;code&gt;&amp;quot;aab&amp;quot;&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;Return 1 since the palindrome partitioning &lt;code&gt;[&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;]&lt;/code&gt; could be produced using 1 cut.&lt;/p&gt;

&lt;h3 id=&#34;think-1&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;First step should be set up boolean matrix for check word segment is prlindrome or not. &lt;code&gt;[i][j]&lt;/code&gt; -&amp;gt; &lt;code&gt;word(i, j)&lt;/code&gt; is palindrome&lt;/li&gt;
&lt;li&gt;Then we need to have a array &lt;code&gt;res[i]&lt;/code&gt; to memorize the minimum cut from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;i&lt;/code&gt; position.&lt;/li&gt;
&lt;li&gt;Initial the first element in memorized array  as &lt;code&gt;0&lt;/code&gt; (no cut needed)&lt;/li&gt;
&lt;li&gt;Pass all position &lt;code&gt;i&lt;/code&gt; from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;When at &lt;code&gt;i&lt;/code&gt; position, we should try &lt;code&gt;j&lt;/code&gt; reversely (avoid update) from &lt;code&gt;j = i&lt;/code&gt; to &lt;code&gt;j = 0&lt;/code&gt; and check if &lt;code&gt;word(j, i-1)&lt;/code&gt; is palindrome.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;word(j, i-1)&lt;/code&gt; is palindrome, and &lt;code&gt;res[j]&lt;/code&gt; has valid minimum cut. Update &lt;code&gt;res[i]&lt;/code&gt; is necessary.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-1&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param s a string
     * @return an integer
     */
    public int minCut(String s) {
        if( s == null || s.length() == 0)
            return 0;
        // step one: boolean matrix for check word segment is prlindrome or not
        boolean[][] memo = new boolean[s.length()][s.length()];
        for(int i = s.length() - 1; i &amp;gt;= 0; i--) 
            for(int j = i; j &amp;lt; s.length(); j++) 
                memo[i][j] |= (j - i &amp;lt; 2 || memo[i+1][j-1]) &amp;amp;&amp;amp; s.charAt(i) == s.charAt(j);
        // step two: cut[i] memorized the minimum cut from `1` to `i` position
        int[] cut = new int[s.length() + 1];
        cut[0] = 0;
        for(int i = 0; i &amp;lt; s.length(); i++) {
            cut[i + 1] = Integer.MAX_VALUE; 
            for(int j = i; j &amp;gt;= 0; j --) {
                cut[i + 1] = memo[j][i] &amp;amp;&amp;amp; cut[j] != Integer.MAX_VALUE ?  Math.min(cut[i+1], cut[j] + 1) : cut[i+1];
            }
        }
        return cut[s.length()] - 1;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Distinct Subsequences</title>
      <link>http://xmruibi.github.io/2015/11/05/distinct-subsequences/</link>
      <pubDate>Thu, 05 Nov 2015 13:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/05/distinct-subsequences/</guid>
      <description>

&lt;p&gt;Given a string S and a string T, count the number of distinct subsequences of T in S.&lt;/p&gt;

&lt;p&gt;A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &amp;laquo;ACE&amp;raquo; is a subsequence of &amp;laquo;ABCDE&amp;raquo; while &amp;laquo;AEC&amp;raquo; is not).&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given S = &amp;laquo;rabbbit&amp;raquo;, T = &amp;laquo;rabbit&amp;raquo;, return 3.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it in $O(n^2)$ time and $O(n)$ memory.&lt;/p&gt;

&lt;p&gt;$O(n^2)$ memory is also acceptable if you do not know how to optimize memory.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Two sequence DP, setup 2-D array for memorizing&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][j]&lt;/code&gt; means the distinct count when &lt;code&gt;S(1,i)&lt;/code&gt; and &lt;code&gt;T(1,j)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If S has non character &lt;code&gt;dp[0][j]&lt;/code&gt; should be 0, while T has non character &lt;code&gt;dp[i][0]&lt;/code&gt; should be 1.&lt;/li&gt;
&lt;li&gt;Each time we add &lt;code&gt;S[i]&lt;/code&gt; on &lt;code&gt;dp[i-1][j]&lt;/code&gt;, iterate &lt;code&gt;j&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;len - 1&lt;/code&gt;, if &lt;code&gt;S[i] == T[j]&lt;/code&gt; we should look up the the result from &lt;code&gt;dp[i-1][j-1]&lt;/code&gt; and add it on &lt;code&gt;dp[i-1][j]&lt;/code&gt;, otherwise we add nothing.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param S, T: Two string.
     * @return: Count the number of distinct subsequences
     */
    public int numDistinct(String S, String T) {
        int[][] memo = new int[S.length() + 1][T.length() + 1];
        for(int i = 0; i &amp;lt;= S.length(); i++) {
            for(int j = 0; j &amp;lt;= T.length(); j++) {
                if(i == 0)
                    memo[i][j] = 0;
                if(j == 0)
                    memo[i][j] = 1;
                else{
                    memo[i][j] = memo[i-1][j] + (S.charAt(i-1) == T.charAt(j-1)) ? memo[i-1][j-1] : 0;
                }
            }
        }
        return memo[S.length()][T.length()];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Encode String</title>
      <link>http://xmruibi.github.io/2015/11/04/encode-string/</link>
      <pubDate>Wed, 04 Nov 2015 15:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/04/encode-string/</guid>
      <description>

&lt;p&gt;Given a String like &lt;code&gt;&amp;quot;ABBCCCC&amp;quot;&lt;/code&gt;, encode it to &lt;code&gt;A2B4C&lt;/code&gt;. Avoid to make the encode string larger than original string. Do it in-place! The repeat count should less than 10.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Pass the char array by reversed order so that it&amp;rsquo;s easier to modify the char to count number in-place&lt;/li&gt;
&lt;li&gt;Index passing should from &lt;code&gt;len - 2&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt;, this is tricky part to avoid the case when index is zero cannot be count&lt;/li&gt;
&lt;li&gt;The in-place modification index come from the &lt;code&gt;len - 1&lt;/code&gt;, rewrite the result char by this index&lt;/li&gt;
&lt;li&gt;For the integer convert to character, it may need to use &lt;code&gt;Character.forDigit(count, 10)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For those rest char less than rewrite index, set them as null character &lt;code&gt;&amp;quot;\u0000&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
  public static void main(String[] args) {
    String str = &amp;quot;ABC&amp;quot;;
    inplaceEncode(str.toCharArray());
  }
  
  public static void inplaceEncode(char[] chars){
    int idx = chars.length - 1;
    int count = 1;
    for(int i = chars.length - 2; i &amp;gt;= -1; i--) {
      if(i&amp;gt;=0 &amp;amp;&amp;amp; chars[i] == chars[i+1])
        count++;
      else {
        char cur = chars[i+1];
        if(count &amp;gt; 1){
          chars[idx--] = cur;
          chars[idx--] = Character.forDigit(count, 10);
        }else
          chars[idx--] = cur;
        count = 1;
      }
    }
    
    // place the rest char position as null char
    while(idx&amp;gt;=0)
      chars[idx--] = &#39;\u0000&#39;;
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Interleaving String</title>
      <link>http://xmruibi.github.io/2015/10/20/interleaving-string/</link>
      <pubDate>Tue, 20 Oct 2015 19:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/interleaving-string/</guid>
      <description>

&lt;p&gt;Given three strings: s1, s2, s3, determine whether s3 is formed by the interleaving of s1 and s2.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For s1 = &lt;code&gt;&amp;quot;aabcc&amp;quot;&lt;/code&gt;, s2 = &lt;code&gt;&amp;quot;dbbca&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When s3 = &lt;code&gt;&amp;quot;aadbbcbcac&amp;quot;&lt;/code&gt;, return true.
When s3 = &lt;code&gt;&amp;quot;aadbbbaccc&amp;quot;&lt;/code&gt;, return false.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n2) time or better&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Typical dynamic programming with subsequence problem.&lt;/li&gt;
&lt;li&gt;Set up a 2-D dp boolean table to memorized:

&lt;ul&gt;
&lt;li&gt;Initial: memo[0][0] = true;&lt;/li&gt;
&lt;li&gt;two conditions: s1 find matched or s2 find matched;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memo[i][j] = ( i &amp;gt; 0 &amp;amp;&amp;amp; s1.charAt(i - 1) == s3.charAt(i + j - 1) &amp;amp;&amp;amp; memo[i - 1][j]) || (s2.charAt(j - 1) == s3.charAt(i + j - 1) &amp;amp;&amp;amp; memo[i][j - 1])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * Determine whether s3 is formed by interleaving of s1 and s2.
     * @param s1, s2, s3: As description.
     * @return: true or false.
     */
    public boolean isInterleave(String s1, String s2, String s3) {

        if(s1 == null || s2 == null)
            return false;
        if(s1.length() + s2.length() != s3.length())
            return false;
            
        boolean[][] memo = new boolean[s1.length() + 1][s2.length() + 1];
        for(int i = 0; i &amp;lt;= s1.length(); i++) {
            for(int j = 0; j &amp;lt;= s2.length(); j++) {
                if(i == 0 &amp;amp;&amp;amp; j == 0)
                    memo[i][j] = true;
                else{
                    if(i &amp;gt; 0 &amp;amp;&amp;amp; s1.charAt(i - 1) == s3.charAt(i + j - 1))
                        memo[i][j] = memo[i - 1][j];
                    if(j &amp;gt; 0 &amp;amp;&amp;amp;s2.charAt(j - 1) == s3.charAt(i + j - 1))
                        memo[i][j] |= memo[i][j - 1];
                }
            }
        }
        
        return memo[s1.length()][s2.length()];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Integer to Roman</title>
      <link>http://xmruibi.github.io/2015/10/16/integer-to-roman/</link>
      <pubDate>Fri, 16 Oct 2015 21:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/16/integer-to-roman/</guid>
      <description>

&lt;p&gt;Given an integer, convert it to a roman numeral.&lt;/p&gt;

&lt;p&gt;The number is guaranteed to be within the range from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;3999&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;4&lt;/code&gt; -&amp;gt; &lt;code&gt;IV&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;12&lt;/code&gt; -&amp;gt; &lt;code&gt;XII&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;21&lt;/code&gt; -&amp;gt; &lt;code&gt;XXI&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;99&lt;/code&gt; -&amp;gt; &lt;code&gt;XCIX&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param n The integer
     * @return Roman representation
     */
    public String intToRoman(int n) {
        int[] numTab = {1,4,5,9,10,40,50,90,100,400,500,900,1000};
        String[] romanTab = {&amp;quot;I&amp;quot;, &amp;quot;IV&amp;quot;, &amp;quot;V&amp;quot;, &amp;quot;IX&amp;quot;, &amp;quot;X&amp;quot;, &amp;quot;XL&amp;quot;, &amp;quot;L&amp;quot;, &amp;quot;LC&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;CD&amp;quot;, &amp;quot;D&amp;quot;, &amp;quot;DM&amp;quot;,&amp;quot;M&amp;quot;};
        
        StringBuilder sb = new StringBuilder();
        for(int i = numTab.length - 1; i &amp;gt;= 0; i--) {
            while(n &amp;gt;= numTab[i]) {
                sb.append(romanTab[i]);
                n -= numTab[i];
            }
        }
        return sb.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Roman to Integer</title>
      <link>http://xmruibi.github.io/2015/10/16/roman-to-integer/</link>
      <pubDate>Fri, 16 Oct 2015 21:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/16/roman-to-integer/</guid>
      <description>

&lt;p&gt;Given a roman numeral, convert it to an integer.&lt;/p&gt;

&lt;p&gt;The answer is guaranteed to be within the range from 1 to 3999.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;IV&lt;/code&gt; -&amp;gt; &lt;code&gt;4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;XII&lt;/code&gt; -&amp;gt; &lt;code&gt;12&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;XXI&lt;/code&gt; -&amp;gt; &lt;code&gt;21&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;XCIX&lt;/code&gt; -&amp;gt; &lt;code&gt;99&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;clarification&#34;&gt;Clarification&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Symbol&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;1,000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;同一数码最多只能出现三次，如40不可表示为XXXX，而要表示为XL。&lt;/li&gt;
&lt;li&gt;在较大的罗马数字的右边记上较小的罗马数字，表示大数字加小数字。&lt;/li&gt;
&lt;li&gt;在较大的罗马数字的左边记上较小的罗马数字，表示大数字减小数字。&lt;/li&gt;
&lt;li&gt;左减的数字有限制，仅限于I、X、C。比如45不可以写成VL，只能是XLV。&lt;/li&gt;
&lt;li&gt;但是，左减时不可跨越一个位数。比如，99不可以用IC（100 - 1）表示，是用XCIX（[100 - 10] + [10 - 1]）表示。&lt;/li&gt;
&lt;li&gt;左减数字必须为一位，比如8写成VIII，而非IIX。&lt;/li&gt;
&lt;li&gt;右加数字不可连续超过三位，比如14写成XIV，而非XIIII。（见下方“数码限制”一项。）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param s Roman representation
     * @return an integer
     */
    public int romanToInt(String s) {
        // Write your code here
        HashMap&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&#39;I&#39;, 1);map.put(&#39;V&#39;, 5);
        map.put(&#39;X&#39;, 10);map.put(&#39;L&#39;, 50);
        map.put(&#39;C&#39;, 100);map.put(&#39;D&#39;, 500);
        map.put(&#39;M&#39;, 1000);
        
        int res = 0;
        for (int i = 0; i &amp;lt; s.length() ; i++) {
            if(i &amp;lt; s.length() - 1 &amp;amp;&amp;amp; map.get(s.charAt(i)) &amp;lt; map.get(s.charAt(i+1)) )
                res -= map.get(s.charAt(i));
            else
                res += map.get(s.charAt(i));
        }
        
        return res;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Common Subsequence</title>
      <link>http://xmruibi.github.io/2015/10/16/longest-common-subsequence/</link>
      <pubDate>Fri, 16 Oct 2015 09:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/16/longest-common-subsequence/</guid>
      <description>

&lt;p&gt;Given two strings, find the longest common subsequence (LCS).&lt;/p&gt;

&lt;p&gt;Your code should return the length of LCS.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;ABCD&lt;/code&gt; and &lt;code&gt;EDCA&lt;/code&gt;, the LCS is &lt;code&gt;A&lt;/code&gt; (or &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;), return 1.&lt;/p&gt;

&lt;p&gt;For &lt;code&gt;ABCD&lt;/code&gt; and &lt;code&gt;EACB&lt;/code&gt;, the LCS is &lt;code&gt;AC&lt;/code&gt;, return 2.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param A, B: Two strings.
     * @return: The length of longest common subsequence of A and B.
     */
    public int longestCommonSubsequence(String A, String B) {
        if(A == null || B == null)
            return 0;
        
        int[][] memo = new int[A.length()+1][B.length()+1];
        for(int i = 0; i &amp;lt;= A.length(); i ++) {
            for(int j = 0; j &amp;lt;= B.length(); j ++) {
                if(i == 0 || j == 0)
                    memo[i][j] = 0;
                else
                    memo[i][j] = (A.charAt(i-1) == B.charAt(j-1) ? memo[i-1][j-1] + 1 : Math.max(memo[i][j-1],memo[i-1][j]));
            }
        }
        return memo[A.length()][B.length()];
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>