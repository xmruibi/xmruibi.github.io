<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Object Oriented Programming on Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/tags/object-oriented-programming/</link>
    <description>Recent content in Object Oriented Programming on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Wed, 21 Oct 2015 15:16:26 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/tags/object-oriented-programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Parking Lot</title>
      <link>http://xmruibi.github.io/2015/10/21/parking-lot/</link>
      <pubDate>Wed, 21 Oct 2015 15:16:26 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/21/parking-lot/</guid>
      <description>

&lt;p&gt;Design a parking lot with object-oriented programming principle.&lt;/p&gt;

&lt;h2 id=&#34;basic-object&#34;&gt;Basic Object&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Vehicle

&lt;ul&gt;
&lt;li&gt;size of vehicle (small, medium, large)&lt;/li&gt;
&lt;li&gt;status of vehicle (run or parked)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sedan, SUV, Bus, Truck&amp;hellip; extends Vehicle&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Slot&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;size of slot&lt;/li&gt;
&lt;li&gt;status (available or not)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lot&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;hold slots in lot&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Vehicle&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Vehicle {
	private final int size;
	private final int lisense;
	private boolean status;
	private Lot lot;

	public Vehicle(int size) {
		this.size = size;
		lisense = this.hashCode();
		lot = Lot.getInstance();
	}

	public void setStatus(boolean status) {
		this.status = status;
	}

	private Slot findSlot() {

		Slot slot;
		switch (this.size) {
		case 1:
			slot = lot.getSmallSlots().remove(0);
		case 2:
			slot = lot.getCompactSlots().remove(0);
		case 3:
			slot = lot.getLargeSlots().remove(0);
		default:
			slot = null;
		}
		return slot;
	}

	public void park() {
		Slot slot = findSlot();
		if (slot != null) {
			lot.occupiedSlots.put(this.lisense, slot);
			slot.occupy(this);
		}
	}

	public void leave() {
		Slot slot = lot.occupiedSlots.remove(this.lisense);
		slot.release();
		switch (this.size) {
		case 1:
			lot.getSmallSlots().add(slot);
		case 2:
			lot.getCompactSlots().add(slot);
		case 3:
			lot.getLargeSlots().add(slot);
		}
	}
}

public class Car extends Vehicle{
	public Car(){
		super(1);		
	}
}
public class Truck extends Vehicle{
	public Truck(){
		super(2);		
	}
}
// ... other type of vehicle
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Lot&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Lot {
	private static Lot lot = null;

	private static final int NUMBER_OF_SMALL_SLOTS = 10;
	private static final int NUMBER_OF_COMPACT_SLOTS = 10;
	private static final int NUMBER_OF_LARGE_SLOTS = 10;

	public Map&amp;lt;Integer, Slot&amp;gt; occupiedSlots;
	private List&amp;lt;Slot&amp;gt; smallSlots;
	private List&amp;lt;Slot&amp;gt; compactSlots;
	private List&amp;lt;Slot&amp;gt; largeSlots;

	private Lot() {
		smallSlots = new LinkedList&amp;lt;&amp;gt;();
		compactSlots = new LinkedList&amp;lt;&amp;gt;();
		largeSlots = new LinkedList&amp;lt;&amp;gt;();
		occupiedSlots = new HashMap&amp;lt;&amp;gt;();
		for (int i = 1; i &amp;lt;= NUMBER_OF_SMALL_SLOTS; i++)
			smallSlots.add(new Slot(i, 1));

		for (int i = 1; i &amp;lt;= NUMBER_OF_COMPACT_SLOTS; i++)
			compactSlots.add(new Slot(i, 2));

		for (int i = 1; i &amp;lt;= NUMBER_OF_LARGE_SLOTS; i++)
			largeSlots.add(new Slot(i, 3));

	}

	public List&amp;lt;Slot&amp;gt; getSmallSlots() {
		return smallSlots;
	}

	public List&amp;lt;Slot&amp;gt; getCompactSlots() {
		return compactSlots;
	}

	public List&amp;lt;Slot&amp;gt; getLargeSlots() {
		return largeSlots;
	}

	public static Lot getInstance() {
		if (lot == null)
			lot = new Lot();
		return lot;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Slot&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class Slot {
	private final int id;
	private final int size;
	private boolean available;
	private Vehicle vehicle;

	public Slot(int id, int size) {
		this.id = id;
		this.size = size;
		this.available = true;
	}

	public void occupy(Vehicle v) {
		this.vehicle = v;
		this.available = false;
	}

	public void release() {
		this.vehicle = null;
		this.available = true;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Conclusion on Object Oriented Programming</title>
      <link>http://xmruibi.github.io/2015/10/21/conclusion-on-object-oriented-programming/</link>
      <pubDate>Wed, 21 Oct 2015 11:16:26 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/21/conclusion-on-object-oriented-programming/</guid>
      <description>

&lt;h2 id=&#34;principles&#34;&gt;Principles&lt;/h2&gt;

&lt;h3 id=&#34;open-close&#34;&gt;Open - Close&lt;/h3&gt;

&lt;h5 id=&#34;open-for-extension-but-closed-for-modifications&#34;&gt;Open for extension but closed for modifications&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;The design and writing of the code should be done in a way that new functionality should be added with minimum changes in the existing code. The design should be done in a way to allow the adding of new functionality as new classes, keeping as much as possible existing code unchanged.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;example&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ShapeEditor{
    void drawShape(Shape s){
        if (s.m_type==1)
 			drawRectangle(s);
 		else if (s.m_type==2)
 			drawCircle(s);
 	};
    void drawRectangle(Shape s);
    void drawCircle(Shape s);
}
class Shape{}
class Rectangle extends Shape{}
class Circle extends Shape{}

//---&amp;gt; Every time if new shape added, we have to modify method in the editor class, which violates this rule!
// ---&amp;gt; change!!! write draw method in each shape concreted class
class Shape{ abstract void draw(); }
class Rectangle extends Shape{ public void draw() { /*draw the rectangle*/} }
class Circle extends Shape{ public void draw() { /*draw the circle*/} }
class ShapeEditor{
    void drawShape(Shape s){ s.draw(); }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dependency-inversion&#34;&gt;Dependency Inversion&lt;/h3&gt;

&lt;p&gt;The low level classes the classes which implement basic and primary operations(disk access, network protocols,&amp;hellip;) and high level classes the classes which encapsulate complex logic(business flows, &amp;hellip;). The last ones rely on the low level classes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;High-level modules should not depend on low-level modules. Both should depend on abstractions.&lt;/p&gt;

&lt;p&gt;Abstractions should not depend on details. Details should depend on abstractions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;When this principle is applied it means the high level classes are not working directly with low level classes, they are using interfaces as an abstract layer.&lt;/p&gt;

&lt;h5 id=&#34;example-1&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class WorkerWithTechOne{}
class Manager{
    WorkerWithTechOne worker;
}
// --&amp;gt; what if add other workers with other techniques?
// --&amp;gt; abstract worker!
interface Worker{}
class WorkerWithTechOne implements Worker{}
class WorkerWithTechTwo implements Worker{}
class Manager{
    Worker worker;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;interface-segregation&#34;&gt;Interface Segregation&lt;/h3&gt;

&lt;h5 id=&#34;clients-should-not-be-forced-to-depend-upon-interfaces-that-they-don-t-use&#34;&gt;Clients should not be forced to depend upon interfaces that they don&amp;rsquo;t use.&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;Instead of one fat interface, many small interfaces are preferred based on groups of methods, each one serving one submodule.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&#34;example-2&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface work{
    public void work();
    // too much methods!
    public void life();
    public void rest();
}
// ---&amp;gt; change!!!
interface work{public void work();}
interface life{public void life();}
interface rest{public void rest();}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;single-responsibility&#34;&gt;Single Responsibility&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;A class should have only one reason to change.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A simple and intuitive principle, but in practice it is sometimes hard to get it right.&lt;/p&gt;

&lt;p&gt;This principle states that if we have 2 reasons to change for a class, we have to split the functionality in two classes. Each class will handle only one responsibility and on future if we need to make one change we are going to make it in the class which handle it. When we need to make a change in a class having more responsibilities the change might affect the other functionality of the classes.&lt;/p&gt;

&lt;h5 id=&#34;example-3&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Iemail{
    public void setSender(String sender);
	public void setReceiver(String receiver);
	public void setContent(String content);
	// --&amp;gt; change!!!
	public void setContent(Content content);
}
// --&amp;gt; Content can be change to HTML or JSON or other kinds of format
// so it should be splited 
interface Content {
	public String getAsString(); // used for serialization
}
class email implement Iemail{
    public void setSender(String sender) { set sender; }
	public void setReceiver(String receiver) { set receiver; }
	public void setContent(String content) {set content; }
	// --&amp;gt; change!!!
	public void setContent(Content content) { set content; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;liskov-s-substitution&#34;&gt;Liskov&amp;rsquo;s Substitution&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Derived types must be completely substitutable for their base types.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This principle is just an extension of the Open Close Principle and it means that we must make sure that new derived classes are extending the base classes without changing their behavior.&lt;/p&gt;

&lt;p&gt;This principle considers what kind of derived class should extends a base class.&lt;/p&gt;

&lt;h5 id=&#34;example-4&#34;&gt;Example&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Violation of Likov&#39;s Substitution Principle
class Rectangle {
	protected int m_width;
	protected int m_height;

	public void setWidth(int width){ m_width = width; }
	public void setHeight(int height){ m_height = height; }
}

class Square extends Rectangle {
	public void setWidth(int width){
		m_width = width;	m_height = width;
	}
	public void setHeight(int height){
		m_width = height;	m_height = height;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;muddiest-points&#34;&gt;Muddiest Points&lt;/h2&gt;

&lt;h3 id=&#34;composite-v-s-aggregation&#34;&gt;Composite v.s Aggregation&lt;/h3&gt;

&lt;h5 id=&#34;simple-rules&#34;&gt;Simple rules:&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;A &amp;laquo;owns&amp;raquo; B = Composition : B has no meaning or purpose in the system without A&lt;/p&gt;

&lt;p&gt;A &amp;laquo;uses&amp;raquo; B = Aggregation : B exists independently (conceptually) from A&lt;/p&gt;

&lt;h5 id=&#34;example-1-1&#34;&gt;Example 1:&lt;/h5&gt;
&lt;/blockquote&gt;

&lt;p&gt;A Company is an aggregation of People. A Company is a composition of Accounts. When a Company ceases to do business its Accounts cease to exist but its People continue to exist.&lt;/p&gt;

&lt;h5 id=&#34;example-2-very-simplified&#34;&gt;Example 2: (very simplified)&lt;/h5&gt;

&lt;p&gt;A Text Editor owns a Buffer (composition). A Text Editor uses a File (aggregation). When the Text Editor is closed, the Buffer is destroyed but the File itself is not destroyed.&lt;/p&gt;

&lt;h3 id=&#34;interface-v-s-abstract-class&#34;&gt;Interface v.s Abstract Class&lt;/h3&gt;

&lt;h4 id=&#34;interface&#34;&gt;Interface&lt;/h4&gt;

&lt;h5 id=&#34;characters&#34;&gt;Characters&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Allow multiple inheritance.&lt;/li&gt;
&lt;li&gt;No concrete method.&lt;/li&gt;
&lt;li&gt;No constructor.&lt;/li&gt;
&lt;li&gt;No instance variable, it only allow static final constant with the assignment.&lt;/li&gt;
&lt;li&gt;Can extend interface.&lt;/li&gt;
&lt;li&gt;Cannot be initialized. But sometime the interface can initialized by providing anonymous inner class.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;guide&#34;&gt;Guide&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;When you think that the API will not change for a while.&lt;/li&gt;
&lt;li&gt;When you want to have something similar to multiple inheritance.&lt;/li&gt;
&lt;li&gt;Enforce developer to implement the methods defined in interface.&lt;/li&gt;
&lt;li&gt;Interface are used to represent adjective or behavior&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;abstract-class&#34;&gt;Abstract Class&lt;/h4&gt;

&lt;h5 id=&#34;characters-1&#34;&gt;Characters&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Can extend abstract class.&lt;/li&gt;
&lt;li&gt;Allow concrete method, provide some default behavior.&lt;/li&gt;
&lt;li&gt;Allow abstract method.&lt;/li&gt;
&lt;li&gt;Cannot be initialized.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;guide-1&#34;&gt;Guide&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;On time critical application prefer abstract class is slightly faster than interface.&lt;/li&gt;
&lt;li&gt;If there is a genuine common behavior across the inheritance hierarchy which can be coded better at one place than abstract class is preferred choice.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;all-in-all&#34;&gt;All in all&lt;/h4&gt;

&lt;p&gt;Interface and abstract class can work together also where defining function in interface and default functionality on abstract class.
It also called &lt;strong&gt;Skeletal Implementations&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;OO Design Website: &lt;a href=&#34;http://www.oodesign.com/&#34;&gt;oodesign.com&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;OOD Question on Stackexchange: &lt;a href=&#34;http://programmers.stackexchange.com/questions/61376/aggregation-vs-composition&#34;&gt;Composite v.s Aggregation&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Online Book Reader System</title>
      <link>http://xmruibi.github.io/2015/10/21/online-book-reader-system/</link>
      <pubDate>Wed, 21 Oct 2015 11:16:26 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/21/online-book-reader-system/</guid>
      <description>

&lt;p&gt;This question comes from the book named &amp;laquo;Cracking Code Interview&amp;raquo;, Chapter 7; It is very very easy problem with thinking about the insert/remove/update/retrieve action.&lt;/p&gt;

&lt;h4 id=&#34;functionality&#34;&gt;Functionality&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;User Membership Creation and Extension&lt;/li&gt;
&lt;li&gt;Search the book in memory&lt;/li&gt;
&lt;li&gt;Reading the book&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;analysis&#34;&gt;Analysis&lt;/h2&gt;

&lt;h4 id=&#34;objects&#34;&gt;Objects&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Book:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ID&lt;/li&gt;
&lt;li&gt;Title&lt;/li&gt;
&lt;li&gt;Author&lt;/li&gt;
&lt;li&gt;Content&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Books: (In-memory storage for many book objects)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Set&lt;Book&gt;&lt;/li&gt;
&lt;li&gt;Method

&lt;ul&gt;
&lt;li&gt;find&lt;/li&gt;
&lt;li&gt;add&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;User&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ID&lt;/li&gt;
&lt;li&gt;Name&lt;/li&gt;
&lt;li&gt;accoutnType
-&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Users&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Set&lt;User&gt;&lt;/li&gt;
&lt;li&gt;Method

&lt;ul&gt;
&lt;li&gt;find&lt;/li&gt;
&lt;li&gt;add&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Deck of Card</title>
      <link>http://xmruibi.github.io/2015/10/21/deck-of-card/</link>
      <pubDate>Wed, 21 Oct 2015 10:16:26 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/21/deck-of-card/</guid>
      <description>

&lt;p&gt;Design the data structure for a generic deck of cards. How you would subclass it to implement particular card games?&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;Card has suit and value; Suit has four kinds with Club, Spadem Heart and Diamond.&lt;/p&gt;

&lt;h4 id=&#34;about-enum-type&#34;&gt;About Enum Type&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;enum 类型不支持 public 和 protected 修饰符的构造方法，因此构造函数一定要是 private 或 friendly 的。也正因为如此，所以枚举对象是无法在程序中通过直接调用其构造方法来初始化的。&lt;/li&gt;
&lt;li&gt;定义 enum 类型时候，如果是简单类型 (No more constructor)，那么最后一个枚举值后不用跟任何一个符号；但如果有定制方法，那么最后一个枚举值与后面代码要用分号&amp;rsquo;;&amp;lsquo;隔开，不能用逗号或空格。&lt;/li&gt;
&lt;li&gt;由于 enum 类型的值实际上是通过运行期构造出对象来表示的，所以在 cluster 环境下，每个虚拟机都会构造出一个同义的枚举对象。因而在做比较操作时候就需要注意，如果直接通过使用等号 ( ‘ == ’ ) 操作符，这些看似一样的枚举值一定不相等，因为这不是同一个对象实例。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Card {
	// Define the Suit by Enum type
	public enum Suit {
		CLUBS(1), SPADE(2), HEART(3), DIAMOND(4);
		int value;
		private Suit(int val) {
			this.value = val;
		}
	}

	// Card has suit and value, only two kind of data need to store
	int val;
	Suit suit;


	public Card(int value, Suit suit) {
		this.val = value;
		this.suit = suit;
	}

	public int getVal(){
		return this.val;
	}

	public Suit getSuit(){
		return this.suit;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;blackjack&#34;&gt;BlackJack&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Face cards (kings, queens, and jacks) are counted as ten points.&lt;/li&gt;
&lt;li&gt;Ace can be counted as 1 point or 11 points&lt;/li&gt;
&lt;li&gt;Other cards with value less than ten should be counted as what it values.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
class BlackJack extends Card{
	public BlackJack(int val, Suit suit) {
		super(val, suit);
	}

	@Override
	public int getVal(){
		int value = super.getVal();
		if(value &amp;lt; 10)
			return value；
		else if(value == 1)
			return 11;
		return 10;
	}

	public boolean isAce(){
		return super.getVal() == 1;
	}
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>