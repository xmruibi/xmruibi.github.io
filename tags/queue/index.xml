<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Queue on Geek Think</title>
    <link>http://xmruibi.github.io/tags/queue/</link>
    <description>Recent content in Queue on Geek Think</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Wed, 18 Nov 2015 12:43:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/tags/queue/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LRU Problem</title>
      <link>http://xmruibi.github.io/2015/11/18/lru-problem/</link>
      <pubDate>Wed, 18 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/18/lru-problem/</guid>
      <description>&lt;p&gt;Given the max size of a LRU cache and a input array, calculate the miss times.&lt;/p&gt;

&lt;p&gt;## Solution&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public int CacheMiss(int[] array, int size) {
		if(array == null)	
			return 0;
		Queue&amp;lt;Integer&amp;gt; cache = new LinkedList&amp;lt;Integer&amp;gt;();
		HashSet&amp;lt;Integer&amp;gt; hash = new HashSet&amp;lt;&amp;gt;();
		int count = 0;
		for (int i = 0; i &amp;lt; array.length; i++) {
			if(hash.contains(array[i])) {
				cache.remove(array[i]); // if hit it need to move it back, so remove here at first
			} else {
				count++; // miss, increse the count
			}
			cache.add(array[i]);
			hash.add(new Integer(array[i]));
			if (size == cache.size()) // over size, poll the first of queue
				cache.poll();
		}
		return count;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Process Schedule Problems</title>
      <link>http://xmruibi.github.io/2015/11/18/process-schedule-problems/</link>
      <pubDate>Wed, 18 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/18/process-schedule-problems/</guid>
      <description>

&lt;p&gt;Process schedule is very important to Operation System. There are several algorithm to deal with such problem. Here we discuss two of them. At first, we are given a process class for coding conveninence.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Process implements Comparable&amp;lt;Process&amp;gt; {
	int arrTime;
	int exeTime;

	public Process(int arrTime, int exeTime) {
		this.arrTime = arrTime;
		this.exeTime = exeTime;
	}

	// for shortest job first problem
	@Override
	public int compareTo(Process that) {
		if (this.exeTime == that.exeTime)
			return this.arrTime - that.arrTime;
		return this.exeTime - that.exeTime;
	}

	@Override
	public String toString() {
		return &amp;quot;arrTime: &amp;quot; + this.arrTime;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-one:fd5fbfca02af2e560dbb93ca15b4bf95&#34;&gt;Problem One&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Robin Round:&lt;/strong&gt; The question is about the robin round. Given an array with start time of each task and another array represent the executing time of each task and &lt;code&gt;q&lt;/code&gt; for quantum which is allowance of CPU time, means the maximum time for exeuting one task. Write a function, calculate the average waiting time on each task.&lt;/p&gt;

&lt;h2 id=&#34;solution-robin-round:fd5fbfca02af2e560dbb93ca15b4bf95&#34;&gt;Solution #Robin Round&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public double robinRound(int[] arrTime, int[] exeTime, int q) {
		// edge cases
		if (arrTime == null || exeTime == null
				|| exeTime.length != arrTime.length)
			return 0;

		int waitTime = 0; // total Waiting time
		int len = arrTime.length; // the len of time list
		int idx = 0; // pointer for iterate through time list
		Queue&amp;lt;Process&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); // store those processes

		int curTime = 0; // tracking current time
		while (!queue.isEmpty() || idx &amp;lt; len) {
			if (queue.isEmpty()) {
				queue.offer(new Process(arrTime[idx], exeTime[idx]));
				curTime = arrTime[idx++];
			} else {
				// poll out a Process from queue
				Process curP = queue.poll();
				// calculate the waiting time on this process and add it to the
				// total waitTime
				waitTime += Math.abs(curP.arrTime - curTime);
				// update curTime track according to the limit of &#39;q&#39;
				curTime = Math.min(curTime + q, curTime + curP.exeTime);
				while (idx &amp;lt; len &amp;amp;&amp;amp; arrTime[idx] &amp;lt;= curTime)
					queue.offer(new Process(arrTime[idx], exeTime[idx++]));
				// if the current process still not be executed according to the
				// &#39;quantum&#39; limit, use curTime minus that &#39;q&#39; as new exeTime
				// and count curTime as new arrTime for new Process, then put it
				// back to the queue
				if (curP.exeTime &amp;gt; q) {
					curP.exeTime -= q;
					curP.arrTime = curTime;
					queue.offer(curP);
				}
			}
		}
		return (double) waitTime / len;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-two:fd5fbfca02af2e560dbb93ca15b4bf95&#34;&gt;Problem Two&lt;/h2&gt;

&lt;p&gt;Given an array with start time of each task and another array represent the executing time of each task. Process these task by the principle that the shortest job should always run firstly. Write a function to achieve that.&lt;/p&gt;

&lt;h2 id=&#34;solution-shortest-job-first:fd5fbfca02af2e560dbb93ca15b4bf95&#34;&gt;Solution #Shortest Job First&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public static double shortestJobFirst(int[] arrTime, int[] exeTime) {
		if (arrTime == null || exeTime == null
				|| exeTime.length != arrTime.length)
			return 0;

		int waitTime = 0; // total Waiting time
		int len = arrTime.length; // the len of time list
		int idx = 0; // pointer for iterate through time list
		PriorityQueue&amp;lt;Process&amp;gt; heap = new PriorityQueue&amp;lt;&amp;gt;();
		int curTime = 0; // tracking current time
		while (!heap.isEmpty() || idx &amp;lt; len) {
			if (heap.isEmpty()) {
				heap.offer(new Process(arrTime[idx], exeTime[idx]));
				curTime = arrTime[idx++];
			} else {
				Process curP = heap.poll();
				System.out.println(curP);
				waitTime += Math.abs(curP.arrTime - curTime);
				curTime += curP.exeTime;
				while (idx &amp;lt; len &amp;amp;&amp;amp; arrTime[idx] &amp;lt;= curTime)
					heap.offer(new Process(arrTime[idx], exeTime[idx++]));
			}
		}
		return (double) waitTime / len;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Rotate Matrix</title>
      <link>http://xmruibi.github.io/2015/11/18/rotate-matrix/</link>
      <pubDate>Wed, 18 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/18/rotate-matrix/</guid>
      <description>

&lt;p&gt;Given A Matrix and rotate by input flag represent the direction of rotation.&lt;/p&gt;

&lt;h2 id=&#34;solution:18934d05988ea6297312db56d76fae0e&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public int[][] rotateMatrix(int[][] matrix, boolean flag) {
		int n = matrix.length - 1;
		// in-place solution
		for (int i = 0; i &amp;lt; n; i++) {
			for (int j = i; j &amp;lt; n - i; j++) {
			// do it in 1/4 area of matrix
				int temp;
				if(flag) {
					temp = matrix[j][n - i];
					matrix[j][n - i] = matrix[i][j];
					matrix[i][j] = matrix[n - j][i];
					matrix[n - j][i] = matrix[n - i][n - j];
					matrix[n - i][n - j] = temp;
				}else{
					temp = matrix[n - i][n - j];
					matrix[n - i][n - j] = matrix[n - j][i];
					matrix[n - j][i] = matrix[i][j];
					matrix[i][j] = matrix[j][n - i];
					matrix[j][n - i] = temp;
				}
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>