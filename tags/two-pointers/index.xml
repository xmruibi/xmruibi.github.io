<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Two Pointers on Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/tags/two-pointers/</link>
    <description>Recent content in Two Pointers on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Sun, 25 Oct 2015 20:33:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/tags/two-pointers/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Convert Sorted List to Binary Search Tree</title>
      <link>http://xmruibi.github.io/2015/10/25/convert-sorted-list-to-binary-search-tree/</link>
      <pubDate>Sun, 25 Oct 2015 20:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/convert-sorted-list-to-binary-search-tree/</guid>
      <description>

&lt;p&gt;Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;               2
1-&amp;gt;2-&amp;gt;3  =&amp;gt;   / \
             1   3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Find the middle point in list&lt;/li&gt;
&lt;li&gt;Divide and Conquer to build left child and right child node&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head: The first node of linked list.
     * @return: a tree node
     */
    public TreeNode sortedListToBST(ListNode head) {  
        // write your code here
        if(head == null)
            return null;
        if(head.next == null)
            return new TreeNode(head.val);
            
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode runner = head;
        ListNode walker = dummy;
        while(runner!=null &amp;amp;&amp;amp; runner.next!=null) {
            runner = runner.next.next;
            walker = walker.next;
        }
        
        ListNode m = walker.next;
        TreeNode root = new TreeNode(m.val);
        ListNode left = dummy.next;
        ListNode right = walker.next.next;
        walker.next = null;
        root.left = sortedListToBST(left);
        root.right = sortedListToBST(right);
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Remove Duplicates from Sorted List II</title>
      <link>http://xmruibi.github.io/2015/10/25/remove-duplicates-from-sorted-list-ii/</link>
      <pubDate>Sun, 25 Oct 2015 20:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/remove-duplicates-from-sorted-list-ii/</guid>
      <description>

&lt;p&gt;Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5&lt;/code&gt;, return &lt;code&gt;1-&amp;gt;2-&amp;gt;5&lt;/code&gt;.
Given &lt;code&gt;1-&amp;gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3&lt;/code&gt;, return &lt;code&gt;2-&amp;gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param ListNode head is the head of the linked list
     * @return: ListNode head of the linked list
     */
    public static ListNode deleteDuplicates(ListNode head) {
        // write your code here
        if(head == null || head.next == null)
            return head;
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        while(head != null){
            ListNode cur = head;
            while(head.next != null &amp;amp;&amp;amp; cur.val == head.next.val)
                head = head.next;
            
            if(head != cur){
                pre.next = head.next;
            }else
                pre = pre.next;
            head = head.next;
        }
        
        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Copy List with Random Pointer</title>
      <link>http://xmruibi.github.io/2015/10/25/copy-list-with-random-pointer/</link>
      <pubDate>Sun, 25 Oct 2015 20:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/copy-list-with-random-pointer/</guid>
      <description>

&lt;p&gt;Merge k sorted linked lists and return it as one sorted list.&lt;/p&gt;

&lt;p&gt;Analyze and describe its complexity.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given lists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  2-&amp;gt;4-&amp;gt;null,
  null,
  -1-&amp;gt;null
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return &lt;code&gt;-1-&amp;gt;2-&amp;gt;4-&amp;gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use a heap to receive element from linked list&lt;/li&gt;
&lt;li&gt;Tricky part:

&lt;ul&gt;
&lt;li&gt;Just entered k node in heap instead of pass all nodes in lists.&lt;/li&gt;
&lt;li&gt;When poll out element, it also need to push back the next node of polled node.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param lists: a list of ListNode
     * @return: The head of one sorted list.
     */
    public ListNode mergeKLists(List&amp;lt;ListNode&amp;gt; lists) {  
        if(lists == null)
            return null;
        
        PriorityQueue&amp;lt;ListNode&amp;gt; queue = new PriorityQueue&amp;lt;ListNode&amp;gt;(10, new Comparator&amp;lt;ListNode&amp;gt;(){
            @Override
            public int compare(ListNode o1, ListNode o2){
                return Integer.compare(o1.val, o2.val);
            }
        });
        // O(n) : n total nodes 
        for(ListNode node : lists){
            if(node != null)
                queue.offer(node);
        }
        
        ListNode dummy = new ListNode(0);
        ListNode pre = dummy;
        while(!queue.isEmpty()){
            ListNode cur = queue.remove();
            if(cur.next != null)
                queue.offer(cur.next);
            pre.next = cur;
            pre = cur;
        }
        
        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Remove Nth Node From End of List</title>
      <link>http://xmruibi.github.io/2015/10/25/remove-nth-node-from-end-of-list/</link>
      <pubDate>Sun, 25 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/remove-nth-node-from-end-of-list/</guid>
      <description>

&lt;p&gt;Given a linked list, remove the nth node from the end of list and return its head.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given linked list: &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;null&lt;/code&gt;, and n = &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After removing the second node from the end, the linked list becomes &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;5-&amp;gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The minimum number of nodes in list is n.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n) time&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Typical idea on runner and walker linked list question&lt;/li&gt;
&lt;li&gt;Let runner node run for N step further than walker node.&lt;/li&gt;
&lt;li&gt;Get the N + 1 th position from end of list.&lt;/li&gt;
&lt;li&gt;Remove walker.next which is the target node.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head: The first node of linked list.
     * @param n: An integer.
     * @return: The head of linked list.
     */
    ListNode removeNthFromEnd(ListNode head, int n) {
        if(head==null)
            return head;
        ListNode runner = head;
        ListNode pre = new ListNode(0);
        pre.next = head;
        ListNode walker = pre;
        while(n&amp;gt;0&amp;amp;&amp;amp;runner!=null){
            runner = runner.next;
            n--;
        }
        while(runner!=null){
            runner = runner.next;
            walker = walker.next;
        }
        walker.next = walker.next.next;
        return pre.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Copy List with Random Pointer</title>
      <link>http://xmruibi.github.io/2015/10/25/copy-list-with-random-pointer/</link>
      <pubDate>Sun, 25 Oct 2015 15:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/copy-list-with-random-pointer/</guid>
      <description>

&lt;p&gt;A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.&lt;/p&gt;

&lt;p&gt;Return a deep copy of the list.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Could you solve it with O(1) space?&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Three pass:

&lt;ul&gt;
&lt;li&gt;Clone every node and attach it right next of original node,&lt;/li&gt;
&lt;li&gt;Copy the random pointer for clone node (the next of origianl node&amp;rsquo;s random pointer)&lt;/li&gt;
&lt;li&gt;Cut down the original and clone one&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head: The head of linked list with a random pointer.
     * @return: A new head of a deep copy of the list.
     */
    public RandomListNode copyRandomList(RandomListNode head) {
        // write your code here
        if(head == null)
            return null;
        RandomListNode dummyHead = head;
        while(head != null) {
            RandomListNode clone = new RandomListNode(head.label);
            RandomListNode next = head.next;
            head.next = clone;
            clone.next = next;
            head = next;
        }
        head = dummyHead;
        while(head != null) {
            RandomListNode clone = head.next;
            if(head.random != null)
                clone.random = head.random.next;
            head = clone.next;
        }
        head = dummyHead;
        RandomListNode resHead = dummyHead.next;
        while(head != null) {
            RandomListNode clone = head.next;
            head.next = clone.next;
            head = head.next;
            if(head != null)
                clone.next = head.next;
        }
        
        return resHead;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Insertion Sort for Linked List</title>
      <link>http://xmruibi.github.io/2015/10/25/insertion-sort-for-linked-list/</link>
      <pubDate>Sun, 25 Oct 2015 15:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/insertion-sort-for-linked-list/</guid>
      <description>

&lt;p&gt;Sort a linked list using insertion sort.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;1-&amp;gt;3-&amp;gt;2-&amp;gt;0-&amp;gt;null&lt;/code&gt;, return &lt;code&gt;0-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Pass nodes from head to end.&lt;/li&gt;
&lt;li&gt;Once it get an element larger than its next one, do a swap.&lt;/li&gt;
&lt;li&gt;Then return to the head and to do the passing again.&lt;/li&gt;
&lt;li&gt;Loop until get all sorted.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head: The first node of linked list.
     * @return: The head of linked list.
     */
    public ListNode insertionSortList(ListNode head) {
        if(head == null || head.next == null)
            return head;
            
            ListNode dummy = new ListNode(0);
            ListNode pre = dummy;
            ListNode cur = head;
            while(cur != null){
                pre = dummy;
                ListNode next = cur.next;
                while(pre.next != null &amp;amp;&amp;amp; pre.next.val &amp;lt; cur.val)
                    pre = pre.next;
                cur.next = pre.next;
                pre.next = cur;
                cur = next;
            }
            
            return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Reverse Nodes in k-Group</title>
      <link>http://xmruibi.github.io/2015/10/25/reverse-nodes-in-k-group/</link>
      <pubDate>Sun, 25 Oct 2015 15:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/reverse-nodes-in-k-group/</guid>
      <description>

&lt;p&gt;Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.&lt;/p&gt;

&lt;p&gt;If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.&lt;/p&gt;

&lt;p&gt;You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given this linked list: &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For k = &lt;code&gt;2&lt;/code&gt;, you should return: &lt;code&gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For k = &lt;code&gt;3&lt;/code&gt;, you should return: &lt;code&gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Consider the list like following:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;	
	dummy(pre) -&amp;gt; l1 -&amp;gt; l2 -&amp;gt; l3 -&amp;gt; l4 -&amp;gt; l5 -&amp;gt; null
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Get the reversed segment:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; when cnt % k == 0:

		pre.next	  node  node.next
		   |            |     |
	pre -&amp;gt; l1 -&amp;gt; l2 -&amp;gt; l3 -&amp;gt; l4 -&amp;gt; l5 -&amp;gt; null

		  last	  ----&amp;gt;	     end
		    |		          |
	pre -&amp;gt; l1 -&amp;gt; l2 -&amp;gt; l3 -&amp;gt; l4 -&amp;gt; l5 -&amp;gt; null
			|     |	    
		pre.next pre.next(final status)	
			   \     \
			      |  -&amp;gt; |     |
				 cur   cur	 cur.next (final status)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head a ListNode
     * @param k an integer
     * @return a ListNode
     */
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head == null || head.next == null)
            return head;
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        int cnt = 1;
        ListNode front = head;
        while(head != null) {
            if(cnt % k == 0) {
                pre = reverse(pre, head.next);
                head = pre.next;
            }else
                head = head.next;
            cnt++;
        }
        return dummy.next;
    }
    
    private ListNode reverse(ListNode pre, ListNode end) {
        ListNode last = pre.next, cur = last.next;
        while(cur != end) {
            last.next = cur.next;
            cur.next = pre.next;
            pre.next = cur;
            cur = last.next;
        }
        return last;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Intersection of Two Linked Lists</title>
      <link>http://xmruibi.github.io/2015/10/18/intersection-of-two-linked-lists/</link>
      <pubDate>Sun, 18 Oct 2015 11:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/intersection-of-two-linked-lists/</guid>
      <description>

&lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;The following two linked lists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;begin to intersect at node c1.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;If the two linked lists have no intersection at all, return null.
The linked lists must retain their original structure after the function returns.
You may assume there are no cycles anywhere in the entire linked structure.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Count the length of each linked list&lt;/li&gt;
&lt;li&gt;Make two counts to be equal, then start moving and check if there are two nodes the same as each other.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param headA: the first list
     * @param headB: the second list
     * @return: a ListNode 
     */
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        
        ListNode a = headA;
        ListNode b = headB;
        int alen = 0, blen = 0;
        
        while(a!=null) {
            a = a.next;
            alen++;
        }
        while(b!=null) {
            b = b.next;
            blen++;
        }
        
        while(alen &amp;gt; blen) {
            headA = headA.next;
            alen--;
        }
        
        while(alen &amp;lt; blen) {
            headB = headB.next;
            blen--;
        }
        
        while(headA != null &amp;amp;&amp;amp; headB != null) {
            if(headA == headB)
                return headA;
            headA = headA.next;
            headB = headB.next;
        }
        return null;
    }  
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Flatten Binary Tree to Linked List</title>
      <link>http://xmruibi.github.io/2015/10/17/flatten-binary-tree-to-linked-list/</link>
      <pubDate>Sat, 17 Oct 2015 17:50:34 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/17/flatten-binary-tree-to-linked-list/</guid>
      <description>

&lt;p&gt;Flatten a binary tree to a fake &amp;laquo;linked list&amp;raquo; in pre-order traversal.&lt;/p&gt;

&lt;p&gt;Here we use the right pointer in TreeNode as the next pointer in ListNode.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;              1
               \
     1          2
    / \          \
   2   5    =&amp;gt;    3
  / \   \          \
 3   4   6          4
                     \
                      5
                       \
                        6
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;Don&amp;rsquo;t forget to mark the left child of each node to null. Or you will get Time Limit Exceeded or Memory Limit Exceeded.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it in-place without any extra memory.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;One pass with iterate each right node.&lt;/li&gt;
&lt;li&gt;Put left node to right node.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param root: a TreeNode, the root of the binary tree
     * @return: nothing
     */
    public void flatten(TreeNode root) {
        TreeNode node = root;
        while(node!=null) {
            if(node.left != null) {
                TreeNode left = node.left;
                while(left.right != null) {
                    left = left.right;
                }
                left.right = node.right;
                node.right = node.left;
                node.left = null;
            }
            node = node.right;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Swap Nodes in Pairs</title>
      <link>http://xmruibi.github.io/2015/10/17/swap-nodes-in-pairs/</link>
      <pubDate>Sat, 17 Oct 2015 17:50:34 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/17/swap-nodes-in-pairs/</guid>
      <description>

&lt;p&gt;Given a linked list, swap every two adjacent nodes and return its head.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Record next two node:  dummy pre -&amp;gt; A -&amp;gt; B -&amp;gt; C.&lt;/li&gt;
&lt;li&gt;Get C as next, change pre.next to B(head.next), B.next to A(head) and A(head.next) to C.&lt;/li&gt;
&lt;li&gt;Do while loop when head and head.next are both not null node&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param head a ListNode
     * @return a ListNode
     */
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;

        while(head != null &amp;amp;&amp;amp; head.next != null) {

            ListNode next = head.next.next;
            pre.next = head.next;
            pre.next.next = head;
            pre = head;
            head.next = next;
            head = next;
        }
        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Substring Without Repeating Characters</title>
      <link>http://xmruibi.github.io/2015/10/15/longest-substring-without-repeating-characters/</link>
      <pubDate>Thu, 15 Oct 2015 09:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/15/longest-substring-without-repeating-characters/</guid>
      <description>

&lt;p&gt;Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For example, the longest substring without repeating letters for &lt;code&gt;abcabcbb&lt;/code&gt; is &lt;code&gt;abc&lt;/code&gt;, which the length is 3.&lt;/p&gt;

&lt;p&gt;For &lt;code&gt;bbbbb&lt;/code&gt; the longest substring is &lt;code&gt;b&lt;/code&gt;, with the length of 1.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n) time&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Set two pointers as a windows for input string.&lt;/li&gt;
&lt;li&gt;Very simple idea, to use a hashset to store the characters in a window (substring) in string.&lt;/li&gt;
&lt;li&gt;While the repeat detect, move forward the previous pointer.&lt;/li&gt;
&lt;li&gt;Update the max window size each time.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param s: a string
     * @return: an integer 
     */
    public int lengthOfLongestSubstring(String s) {
        Set&amp;lt;Character&amp;gt; disc = new HashSet&amp;lt;&amp;gt;();
        
        int maxLen = 0;
        int prev = 0;
        for(int i = 0; i &amp;lt; s.length(); i++) {
            char c = s.charAt(i);
            
            while(disc.contains(c)){
                disc.remove(s.charAt(prev++));
            }
            maxLen = Math.max(maxLen, i - prev + 1);
            disc.add(c);
        }
        return maxLen;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Substring with At Most K Distinct Characters Show result</title>
      <link>http://xmruibi.github.io/2015/10/08/longest-substring-with-at-most-k-distinct-characters-show-result/</link>
      <pubDate>Thu, 08 Oct 2015 22:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/08/longest-substring-with-at-most-k-distinct-characters-show-result/</guid>
      <description>

&lt;p&gt;Given a string s, find the length of the longest substring T that contains at most k distinct characters.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For example, Given s = &lt;code&gt;eceba&lt;/code&gt;, k = 3,&lt;/p&gt;

&lt;p&gt;T is &lt;code&gt;eceb&lt;/code&gt; which its length is 4.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n), n is the size of the string s.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Set two pointers as a windows for input string.&lt;/li&gt;
&lt;li&gt;Use a hashmap to store the characters in a window (substring) in string.&lt;/li&gt;
&lt;li&gt;However, we notice that we use hashmap for count the character appearance times.&lt;/li&gt;
&lt;li&gt;Remove the character as a key only if the count for this key is zero.&lt;/li&gt;
&lt;li&gt;Update the max window size each time.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param s : A string
     * @return : The length of the longest substring 
     *           that contains at most k distinct characters.
     */
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        if(s == null)
            return 0;
        
        HashMap&amp;lt;Character, Integer&amp;gt; dict = new HashMap&amp;lt;&amp;gt;();
        
        int prev = 0;
        int maxLen = 0;
        for(int i = 0; i &amp;lt; s.length(); i++) {
            char c = s.charAt(i);
            if(dict.containsKey(c)) {
                dict.put(c, dict.get(c) + 1);
            }else {
                dict.put(c, 1);
                while(dict.size() &amp;gt; k) {
                    char prevChar = s.charAt(prev++);
                    if(dict.get(prevChar) &amp;gt; 1)
                        dict.put(prevChar, dict.get(prevChar) - 1);
                    else
                        dict.remove(prevChar);
                }
            }
            maxLen = Math.max(maxLen, i - prev + 1);
        }
        
        return maxLen;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the first I made a mistake by using hashset. However, like the previous mentioned, we need to count the character appearance. Why? Since there is possible when the character on index &lt;code&gt;prev&lt;/code&gt; has another one in this window. But when you simply remove this element, there is still one inside this window. Tha makes the mistake happened!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Say, in &lt;code&gt;acdab&lt;/code&gt;, pointer &lt;code&gt;prev&lt;/code&gt; is on first &lt;code&gt;a&lt;/code&gt;, once we do &lt;code&gt;set.remove(a)&lt;/code&gt;, the &lt;code&gt;size()&lt;/code&gt; become 3, but in fact, it is still 4.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    // This is the wrong code!!!
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        // write your code here
        Set&amp;lt;Character&amp;gt; disc = new HashSet&amp;lt;&amp;gt;();
        
        int maxLen = 0;
        int prev = 0;
        for(int i = 0; i &amp;lt; s.length(); i++) {
            char c = s.charAt(i);
            disc.add(c);
            while(disc.size() &amp;gt; k){
                disc.remove(s.charAt(prev++));
            }
            maxLen = Math.max(maxLen, i - prev + 1);
        }
        return maxLen;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Minimum Window Substring</title>
      <link>http://xmruibi.github.io/2015/10/08/minimum-window-substring/</link>
      <pubDate>Thu, 08 Oct 2015 22:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/08/minimum-window-substring/</guid>
      <description>

&lt;p&gt;Given a string source and a string target, find the minimum window in source which will contain all the characters in target.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;source = &amp;laquo;ADOBECODEBANC&amp;raquo; target = &amp;laquo;ABC&amp;raquo; Minimum window is &amp;laquo;BANC&amp;raquo;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;If there is no such window in source that covers all characters in target, return the emtpy string &amp;laquo;&amp;raquo;.&lt;/p&gt;

&lt;p&gt;If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in source.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Can you do it in time complexity O(n) ?&lt;/p&gt;

&lt;h3 id=&#34;clarification&#34;&gt;Clarification&lt;/h3&gt;

&lt;p&gt;The characters in minimum window doesn&amp;rsquo;t need to has the same order in target.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public String minWindow(String source, String target) {
        // preload for target checking
        if(source == null || source.length() == 0 || target == null || target.length() == 0)
            return &amp;quot;&amp;quot;;
        
        
        int tarLen = target.length();
        HashMap&amp;lt;Character, Integer&amp;gt; dict = new HashMap&amp;lt;&amp;gt;();
        for(char c : target.toCharArray()) 
            dict.put(c, dict.containsKey(c)? dict.get(c) + 1 : 1);
        
        int hitCount = 0; // record current window hits how many characters in target
        int prevIdx = 0; // record the left bound of current window
        int minWindow = source.length() + 1; // initial the minimum window length
        int start = 0;
        for(int i = 0; i &amp;lt; source.length(); i++) {
            char cur = source.charAt(i);
            // if current char is not in dict, continue
            if(!dict.containsKey(cur))
                continue;
            
            dict.put(cur, dict.get(cur) - 1);
            if(dict.get(cur) &amp;gt;= 0)
                hitCount++;
            
            // check the windows has amount of this char more than it in target string
            // loop until the amount back to normal, but always reduce the prev index char
            while(hitCount == tarLen) {
                if( minWindow &amp;gt; i - prevIdx + 1) {
                    start = prevIdx;
                    minWindow = i - prevIdx + 1;
                }
                char prevChar = source.charAt(prevIdx);
                if(dict.containsKey(prevChar)) {
                    dict.put(prevChar, dict.get(prevChar)+1);
                    if(dict.get(prevChar) &amp;gt; 0)
                        hitCount--;
                }
                prevIdx++;
            }
        }
        // 
        if(minWindow &amp;gt; source.length())
            return &amp;quot;&amp;quot;;
        return source.substring(start, start + minWindow);
    }

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Partition Array</title>
      <link>http://xmruibi.github.io/2015/10/08/partition-array/</link>
      <pubDate>Thu, 08 Oct 2015 22:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/08/partition-array/</guid>
      <description>&lt;p&gt;Given an array &lt;code&gt;nums&lt;/code&gt; of integers and an int &lt;code&gt;k&lt;/code&gt;, partition the array (i.e move the elements in &amp;laquo;nums&amp;raquo;) such that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All elements &amp;lt; k are moved to the left&lt;/li&gt;
&lt;li&gt;All elements &amp;gt;= k are moved to the right&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Return the partitioning index, i.e the first index i nums[i] &amp;gt;= k.&lt;/p&gt;

&lt;p&gt;Solution:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Typical index rotate two pointer problem, looks like the idea of quick sort .&lt;/li&gt;
&lt;li&gt;Set an index &lt;code&gt;pivot&lt;/code&gt; for marking the real position of element less than &lt;code&gt;k&lt;/code&gt; during pass the orginal array.&lt;/li&gt;
&lt;li&gt;Once the current passing index &lt;code&gt;i&lt;/code&gt; hits the element less than &lt;code&gt;k&lt;/code&gt;, we do the swap with &lt;code&gt;pivot&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Make sure the &lt;code&gt;pivot&lt;/code&gt; should add 1 after swap since the marked position is increase for next one.&lt;/li&gt;
&lt;li&gt;However in new &lt;code&gt;pivot&lt;/code&gt; position we not sure the element&amp;rsquo;s value, so&amp;hellip; we need to check in next procedure.&lt;/li&gt;
&lt;li&gt;Make sure the &lt;code&gt;i&lt;/code&gt; position decrease 1, because we just did a swap and we need to check the new &lt;code&gt;i&lt;/code&gt; is less than &amp;lsquo;k&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /** 
     *@param nums: The integer array you should partition
     *@param k: As description
     *return: The index after partition
     */
    public int partitionArray(int[] nums, int k) {
        if(nums == null || nums.length == 0)
            return 0;
            
        int pivot = 0;
        for(int i = 0; i &amp;lt; nums.length; i++) {
            if(i &amp;gt; pivot &amp;amp;&amp;amp; nums[i] &amp;lt; k) {
                int tmp = nums[pivot];
                nums[pivot++] = nums[i];
                nums[i--] = tmp;
            }
        }
        // this is just for corner case when the last element still less than k
        if(nums[nums.length - 1] &amp;lt; k)
            return nums.length;
        return pivot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Search In 2D Matrix II</title>
      <link>http://xmruibi.github.io/2015/09/22/search-in-2d-matrix-ii/</link>
      <pubDate>Tue, 22 Sep 2015 13:35:30 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/09/22/search-in-2d-matrix-ii/</guid>
      <description>

&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix, return the occurrence of it.&lt;/p&gt;

&lt;p&gt;This matrix has the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Integers in each row are sorted from left to right.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Integers in each column are sorted from up to bottom.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;No duplicate integers in each row or column.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Typical Matrix Search Problem, using a condition for driven coordinate moving.&lt;/li&gt;
&lt;li&gt;Here the value and target comparasion is the driven condition.&lt;/li&gt;
&lt;li&gt;Since the sorted matrix, we can start from right top element.&lt;/li&gt;
&lt;li&gt;Because on the diagonal from right top to left down, all the left elements are less than the right elments.&lt;/li&gt;
&lt;li&gt;So we have three type of running condition and set the x, y coordinate differently.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
&lt;code class=&#34;java&#34;&gt;
public class Solution {
    /**
     * @param matrix: A list of lists of integers
     * @param: A number you want to search in the matrix
     * @return: An integer indicate the occurrence of target in the given matrix
     */

    public int searchMatrix(int[][] matrix, int target) {
        // write your code here
        if(matrix == null || matrix.length == 0)
            return 0;
        int rightTop = matrix[0][matrix[0].length - 1];
        int x = 0, y = matrix[0].length - 1;
        int occ = 0;
        while(x &lt; matrix.length &amp;&amp; y &gt;= 0) {
            int cur = matrix[x][y];
            if(cur == target) {
                occ ++;
                x++; y--;
            }else if(cur &lt; target)
                x++;
            else
                y--;
        }       
        return occ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>