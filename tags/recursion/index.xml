<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Recursion on Geek Think</title>
    <link>http://xmruibi.github.io/tags/recursion/</link>
    <description>Recent content in Recursion on Geek Think</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Mon, 09 Nov 2015 20:33:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/tags/recursion/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Factor Combinations</title>
      <link>http://xmruibi.github.io/2015/11/09/factor-combinations/</link>
      <pubDate>Mon, 09 Nov 2015 20:33:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/09/factor-combinations/</guid>
      <description>

&lt;p&gt;Numbers can be regarded as product of its factors. For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;8 = 2 x 2 x 2;
  = 2 x 4.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Write a function that takes an integer n and return all possible combinations of its factors.&lt;/p&gt;

&lt;h3 id=&#34;note:d3fa2271d6e080f445f18820b36a73ed&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;Each combination’s factors must be sorted ascending, for example: The factors of &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;6&lt;/code&gt; is &lt;code&gt;[2, 6]&lt;/code&gt;, not &lt;code&gt;[6, 2]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may assume that n is always positive.&lt;/p&gt;

&lt;p&gt;Factors should be greater than 1 and less than n.&lt;/p&gt;

&lt;h3 id=&#34;examples:d3fa2271d6e080f445f18820b36a73ed&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;input: &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;output: &lt;code&gt;[]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;input: &lt;code&gt;37&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;output: &lt;code&gt;[]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;input: &lt;code&gt;12&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;output:
&lt;code&gt;[ [2, 6], [2, 2, 3], [3, 4] ]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;input: &lt;code&gt;32&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;output:
&lt;code&gt;[ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ]&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think:d3fa2271d6e080f445f18820b36a73ed&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;For input value &lt;code&gt;n&lt;/code&gt;, it has possible factors start from &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;Sqrt(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For every factor, we also calculate its factors, like: &lt;code&gt;16 -&amp;gt; 2, 8 -&amp;gt; 2, 2, 4 -&amp;gt; 2, 2, 2, 2, 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Build helper function, the only difference between main recursion and helper recursion function is, in helper, we have to consider about the input value is one of factor which should also include in result list&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:d3fa2271d6e080f445f18820b36a73ed&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; getFactors(int n) {
        // use hashset to avoid replicate
        Set&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new HashSet&amp;lt;&amp;gt;();
        int end = (int) Math.sqrt(n);
        for (int i = 2; i &amp;lt;= end; i++) {
            if (n % i != 0)
                continue;
            List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; prev = helper(n / i);
            for (List&amp;lt;Integer&amp;gt; each : prev) {
                each.add(i);
                // make sure the elements are sorted
                Collections.sort(each);
                res.add(each);
            }
        }
        return  new ArrayList&amp;lt;&amp;gt;(res);
    }

    private List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; helper(int n) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        // add it self which is also a factor
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(n);
        res.add(list);

        int end = (int) Math.sqrt(n);
        for (int i = 2; i &amp;lt;= end; i++) {
            if (n % i != 0)
                continue;
            List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; prev = helper(n / i);
            for (List&amp;lt;Integer&amp;gt; each : prev) {
                each.add(i);
                res.add(each);
            }
        }
        return res;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Print Numbers by Recursion</title>
      <link>http://xmruibi.github.io/2015/10/26/print-numbers-by-recursion/</link>
      <pubDate>Mon, 26 Oct 2015 16:33:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/10/26/print-numbers-by-recursion/</guid>
      <description>

&lt;p&gt;Print numbers from 1 to the largest number with &lt;code&gt;N&lt;/code&gt; digits by recursion.&lt;/p&gt;

&lt;h3 id=&#34;example:ba94cf21c77b209e1a4c304ec207129a&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;N = 1&lt;/code&gt;, return &lt;code&gt;[1,2,3,4,5,6,7,8,9]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Given &lt;code&gt;N = 2&lt;/code&gt;, return &lt;code&gt;[1,2,3,4,5,6,7,8,9,10,11,12,...,99]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note:ba94cf21c77b209e1a4c304ec207129a&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s pretty easy to do recursion like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;recursion(i) {
    if i &amp;gt; largest number:
        return
    results.add(i)
    recursion(i + 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However this cost a lot of recursion memory as the recursion depth maybe very large ($10^n - 1$). Can you do it in another way to recursive with at most N depth?&lt;/p&gt;

&lt;h3 id=&#34;challenge:ba94cf21c77b209e1a4c304ec207129a&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it in recursion, not for-loop.&lt;/p&gt;

&lt;h2 id=&#34;think:ba94cf21c77b209e1a4c304ec207129a&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Think from bottom to top.&lt;/li&gt;
&lt;li&gt;Build the result list from number with one digits to N digits.&lt;/li&gt;
&lt;li&gt;Since we considering with digits as its deep, we have to set a loop to add the number in list on the new-generated base number (1 - 9 with following digits):&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;when zero digit, none;
when one digit, new-generated base number is 1, add 1,2,...9;
when two digit, new-generated base number is 10, add 10,20,...90;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Each time when having the new-generated base number, we need to pass through the original result list to fill the rest of number with beginning as new-generated base number.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;when one digit, new-generated base number is 1, add 1,2,...9, but original result list has nothing. so just add itself;
when two digit, new-generated base number is 10, when add 10, go back the original result list with &amp;quot;1, 2, 3,..., 9&amp;quot;, add them as 11, 12, 13, ..., 19, when add 20, go back the original result list with &amp;quot;1, 2, 3,..., 9&amp;quot;, add them as 21, 22, 23, ..., 29;
so the same as for 30,..., 90, 100, ..., 900, ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:ba94cf21c77b209e1a4c304ec207129a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param n: An integer.
     * return : An array storing 1 to the largest number with n digits.
     */
    public List&amp;lt;Integer&amp;gt; numbersByRecursion(int n) {
        List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(n &amp;gt;= 0)
            add(res, n);
        return res;
    }
    
    private int add(List&amp;lt;Integer&amp;gt; res, int n){
        if(n == 0)
            return 1;
        
        int cur = add(res, n - 1);
        int size = res.size();
        for(int i = 1; i &amp;lt;= 9; i ++) {
            int digit = i * cur;
            res.add(digit);
            for(int j = 0; j &amp;lt; size; j++) {
                res.add(digit + res.get(j));
            }
        }
        return cur * 10;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis:ba94cf21c77b209e1a4c304ec207129a&#34;&gt;Complexity Analysis&lt;/h2&gt;

&lt;p&gt;Time: $$O(10^n - 1)$$&lt;/p&gt;

&lt;p&gt;Space: $$O(n)$$&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>N Queen I</title>
      <link>http://xmruibi.github.io/2015/10/17/n-queen-i/</link>
      <pubDate>Sat, 17 Oct 2015 17:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/10/17/n-queen-i/</guid>
      <description>

&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.&lt;/p&gt;

&lt;p&gt;Given an integer n, return all distinct solutions to the n-queens puzzle.&lt;/p&gt;

&lt;p&gt;Each solution contains a distinct board configuration of the n-queens&amp;rsquo; placement, where &amp;lsquo;Q&amp;rsquo; and &amp;lsquo;.&amp;rsquo; both indicate a queen and an empty space respectively.&lt;/p&gt;

&lt;h3 id=&#34;example:e3e639c63f954205f552ff514d76c69b&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;There exist two distinct solutions to the 4-queens puzzle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[

    [&amp;quot;.Q..&amp;quot;, // Solution 1

     &amp;quot;...Q&amp;quot;,

     &amp;quot;Q...&amp;quot;,

     &amp;quot;..Q.&amp;quot;],

    [&amp;quot;..Q.&amp;quot;, // Solution 2

     &amp;quot;Q...&amp;quot;,

     &amp;quot;...Q&amp;quot;,

     &amp;quot;.Q..&amp;quot;]

]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:e3e639c63f954205f552ff514d76c69b&#34;&gt;Solution:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use one diamension int array to represent board: index -&amp;gt; num, value -&amp;gt; col;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /**
     * Get all distinct N-Queen solutions
     * @param n: The number of queens
     * @return: All distinct solutions
     * For example, A string &#39;...Q&#39; shows a queen on forth position
     */
    ArrayList&amp;lt;ArrayList&amp;lt;String&amp;gt;&amp;gt; solveNQueens(int n) {
        ArrayList&amp;lt;ArrayList&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        int[] board = new int[n]; 
        recursion(res, board, 0);
        return res;
    }
    
    
    private void recursion(ArrayList&amp;lt;ArrayList&amp;lt;String&amp;gt;&amp;gt; res, int[] board, int row) {
        if(row == board.length) {
            // encode the board from 1-d array to string list
            ArrayList&amp;lt;String&amp;gt; cur = new ArrayList&amp;lt;&amp;gt;();
            for(int i = 0 ; i &amp;lt; board.length; i++){
                StringBuilder sb = new StringBuilder();
                for(int j = 0 ; j &amp;lt; board.length; j++) {
                    if(j == board[i])
                        sb.append(&amp;quot;Q&amp;quot;);
                    else
                        sb.append(&amp;quot;.&amp;quot;);
                }
                cur.add(sb.toString());
            }
            res.add(cur);
            return;
        }
        // recursion
        for(int i = 0; i &amp;lt; board.length; i++) {
            board[row] = i;
            if(isSafe(board, row))
                recursion(res, board, row+1);
        }
            
    }
    
    /**
    * Check the current board is safe.
    */
    private boolean isSafe(int[] board, int row) {
        for(int i = 0; i &amp;lt; row; i++) {
            // difference on col value shouldn&#39;t equal to the difference on row value;
            if((board[i]==board[row]) || (Math.abs(i - row) == Math.abs(board[i] - board[row])))
                return false;
        }
        return true;
    }
};

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>N Queen II</title>
      <link>http://xmruibi.github.io/2015/10/17/n-queen-ii/</link>
      <pubDate>Sat, 17 Oct 2015 17:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/10/17/n-queen-ii/</guid>
      <description>&lt;p&gt;Follow up for N-Queens problem.&lt;/p&gt;

&lt;p&gt;Now, instead outputting board configurations, return the total number of distinct solutions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /**
     * Calculate the total number of distinct N-Queen solutions.
     * @param n: The number of queens.
     * @return: The total number of distinct solutions.
     */
    private int solutions = 0;
    public int totalNQueens(int n) {
        //write your code here
        int[] board = new int[n]; 
        recursion(board, 0);
        return solutions;
    }
    
    private void recursion(int[] board, int row) {
        // when valid solution found
        if(row == board.length) {
            solutions++;
            return;
        }
        // recursion
        for(int i = 0; i &amp;lt; board.length; i++) {
            board[row] = i;
            if(isSafe(board, row))
                recursion(board, row+1);
        }
            
    }
    
    private boolean isSafe(int[] board, int row) {
        for(int i = 0; i &amp;lt; row; i++) {
            if((board[i]==board[row]) || (Math.abs(i - row) == Math.abs(board[i] - board[row])))
                return false;
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Letter Combinations of a Phone Number</title>
      <link>http://xmruibi.github.io/2015/10/14/letter-combinations-of-a-phone-number/</link>
      <pubDate>Wed, 14 Oct 2015 20:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/10/14/letter-combinations-of-a-phone-number/</guid>
      <description>

&lt;p&gt;Given a digit string, return all possible letter combinations that the number could represent.&lt;/p&gt;

&lt;h3 id=&#34;example:49f63381cb14e1b96f95b6892f55b425&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;23&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Return &lt;code&gt;[&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note:49f63381cb14e1b96f95b6892f55b425&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;Although the above answer is in lexicographical order, your answer could be in any order you want.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param digits A digital string
     * @return all posible letter combinations
     */
    public ArrayList&amp;lt;String&amp;gt; letterCombinations(String digits) {
        ArrayList&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(digits == null ||digits.length() == 0)
            return res;
        HashMap&amp;lt;Character, String&amp;gt; dict = new HashMap&amp;lt;&amp;gt;();
        dict.put(&#39;2&#39;,&amp;quot;abc&amp;quot;);dict.put(&#39;3&#39;,&amp;quot;def&amp;quot;);dict.put(&#39;4&#39;,&amp;quot;ghi&amp;quot;);dict.put(&#39;5&#39;,&amp;quot;jkl&amp;quot;);
        dict.put(&#39;6&#39;,&amp;quot;mno&amp;quot;);dict.put(&#39;7&#39;,&amp;quot;pqrs&amp;quot;);dict.put(&#39;8&#39;,&amp;quot;tuv&amp;quot;);dict.put(&#39;9&#39;,&amp;quot;wxyz&amp;quot;);

        helper(dict, res, &amp;quot;&amp;quot;, digits, 0);
        return res;
    }
    
    private void helper(HashMap&amp;lt;Character, String&amp;gt; dict, ArrayList&amp;lt;String&amp;gt; res, String str, String digits, int idx) {
        if(idx == digits.length()) {
            res.add(new String(str));
            return;
        }
        String letters = dict.get(digits.charAt(idx));
        for(int i = 0; i &amp;lt; letters.length(); i++) {
            str += letters.charAt(i);
            helper(dict, res, str, digits, idx + 1);
            str = str.substring(0, idx);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>