<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bfs on Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/tags/bfs/</link>
    <description>Recent content in Bfs on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Mon, 09 Nov 2015 18:23:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Graph Valid Tree</title>
      <link>http://xmruibi.github.io/2015/11/09/graph-valid-tree/</link>
      <pubDate>Mon, 09 Nov 2015 18:23:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/09/graph-valid-tree/</guid>
      <description>

&lt;p&gt;Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given n = &lt;code&gt;5&lt;/code&gt; and edges = &lt;code&gt;[[0, 1], [0, 2], [0, 3], [1, 4]]&lt;/code&gt;, return true.
Given n = &lt;code&gt;5&lt;/code&gt; and edges = &lt;code&gt;[[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]&lt;/code&gt;, return false.&lt;/p&gt;

&lt;h3 id=&#34;hint&#34;&gt;Hint&lt;/h3&gt;

&lt;h5 id=&#34;the-definition-of-tree-on-wikipedia&#34;&gt;The definition of tree on Wikipedia:&lt;/h5&gt;

&lt;blockquote&gt;
&lt;p&gt;a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;note-you-can-assume-that-no-duplicate-edges-will-appear-in-edges-since-all-edges-are-undirected-0-1-is-the-same-as-1-0-and-thus-will-not-appear-together-inedges&#34;&gt;Note: You can assume that no duplicate edges will appear in edges. Since all edges are undirected, &lt;code&gt;[0, 1]&lt;/code&gt; is the same as &lt;code&gt;[1, 0]&lt;/code&gt; and thus will not appear together inedges.&lt;/h6&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;Given n = &lt;code&gt;5&lt;/code&gt; and edges = &lt;code&gt;[[0, 1], [1, 2], [3, 4]]&lt;/code&gt;, what should your return? Is this case a valid tree?&lt;/p&gt;

&lt;p&gt;No, isolate node shouldn&amp;rsquo;t be allowed.&lt;/p&gt;

&lt;p&gt;Design a Node class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    private class Node {
		int val;
		List&amp;lt;Integer&amp;gt; neighbors;

		public Node(int val) {
			this.val = val;
			this.neighbors = new ArrayList&amp;lt;&amp;gt;();
		}
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-bfs&#34;&gt;Solution #BFS&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public boolean validTree(int n, int[][] edges) {
		Node[] nodes = new Node[n];
		for (int i = 0; i &amp;lt; nodes.length; i++)
			nodes[i] = new Node(i);
		for (int[] edge : edges) {
			nodes[edge[0]].neighbors.add(edge[1]);
			nodes[edge[1]].neighbors.add(edge[0]);
		}

		boolean[] visited = new boolean[n];
		Queue&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;Integer&amp;gt;();
		queue.offer(0);

		while (!queue.isEmpty()) {
			int vertexId = queue.poll();
			// touch the cycle
			if (visited[vertexId]) 
				return false;
			
			visited[vertexId] = true;
			for (int neighbor : nodes[vertexId].neighbors) {
				if (!visited[neighbor])
					queue.offer(neighbor);
			}
		}

		// Check the isolate
		for (boolean v : visited) {
			if (!v)
				return false;
		}
		return true;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-dfs&#34;&gt;Solution #DFS&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public boolean validTreeDFS(int n, int[][] edges) {
        Node[] nodes = new Node[n];
        for (int i = 0; i &amp;lt; nodes.length; i++)
            nodes[i] = new Node(i);
        for (int[] edge : edges) {
            nodes[edge[0]].neighbors.add(edge[1]);
            nodes[edge[1]].neighbors.add(edge[0]);
        }

        // all node should connected from zero
        boolean[] visited = new boolean[n];
        if (!dfsHelper(nodes, visited, 0, -1))
            return false;
        
        // Check the isolate
        for (boolean v : visited) {
            if (!v)
                return false;
        }
        return true;
    }

    private boolean dfsHelper(Node[] nodes, boolean[] visited, int idx,
            int parentIdx) {
        if (visited[idx])
            return false;
        visited[idx] = true;
        for (int i = 0; i &amp;lt; nodes[idx].neighbors.size(); i++) {
            if (nodes[idx].neighbors.get(i) == parentIdx)
                continue;
            if (!dfsHelper(nodes, visited, nodes[idx].neighbors.get(i), idx))
                return false;
        }
        return true;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Route Between Two Nodes in Directed Graph</title>
      <link>http://xmruibi.github.io/2015/10/11/route-between-two-nodes-in-directed-graph/</link>
      <pubDate>Sun, 11 Oct 2015 15:14:18 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/11/route-between-two-nodes-in-directed-graph/</guid>
      <description>

&lt;p&gt;Given a directed graph, design an algorithm to find out whether there is a route between two nodes.&lt;/p&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Most typical Graph algorithm question!&lt;/li&gt;
&lt;li&gt;Try two ways: DFS, BFS.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
&lt;code class=&#34;java&#34;&gt;
public class Solution {
   /**
     * @param graph: A list of Directed graph node
     * @param s: the starting Directed graph node
     * @param t: the terminal Directed graph node
     * @return: a boolean value
     */
     
     // BFS
     public boolean hasRoute(ArrayList&lt;DirectedGraphNode&gt; graph, 
                            DirectedGraphNode s, DirectedGraphNode t) {
        
        if(s == t)
            return true;

        Queue&lt;DirectedGraphNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(s);
        graph.remove(s);
        while(!queue.isEmpty()) {
            DirectedGraphNode cur = queue.remove();
            graph.remove(cur);
            for(DirectedGraphNode next : cur.neighbors) {
                if(!graph.contains(next))
                    continue;
                if(next == t)
                    return true;
                queue.offer(next);
            }
        }
        return false;
    }
     
     
    // DFS
    public boolean hasRoute(ArrayList&lt;DirectedGraphNode&gt; graph, 
                            DirectedGraphNode s, DirectedGraphNode t) {
        // write your code here
        if(s == t)
            return true;
            
        graph.remove(s);
        for(DirectedGraphNode next : s.neighbors) {
            if(!graph.contains(next))
                    continue;
            if(hasRoute(graph, next, t))
                return true;
        }
        graph.add(s);
        return false;
    }
}


&lt;/code&gt;
&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>