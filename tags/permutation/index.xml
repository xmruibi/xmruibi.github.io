<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Permutation on Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/tags/permutation/</link>
    <description>Recent content in Permutation on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Mon, 19 Oct 2015 20:43:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/tags/permutation/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Next Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/next-permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/next-permutation/</guid>
      <description>

&lt;p&gt;Given a list of integers, which denote a permutation.&lt;/p&gt;

&lt;p&gt;Find the next permutation in ascending order.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;[1,3,2,3]&lt;/code&gt;, the next permutation is &lt;code&gt;[1,3,3,2]&lt;/code&gt;
For &lt;code&gt;[4,3,2,1]&lt;/code&gt;, the next permutation is &lt;code&gt;[1,2,3,4]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The list may contains duplicate integers.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;字典序算法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从后往前寻找索引满足 a[k] &amp;lt; a[k + 1], 如果此条件不满足，则说明已遍历到最后一个。&lt;/li&gt;
&lt;li&gt;如 k == 0, 说明是字典序最后一位， 因此直接倒置整个数组即可.&lt;/li&gt;
&lt;li&gt;从后往前遍历，找到第一个比a[k]大的数a[l], 即a[k] &amp;lt; a[l].&lt;/li&gt;
&lt;li&gt;交换a[k]与a[l].&lt;/li&gt;
&lt;li&gt;反转k + 1 ~ n之间的元素.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nums: an array of integers
     * @return: return nothing (void), do not return anything, modify nums in-place instead
     */
    public int[] nextPermutation(int[] nums) {
        if(nums == null || nums.length == 1)
            return nums;
        
        // step1: find nums[i] &amp;lt; nums[i + 1]
        int i = 0;
        for (i = nums.length - 2; i &amp;gt;= 0; i--) {
            if (nums[i] &amp;lt; nums[i + 1]) {
                break;
            } else if (i == 0) {
                // reverse nums if reach maximum
                reverse(nums, 0, nums.length - 1);
                return nums;
            }
        }
        // step2: find nums[i] &amp;lt; nums[j]
        int j = 0;
        for (j = nums.length - 1; j &amp;gt; i; j--) {
            if (nums[i] &amp;lt; nums[j]) {
                break;
            }
        }
        // step3: swap betwenn nums[i] and nums[j]
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
        
        // step4: reverse between [i + 1, n - 1]
        reverse(nums, i + 1, nums.length - 1);

        return nums;
    }
    
    private void reverse(int[] nums, int l, int r) {
        while(l &amp;lt; r) {
            int tmp = nums[l];
            nums[l++] = nums[r];
            nums[r--] = tmp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis&lt;/h2&gt;

&lt;p&gt;At most, two pass o(2*n) -&amp;gt; O(n); Constant Space Complexity: O(1)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation/</guid>
      <description>

&lt;p&gt;Given a list of numbers, return all possible permutations.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For nums = [1,2,3], the permutations are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it without recursion.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;h4 id=&#34;method-one&#34;&gt;Method One:&lt;/h4&gt;

&lt;p&gt;Backtracking, with memorized the element usage, which takes space, or we can search on arraylist(more time);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /**
     * @param nums: A list of integers.
     * @return: A list of permutations.
     */
    public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; permute(ArrayList&amp;lt;Integer&amp;gt; nums) {

        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(nums == null || nums.size() == 0)
            return res;
        helper(res, new ArrayList&amp;lt;Integer&amp;gt;(), nums);
        return res;
    }
    
    private void helper(ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; res, ArrayList&amp;lt;Integer&amp;gt; list,  ArrayList&amp;lt;Integer&amp;gt; nums ) {
        
        if(list.size() == nums.size()) {
            res.add(new ArrayList&amp;lt;Integer&amp;gt;(list));
            return;
        }
        
        for(int i = 0; i&amp;lt;nums.size(); i++){
        	// to check if this number already taken
            if(list.contains(nums.get(i)))
                continue;
            
            list.add(nums.get(i));
            helper(res, list, nums);
            list.remove(list.size() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;method-two&#34;&gt;Method Two:&lt;/h4&gt;

&lt;p&gt;Swap: &lt;a href=&#34;https://www.cs.princeton.edu/~rs/talks/perms.pdf&#34;&gt;Reference&lt;/a&gt;;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://xmruibi.github.io/media/PermutationSwap.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
  private static Set&amp;lt;Integer&amp;gt; exchPermutation(int[] arr) {
    Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
    int i = 0, num = 0;
    outer: while(true) {
      
      while(i &amp;lt; arr.length - 1) {
        num = exchGenerate(arr, i, ++i);
        if(set.contains(num))
          break outer;
        set.add(num);
      }
      
      num = exchGenerate(arr, 0, 1);
      if(set.contains(num))
        break outer;
      set.add(num);
      
      while(i &amp;gt; 0) {
        num = exchGenerate(arr, --i, i+1);
        if(set.contains(num))
          break outer;
        set.add(num);
      }
      
      num = exchGenerate(arr, arr.length - 2, arr.length - 1);
      if(set.contains(num))
        break outer;
      set.add(num);
    }
    return set;
  }
  
  private static int exchGenerate(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
    
    int res = 0;
    for(int n : arr){
      res = res*10 + n;
    }
    return res;
  }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Previous Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/previous-permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/previous-permutation/</guid>
      <description>

&lt;p&gt;Given a list of integers, which denote a permutation.&lt;/p&gt;

&lt;p&gt;Find the previous permutation in ascending order.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;[1,3,2,3]&lt;/code&gt;, the previous permutation is &lt;code&gt;[1,2,3,3]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For &lt;code&gt;[1,2,3,4]&lt;/code&gt;, the previous permutation is [&lt;code&gt;4,3,2,1]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The list may contains duplicate integers.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;step 1: find last nums[k] &amp;gt; nums[k + 1];&lt;/li&gt;
&lt;li&gt;step 2: find last nums[i] &amp;gt; nums[k];&lt;/li&gt;
&lt;li&gt;step 3: swap i, j;&lt;/li&gt;
&lt;li&gt;step 4: reverse num after i;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nums: A list of integers
     * @return: A list of integers that&#39;s previous permuation
     */
    public ArrayList&amp;lt;Integer&amp;gt; previousPermuation(ArrayList&amp;lt;Integer&amp;gt; nums) {
        if(nums == null || nums.size() &amp;lt;= 1)
            return nums;
            
        // step 1: find last nums[k] &amp;gt; nums[k + 1]
        int i = nums.size() - 2;
        for (; i &amp;gt;= 0; i--) {
            if (nums.get(i) &amp;gt; nums.get(i + 1)) {
                break;
            }
            if(i &amp;lt;= 0) {
                reverse(nums, 0, nums.size() - 1);
                return nums;
            }
        }

        // step 2: find last nums[i] &amp;gt; nums[k]
        int j = nums.size() - 1;
        for (; j &amp;gt; i; j--) {
            if (nums.get(i) &amp;gt; nums.get(j)) {
                break;
            }
        }
        
        // step 3: swap i, j
        Collections.swap(nums, i, j);
        
        // step 4: reverse num after i
        reverse(nums, i + 1, nums.size() - 1);
        
        return nums;
    }
    
    private void reverse(ArrayList&amp;lt;Integer&amp;gt; nums,  int start, int end) {
        for (int i = start, j = end; i &amp;lt; j; i++, j--) {
            Collections.swap(nums, i, j);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Permutation Index II</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation-index-ii/</link>
      <pubDate>Mon, 19 Oct 2015 11:45:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation-index-ii/</guid>
      <description>

&lt;p&gt;Given a permutation which may contain repeated numbers, find its index in all the permutations of these numbers, which are ordered in lexicographical order. The index begins at 1.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given the permutation &lt;code&gt;[1, 4, 2, 2]&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;The key is counting from low digit(right) to higher digit(left), and checking how many digits are less than current digits. Then using that count as the coefficient with positional weight. However, there are duplicates occured. So that means we can use a hash map to do the count.
But the positional system should be modified. The multiple of the factorial of the duplicates occurence should be divided by original position system. That means the &lt;code&gt;entry.value&lt;/code&gt; need to to the factorial and multiply those factors.
Why? For example, n numbers with 2 duplicates, like &lt;code&gt;2,4,3,3&lt;/code&gt;, when &lt;code&gt;4&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param A an integer array
     * @return a long integer
     */
    public long permutationIndexII(int[] A) {
        if(A == null || A.length == 0)
            return 0L;
        
        int pos = 2;
        long factor = 1;
        long index = 1;
        for(int i = A.length - 2; i &amp;gt;= 0; i--) {
            HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
            int cnt = 0;
            // count itself
            map.put(A[i], 1);
            for(int j = i + 1; j &amp;lt; A.length; j++) {
                // count all occurence on following element in Array
                map.put(A[j], map.containsKey(A[j])?map.get(A[j])+1:1);
                if(A[i] &amp;gt; A[j])
                    cnt++;
            }
            index += (cnt*factor)/factorialMultiple(map);
            factor *= pos;
            pos++;
        }
        
        return index;
    }
    
    private int factorialMultiple(HashMap&amp;lt;Integer, Integer&amp;gt; map) {
        int res = 1;
        for(int value : map.values()) {
            // do the factor on occurence
            int factor = 1;
            for(int i = 1; i &amp;lt;= value; i++)
                factor*= i;
            // get the multiple of occurence factor
            res *= factor;
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Permutation Sequence</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation-sequence/</link>
      <pubDate>Mon, 19 Oct 2015 11:45:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation-sequence/</guid>
      <description>

&lt;p&gt;Given n and k, return the k-th permutation sequence.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For n = 3, all permutations are listed as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;123&amp;quot;
&amp;quot;132&amp;quot;
&amp;quot;213&amp;quot;
&amp;quot;231&amp;quot;
&amp;quot;312&amp;quot;
&amp;quot;321&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If k = &lt;code&gt;4&lt;/code&gt;, the fourth permutation is &amp;laquo;&lt;code&gt;231&lt;/code&gt;&amp;laquo;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;n will be between 1 and 9 inclusive.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n*k) in time complexity is easy, can you do it in O(n^2) or less?&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;a1,a2,a3&amp;hellip;..an的permutation 如果确定了a1,那么剩下的permutation就有(n-1)!种 所以 a1 = k / (n-1)! k2 = k % (n-1)! a2 = k2 / (n-2)!&lt;/p&gt;

&lt;p&gt;要注意的是&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;得到的应该是剩下选择数字的index,而不是value,所以要建一个存储可用数字的list&lt;/li&gt;
&lt;li&gt;在用完一个数字后要将它从list中删去&lt;/li&gt;
&lt;li&gt;array是0-based index, 那么K也应该减去1变为0-based的 (&lt;code&gt;k--&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /**
      * @param n: n
      * @param k: the kth permutation
      * @return: return the k-th permutation
      */
    public String getPermutation(int n, int k) {
        
        int[] factors = new int[n + 1];
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        factors[0] = 1;
        for(int i = 1; i &amp;lt;= n; i++) {
            factors[i] = i * factors[i-1];
            list.add(i);
        }
        
        StringBuilder sb = new StringBuilder();
        // for index alignment： e.g: k == 12, k / 6 = 2, 
        // however, it should still belong the number start for list.get(1); So here need to make a alignment
        k--;
        while(n &amp;gt; 1) {
            int index = k / factors[n-1];
            sb.append(list.remove(index));
            k %= factors[n-1];
            n--;
        }
        sb.append(list.get(0));
        return sb.toString();
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Permutation Index</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation-index/</link>
      <pubDate>Mon, 19 Oct 2015 11:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation-index/</guid>
      <description>

&lt;p&gt;Given a permutation which contains no repeated number, find its index in all the permutations of these numbers, which are ordered in lexicographical order. The index begins at 1.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;[1,2,4]&lt;/code&gt;, return &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;thinking&#34;&gt;Thinking&lt;/h2&gt;

&lt;p&gt;Illustrating by manually getting the index of {2, 4, 3, 1}. Since this is a 4-element set, we know there are 4! permutations (4! = 4*3*2*1). If the set only had 3 elements, we would have 3*2*1 permutations. If the set only had 2 elements, we would have 2!=2*1 permutations; and so on.&lt;/p&gt;

&lt;p&gt;ASIDE: The decimal system of counting is a positional system. A 3-element decimal number, for instance, has the following three positional weights: hundred, ten, unit. Hence, we know the value of the number 472 because we understand: 4*hundred + 7*ten + 2*unit.&lt;/p&gt;

&lt;p&gt;If we treat our 4-element set as a positional system, then we get the following positional weights: 3!, 2!, 1!, 0. So that the index of {2, 4, 3, 1} is: x*3!+y*2!+z*1!+w*0. Presently it suffices to find the values of x,y,z to calculate the index (we ignore w because it is paired with 0). x,y,z are counters: the number of succeeding elements less than the element being considered. For example, in {2, 4, 3, 1}, there are two succeeding elements less than 4 (namely 3 and 1). For 2 it&amp;rsquo;s 1 (1); for 4 it&amp;rsquo;s 2 (3 and 1); for 3 it&amp;rsquo;s 1 (1); for 1 it&amp;rsquo;s 0. Now we can calculate the index of {2, 4, 3, 1} as: x=1, y=2, z=1:
    &lt;code&gt;x*3!+y*2!+z*1!+w*0 = 1*3! + 2*2! + 1*1! = 6 + 4 + 1 = 11&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The key is counting from low digit(right) to higher digit(left), and checking how many digits are less than current digits. Then using that count as the coefficient with positional weight.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param A an integer array
     * @return a long integer
     */
    public long permutationIndex(int[] A) {
        
        if(A == null || A.length == 0)
            return 0L;
        
        int pos = 2;
        long factor = 1;
        long index = 1;
        for(int i = A.length - 2; i &amp;gt;= 0; i--) {
            int cnt = 0;
            for(int j = i + 1; j &amp;lt; A.length; j++) {
                if(A[i] &amp;gt; A[j])
                    cnt++;
            }
            index += (cnt*factor);
            factor *= pos;
            pos++;
        }
        
        return index;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis&lt;/h2&gt;

&lt;p&gt;Two loop: &lt;code&gt;i range 0 -&amp;gt; length - 2&lt;/code&gt; and &lt;code&gt;j range i + 1 -&amp;gt; length - 1&lt;/code&gt;, So it is &lt;code&gt;O(n^2)&lt;/code&gt;;
Constant Space with some integer variable, Space: &lt;code&gt;O(1)&lt;/code&gt;;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>