<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Subsequence on Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/tags/subsequence/</link>
    <description>Recent content in Subsequence on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Tue, 20 Oct 2015 19:13:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/tags/subsequence/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Interleaving String</title>
      <link>http://xmruibi.github.io/2015/10/20/interleaving-string/</link>
      <pubDate>Tue, 20 Oct 2015 19:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/interleaving-string/</guid>
      <description>

&lt;p&gt;Given three strings: s1, s2, s3, determine whether s3 is formed by the interleaving of s1 and s2.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For s1 = &lt;code&gt;&amp;quot;aabcc&amp;quot;&lt;/code&gt;, s2 = &lt;code&gt;&amp;quot;dbbca&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When s3 = &lt;code&gt;&amp;quot;aadbbcbcac&amp;quot;&lt;/code&gt;, return true.
When s3 = &lt;code&gt;&amp;quot;aadbbbaccc&amp;quot;&lt;/code&gt;, return false.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n2) time or better&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Typical dynamic programming with subsequence problem.&lt;/li&gt;
&lt;li&gt;Set up a 2-D dp boolean table to memorized:

&lt;ul&gt;
&lt;li&gt;Initial: memo[0][0] = true;&lt;/li&gt;
&lt;li&gt;two conditions: s1 find matched or s2 find matched;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memo[i][j] = ( i &amp;gt; 0 &amp;amp;&amp;amp; s1.charAt(i - 1) == s3.charAt(i + j - 1) &amp;amp;&amp;amp; memo[i - 1][j]) || (s2.charAt(j - 1) == s3.charAt(i + j - 1) &amp;amp;&amp;amp; memo[i][j - 1])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * Determine whether s3 is formed by interleaving of s1 and s2.
     * @param s1, s2, s3: As description.
     * @return: true or false.
     */
    public boolean isInterleave(String s1, String s2, String s3) {

        if(s1 == null || s2 == null)
            return false;
        if(s1.length() + s2.length() != s3.length())
            return false;
            
        boolean[][] memo = new boolean[s1.length() + 1][s2.length() + 1];
        for(int i = 0; i &amp;lt;= s1.length(); i++) {
            for(int j = 0; j &amp;lt;= s2.length(); j++) {
                if(i == 0 &amp;amp;&amp;amp; j == 0)
                    memo[i][j] = true;
                else{
                    if(i &amp;gt; 0 &amp;amp;&amp;amp; s1.charAt(i - 1) == s3.charAt(i + j - 1))
                        memo[i][j] = memo[i - 1][j];
                    if(j &amp;gt; 0 &amp;amp;&amp;amp;s2.charAt(j - 1) == s3.charAt(i + j - 1))
                        memo[i][j] |= memo[i][j - 1];
                }
            }
        }
        
        return memo[s1.length()][s2.length()];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Common Subsequence</title>
      <link>http://xmruibi.github.io/2015/10/16/longest-common-subsequence/</link>
      <pubDate>Fri, 16 Oct 2015 09:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/16/longest-common-subsequence/</guid>
      <description>

&lt;p&gt;Given two strings, find the longest common subsequence (LCS).&lt;/p&gt;

&lt;p&gt;Your code should return the length of LCS.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;ABCD&lt;/code&gt; and &lt;code&gt;EDCA&lt;/code&gt;, the LCS is &lt;code&gt;A&lt;/code&gt; (or &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;), return 1.&lt;/p&gt;

&lt;p&gt;For &lt;code&gt;ABCD&lt;/code&gt; and &lt;code&gt;EACB&lt;/code&gt;, the LCS is &lt;code&gt;AC&lt;/code&gt;, return 2.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param A, B: Two strings.
     * @return: The length of longest common subsequence of A and B.
     */
    public int longestCommonSubsequence(String A, String B) {
        if(A == null || B == null)
            return 0;
        
        int[][] memo = new int[A.length()+1][B.length()+1];
        for(int i = 0; i &amp;lt;= A.length(); i ++) {
            for(int j = 0; j &amp;lt;= B.length(); j ++) {
                if(i == 0 || j == 0)
                    memo[i][j] = 0;
                else
                    memo[i][j] = (A.charAt(i-1) == B.charAt(j-1) ? memo[i-1][j-1] + 1 : Math.max(memo[i][j-1],memo[i-1][j]));
            }
        }
        return memo[A.length()][B.length()];
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Increasing Continuous Subsequence II</title>
      <link>http://xmruibi.github.io/2015/10/16/longest-increasing-continuous-subsequence-ii/</link>
      <pubDate>Fri, 16 Oct 2015 09:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/16/longest-increasing-continuous-subsequence-ii/</guid>
      <description>

&lt;p&gt;Give you an integer matrix (with row size n, column size m)，find the longest increasing continuous subsequence in this matrix. (The definition of the longest increasing continuous subsequence here can start at any row or column and go up/down/right/left any direction).&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given a matrix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [1 ,2 ,3 ,4 ,5],
  [16,17,24,23,6],
  [15,18,25,22,7],
  [14,19,20,21,8],
  [13,12,11,10,9]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return &lt;code&gt;25&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(nm) time and memory.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This is great question with DFS, Dynamic Problem and Subsequence idea.&lt;/li&gt;
&lt;li&gt;The idea is also simple. Recursively search by DFS while we can do some memorized stuff.&lt;/li&gt;
&lt;li&gt;Each time we figure out the maximum length with reversed increasing sequence from each element in matrix.&lt;/li&gt;
&lt;li&gt;Note that the searching is by decreasing way.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param A an integer matrix
     * @return  an integer
     */
    // memorized the local maximum length
    int[][] memo;

    boolean[] visited;
    int n ,m;

    // stepping way for dfs
    int[] dx = {1,-1,0,0}; 
    int[] dy = {0,0,1,-1};

    public int longestIncreasingContinuousSubsequenceII(int[][] A) {
        if(A.length == 0)
            return 0;
        n = A.length;
        m  = A[0].length;
        
        memo = new int[n][m];
        visited = new boolean[n*m];
        
        int res = 0;
        for(int i = 0; i &amp;lt; n; i++) {
            for(int j = 0; j &amp;lt; m; j++) { 
                memo[i][j] = helper(i, j, A);
                res = Math.max(res, memo[i][j]);
            }
        }
        return res;
    }
    
    private int helper(int x, int y, int[][] A) {
        // once it touched the visited element, return that value
        if(visited[x * m + y])
            return memo[x][y];
        
        int res = 1; 
        for(int i = 0; i &amp;lt; 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if(0&amp;lt;= nx &amp;amp;&amp;amp; nx &amp;lt; n &amp;amp;&amp;amp; 0&amp;lt;= ny &amp;amp;&amp;amp; ny &amp;lt; m ) {
                // this is tricky point, we search by decreasing
                if( A[x][y] &amp;gt; A[nx][ny]) 
                    res = Math.max(res,  helper(nx, ny, A) + 1);
            }
        }
        visited[x * m + y] = true;
        memo[x][y] = res;
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Increasing Continuous subsequence</title>
      <link>http://xmruibi.github.io/2015/10/16/longest-increasing-continuous-subsequence/</link>
      <pubDate>Fri, 16 Oct 2015 09:03:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/16/longest-increasing-continuous-subsequence/</guid>
      <description>

&lt;p&gt;Give you an integer array (index from 0 to n-1, where n is the size of this array)，find the longest increasing continuous subsequence in this array. (The definition of the longest increasing continuous subsequence here can be from right to left or from left to right)&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;[5, 4, 2, 1, 3]&lt;/code&gt;, the LICS is &lt;code&gt;[5, 4, 2, 1]&lt;/code&gt;, return &lt;code&gt;4&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For &lt;code&gt;[5, 1, 2, 3, 4]&lt;/code&gt;, the LICS is &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;, return &lt;code&gt;4&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;O(n) time and O(1) extra space.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This is O(1) space dynamic programming. Just maintain one local max and one global max variable.&lt;/li&gt;
&lt;li&gt;The default value of local maximum variable is 2.&lt;/li&gt;
&lt;li&gt;The condition for growing the local maximum is by &lt;code&gt;(A[i] - A[i-1])*(A[i-1] - A[i-2]) &amp;gt; 0&lt;/code&gt;, which means &lt;code&gt;[i-2] &amp;lt; [i-1] &amp;lt; [i]&lt;/code&gt; or &lt;code&gt;[i-2] &amp;gt; [i-1] &amp;gt; [i]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param A an array of Integer
     * @return  an integer
     */
    public int longestIncreasingContinuousSubsequence(int[] A) {
        if( A == null )
            return 0;
        if( A.length &amp;lt;= 1)
            return A.length;
        
        int max = 2;
        int cur = 2;
        for(int i = 2; i &amp;lt; A.length; i++) {
            if((A[i] - A[i-1])*(A[i-1] - A[i-2]) &amp;gt; 0){
                cur ++;   
            }else
                cur = 2;
            max = Math.max(max, cur);
        }
        return max;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>