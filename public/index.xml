<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Geek Think</title>
    <link>http://xmruibi.github.io/</link>
    <description>Recent content on Geek Think</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Fri, 20 Nov 2015 22:43:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Few questions from Old Version</title>
      <link>http://xmruibi.github.io/2015/11/20/few-questions-from-old-version/</link>
      <pubDate>Fri, 20 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/20/few-questions-from-old-version/</guid>
      <description>

&lt;h2 id=&#34;probelam-i-grey-code:283efc603582dcc162156c3c3c334a6b&#34;&gt;Probelam I: Grey Code&lt;/h2&gt;

&lt;p&gt;Given 2 numbers. Find if they are consecutive gray (grey) code sequences.&lt;/p&gt;

&lt;h2 id=&#34;solution:283efc603582dcc162156c3c3c334a6b&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public int greyCode(byte term1, byte term2) {
		byte x = (byte)(term1 ^ term2);
		int total = 0;
		while(x != 0){
			x = (byte) (x &amp;amp; (x - 1));
			total++;
		}
		if(total == 1) 
			return 1; 
		else 
			return 0;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;probelam-ii-remove-vowels:283efc603582dcc162156c3c3c334a6b&#34;&gt;Probelam II: Remove Vowels&lt;/h2&gt;

&lt;h2 id=&#34;solution-1:283efc603582dcc162156c3c3c334a6b&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public int removeVowel(String str) {
		StringBuffer sb = new StringBuffer();
		String v = &amp;quot;aeiouAEIOU&amp;quot;;
		for(int i = 0; i &amp;lt; string.length(); i++){
			if(v.indexOf(string.charAt(i)) &amp;gt; -1)
		 		continue;
			sb.append(string.charAt(i));
		}
		return sb.toStirng();
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-iii:283efc603582dcc162156c3c3c334a6b&#34;&gt;Problem III:&lt;/h2&gt;

&lt;p&gt;String rotation (if string is the rotate of the other)&lt;/p&gt;

&lt;h2 id=&#34;solution-2:283efc603582dcc162156c3c3c334a6b&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;boolean isRotation(String s1,String s2) {  
    return (s1.length() == s2.length()) &amp;amp;&amp;amp; ((s1+s1).indexOf(s2) != -1);  
} 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Insert Node for Circular Linked List</title>
      <link>http://xmruibi.github.io/2015/11/19/insert-node-for-circular-linked-list/</link>
      <pubDate>Thu, 19 Nov 2015 20:33:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/19/insert-node-for-circular-linked-list/</guid>
      <description>

&lt;p&gt;Write a function to insert a new node in a sorted Circular Linked List (CLL). For example, if the input CLL is following.&lt;/p&gt;

&lt;h2 id=&#34;solution:ee71923bba76e242d68d338217d1bb7b&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public void insertNode(CNode root, CNode insert) {
		CNode cur = root;
		// step one: find the node just less than root
		do{
			if(cur.val &amp;lt;= insert.val &amp;amp;&amp;amp; cur.next.val &amp;gt;= insert.val)
				break;
			cur = cur.next;
		}while(cur != root);

		CNode tmp = cur.next;
		insert.next = tmp;
		cur.next = insert;
	}
}

class CNode{
	int val;
	CNode next;
	public CNode(int val) {
		this.val = val;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Game of Life</title>
      <link>http://xmruibi.github.io/2015/11/19/game-of-life/</link>
      <pubDate>Thu, 19 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/19/game-of-life/</guid>
      <description>

&lt;p&gt;Given an array which represents a group of cells, their states are changing everyday according to some rule.&lt;/p&gt;

&lt;h2 id=&#34;problem-i:bd78b8dc0ea88ac5e1b12dcd60867418&#34;&gt;Problem I&lt;/h2&gt;

&lt;p&gt;The following rules is for rule one:
- if the cell has the same numbers on its two sides, set it as &lt;code&gt;0&lt;/code&gt;;
- if the cell has the different numbers on its two sides, set it as &lt;code&gt;0&lt;/code&gt;;&lt;/p&gt;

&lt;h3 id=&#34;example:bd78b8dc0ea88ac5e1b12dcd60867418&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cell: (0)[1, 0, 0, 0, 0, 1, 0, 0](0)
days1: [0, 1, 0, 0, 1, 0, 1, 0]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:bd78b8dc0ea88ac5e1b12dcd60867418&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public int[] cellChange(int[] arr, int days) {
		for(int i = 0; i &amp;lt; days; i++)
			changeHelper(arr);
		return arr;
	}

	private void changeHelper(int[] arr) {
		int bound = 0, prev = 0;
		for(int i = 0; i &amp;lt; arr.length; i++) {
			if(i == 0) {
				prev = arr[i];
				arr[i] = (bound == arr[1]?0:1);
			}else if(i == arr.length - 1) {
				arr[i] = (bound == prev?0:1);
			}else{
				int tmp = arr[i];
				arr[i] = (prev == arr[i+1]?0:1);
				prev = tmp;
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii:bd78b8dc0ea88ac5e1b12dcd60867418&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;According to the Wikipedia&amp;rsquo;s article:
&amp;gt; The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.&lt;/p&gt;

&lt;p&gt;Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Any live cell with fewer than two live neighbors dies, as if caused by under-population.&lt;/li&gt;
&lt;li&gt;Any live cell with two or three live neighbors lives on to the next generation.&lt;/li&gt;
&lt;li&gt;Any live cell with more than three live neighbors dies, as if by over-population..&lt;/li&gt;
&lt;li&gt;Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Write a function to compute the next state (after one update) of the board given its current state.&lt;/p&gt;

&lt;h3 id=&#34;follow-up:bd78b8dc0ea88ac5e1b12dcd60867418&#34;&gt;Follow-up&lt;/h3&gt;

&lt;p&gt;Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.
In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Find a Path in Maze</title>
      <link>http://xmruibi.github.io/2015/11/19/find-a-path-in-maze/</link>
      <pubDate>Thu, 19 Nov 2015 12:33:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/19/find-a-path-in-maze/</guid>
      <description>

&lt;p&gt;Find path in given 2D matrix. 3 states, &lt;code&gt;0&lt;/code&gt; means allow to go, &lt;code&gt;1&lt;/code&gt; means the obstacle, &lt;code&gt;9&lt;/code&gt; is the final, return true or false if the path exist from &lt;code&gt;(0,0)&lt;/code&gt; to any position contains &lt;code&gt;9&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution:6bea082703d3b73c0480d7f0afc663d2&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
    private final static int[] sx = {-1, 0, 0, 1};
    private final static int[] sy = {0, 1, -1, 0};
    public boolean findPath(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)  
            return false;
        if (matrix[0][0] == 9)  
            return true;
        int m = matrix.length, n = matrix[0].length;
        Queue&amp;lt;int[]&amp;gt; queue = new LinkedList&amp;lt;int[]&amp;gt;();
        queue.offer(new int[]{0, 0});
        matrix[0][0] = 1;
        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            for (int i = 0; i &amp;lt; 4; i++) {
                int[] next = {cur[0] + sx[i], cur[1] + sy[i]};
                if (next[0] &amp;gt;= 0 &amp;amp;&amp;amp; next[0] &amp;lt; m &amp;amp;&amp;amp; next[1] &amp;gt;= 0 &amp;amp;&amp;amp; next[1] &amp;lt; n) {
                    if (matrix[next[0]][next[1]] == 9)
                            return true;
                    else if (matrix[next[0]][next[1]] == 0) {
                        queue.offer(next);
                        matrix[next[0]][next[1]] = 1; // set the previous passed position as no longer accessiable 
                    }
                }
            }
        }
        return false;

    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Greatest Common Divisor</title>
      <link>http://xmruibi.github.io/2015/11/19/greatest-common-divisor/</link>
      <pubDate>Thu, 19 Nov 2015 12:33:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/19/greatest-common-divisor/</guid>
      <description>

&lt;p&gt;Write a function to find Greatest Common Divisor of an array.&lt;/p&gt;

&lt;h2 id=&#34;solution:5d09a98119ed49836b368e464065fa50&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public int findGCD(int[] arr) {
		if (array == null || array.length == 1)	return 0;
		int gcd = array[0];
		for (int i = 1; i &amp;lt; array.length; i++) {
			gcd = gcd(gcd, array[i]);
		}
		return gcd;
	}

	private int gcd(int num1, int num2) {
		if (num2 &amp;gt; num1)
			return gcd(num2, num1);
		if (num1 == 0 || num2 == 0)	
			return 0;
		while (num1 != 0 &amp;amp;&amp;amp; num2 != 0) {
			int temp = num1 % num2;
			num1 = num2;
			num2 = temp;
		}
		return num1 + num2;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find if Two Rectangles Overlap</title>
      <link>http://xmruibi.github.io/2015/11/19/find-if-two-rectangles-overlap/</link>
      <pubDate>Thu, 19 Nov 2015 12:33:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/19/find-if-two-rectangles-overlap/</guid>
      <description>

&lt;p&gt;Given two rectangles, find if the given two rectangles overlap or not. Note that a rectangle can be represented by two coordinates, top left and bottom right. So mainly we are given following four coordinates.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;l1: Top Left coordinate of first rectangle.&lt;/li&gt;
&lt;li&gt;r1: Bottom Right coordinate of first rectangle.&lt;/li&gt;
&lt;li&gt;l2: Top Left coordinate of second rectangle.&lt;/li&gt;
&lt;li&gt;r2: Bottom Right coordinate of second rectangle.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Rectangle{
	Point topLeft;
	Point rightBottom;
	public Rectangle(Point topLeft, Point rightBottom){
		this.topLeft = topLeft;
		this.rightBottom = rightBottom;
	}
}
class Point{
	int x;
	int y;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:349119d14e4a4f28c56258b5d1239743&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public boolean overlapRectangle(Rectangle r1, Rectangle r2) {
		// If one rectangle is on left side of other
		if (r1.rightBottom.x &amp;gt;= r2.topLeft.x || r1.topLeft.x &amp;gt;= r2.rightBottom.x)
		    return false;	

		// If one rectangle is above other
		if (r1.rightBottom.y &amp;gt;= r2.topLeft.y || r2.rightBottom.y &amp;gt;= r1.topLeft.y)
		    return false;
		 
		return true;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find Minimum Value Sum of Path</title>
      <link>http://xmruibi.github.io/2015/11/19/find-minimum-value-sum-of-path/</link>
      <pubDate>Thu, 19 Nov 2015 10:23:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/19/find-minimum-value-sum-of-path/</guid>
      <description>

&lt;p&gt;Given a binary tree, find a path has the minimum sum of node value.&lt;/p&gt;

&lt;h2 id=&#34;solution:daf05f69a964957806f1dbf44b1f6175&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public int minPath(TreeNode root) {
		if(root == null)
			return 0;
		return dfshelper(root);
	}

	private int dfshelper(TreeNode node) {
		if(node.left == null &amp;amp;&amp;amp; node.right == null)
			return node.val;
		int left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;
		if(node.left != null)
			left = dfshelper(node.left);
		if(node.right != null) 
			right = dfshelper(node.right);
		return Math.min(left, right) + node.val;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Amplitude of Tree</title>
      <link>http://xmruibi.github.io/2015/11/18/amplitude-of-tree/</link>
      <pubDate>Wed, 18 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/18/amplitude-of-tree/</guid>
      <description>

&lt;p&gt;Given a tree of N nodes, return the amplitude of the tree. In a binary tree T, a path P is a non-empty sequence of nodes of tree such that, each consecutive node in the sequence is a subtree of its preceding node. In the example tree, the sequences &lt;code&gt;[9, 8, 2]&lt;/code&gt; and &lt;code&gt;[5, 8, 12]&lt;/code&gt; are two paths, while &lt;code&gt;[12, 8, 2]&lt;/code&gt; is not. The amplitude of path P is the maximum difference among values of nodes on path P. The amplitude of tree T is the maximum amplitude of all paths in T. When the tree is empty, it contains no path, and its amplitude is treated as 0.&lt;/p&gt;

&lt;h3 id=&#34;exmaple:e9e8391b63bbb0456c71932d2a3068e3&#34;&gt;Exmaple&lt;/h3&gt;

&lt;p&gt;Input:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;         5
       /   \
    8        9
   /  \     /  \ 
  12   2   8    4
          /    /
        2    5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output: &lt;code&gt;7&lt;/code&gt; since there are paths &lt;code&gt;[5, 8, 12]&lt;/code&gt; and &lt;code&gt;[9, 8, 2]&lt;/code&gt; have the maximum amplitude &lt;code&gt;7&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think:e9e8391b63bbb0456c71932d2a3068e3&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Recursion, record the max value and min value a certain path.&lt;/li&gt;
&lt;li&gt;And recursively check each node on the path to that leaf and there differences.&lt;/li&gt;
&lt;li&gt;Set a global variable.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:e9e8391b63bbb0456c71932d2a3068e3&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
    static int maxDiff = 0;
    public int maxAmplitude(TreeNode root) {
        if(root == null)
            return 0;
        recurHelper(root, new int[2]);
        return maxDiff;
    }

    private void recurHelper(TreeNode node, int[] mnMx) {
        mnMx[0] = Math.min(mnMx[0], node.val);
        mnMx[1] = Math.max(mnMx[1], node.val);

        if(node.left == null &amp;amp;&amp;amp; node.right == null){

            int curDiff = Math.abs(mnMx[0] - mnMx[1]);
            maxDiff = Math.max(maxDiff, curDiff);
            return;
        }
        if(node.left != null) 
            recurHelper(node.left, mnMx);
        if(node.right != null) 
            recurHelper(node.right, mnMx);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Arithmetic Sequence</title>
      <link>http://xmruibi.github.io/2015/11/18/arithmetic-sequence/</link>
      <pubDate>Wed, 18 Nov 2015 13:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/18/arithmetic-sequence/</guid>
      <description>

&lt;p&gt;A sequence of numbers is called &lt;em&gt;Arithmetic&lt;/em&gt; if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, &lt;code&gt;[1,3,5,7,9]&lt;/code&gt;, &lt;code&gt;[7,7,7,7,7]&lt;/code&gt; and &lt;code&gt;[3,-1,-5,-9]&lt;/code&gt; are arithmetic.&lt;/p&gt;

&lt;p&gt;A slice (P, Q) of Array A is called arithmetic if the sequence:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	A[P], A[P+1], ..., A[Q-1],A[Q]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is arthmetic. In particular, this means that &lt;code&gt;P+1 &amp;lt; Q&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a function: &lt;code&gt;class Solution { public int solution(int[] A);}&lt;/code&gt; that, given array &lt;code&gt;A&lt;/code&gt; consisting of &lt;code&gt;N&lt;/code&gt; numbers, returns the number of arithmetic slices in &lt;code&gt;A&lt;/code&gt;. The function should return &lt;code&gt;-1&lt;/code&gt; if the result exceeds 1,000,000,000.&lt;/p&gt;

&lt;h3 id=&#34;example:fe4862e12cf7144de624f77907b24b10&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;A[0] = -1, A[1] = 1, A[2] = 3, A[3] = 3, A[4] = 3, A[5] = 2, A[6] = 1, A[7] = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should return &lt;code&gt;5&lt;/code&gt; since there are five arithmetic slices of that array, namely:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{0, 2}, {2, 4}, {4, 6}, {4, 7}, {5, 7}
``


## Solution
```java
public class Solution{
	public int countArithmetic(int[] array) {
		if(array.length &amp;lt; 3) 
			return 0;
		int total = 0;
		int idx = 1;
		int prev = 0;
		while(prev &amp;lt; array.length) {
			int curSlice = 2;
			int diff = array[idx] - array[idx-1];
			// if the difference between two consecutive numbers is the same
			while(++idx &amp;lt; array.length &amp;amp;&amp;amp; array[idx] - array[idx-1] == diff) {
				curSlice++;
			}

			if(curSlice &amp;gt;= 3) {
				// when slice length = 3 -&amp;gt; count 1, = 4 -&amp;gt; 1*2, = 5 -&amp;gt; 1*2*3...
				total += ((curSlice - 2) * (curSlice - 1) / 2);
			}
			prev = idx;
		}
		return (total &amp;gt; 1000000000) ? -1 :total;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sum of Difference on Four Integers</title>
      <link>http://xmruibi.github.io/2015/11/18/sum-of-difference-on-four-integers/</link>
      <pubDate>Wed, 18 Nov 2015 13:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/18/sum-of-difference-on-four-integers/</guid>
      <description>

&lt;p&gt;Given four integers, make &lt;code&gt;F(S)&lt;/code&gt; = &lt;code&gt;abs(S[0] - S[1])&lt;/code&gt; + &lt;code&gt;abs(S[1] - S[2])&lt;/code&gt; + &lt;code&gt;abs(S[2] - S[3])&lt;/code&gt; to be largest.&lt;/p&gt;

&lt;h2 id=&#34;solution-general-method:b95750bdbb505b858c5f59e1fd60a5ee&#34;&gt;Solution #General Method&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
    public int maxDiff(int[] arr) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        permutation(res, new ArrayList&amp;lt;&amp;gt;(), arr);
        int max = 0;
        List&amp;lt;Integer&amp;gt; maxLine = new ArrayList&amp;lt;&amp;gt;();
        for(List&amp;lt;Integer&amp;gt; each : res) {
            int cur = 0;
            for(int i = 1; i &amp;lt; each.size(); i++) 
                cur += Math.abs(each.get(i) - cur.get(i-1));
            if(max &amp;lt;= cur) {
                max = cur;
                maxLine = each;
            }
        }
        System.out.println(maxLine);
        return max;
    }

    private void permutation(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res, List&amp;lt;Integer&amp;gt; curRes, int[] arr) {
        if(curRes.size() == arr.length) {
            res.add(new ArrayList&amp;lt;&amp;gt;(curRes));
            return;
        }

        for(int i = 0; i &amp;lt; arr.length; i++) {
            if(curRes.contains(arr[i]))
                continue;
            curRes.add(arr[i]); 
            permutation(res, curRes, arr);
            curRes.remove(curRes.size() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Process Schedule Problems</title>
      <link>http://xmruibi.github.io/2015/11/18/process-schedule-problems/</link>
      <pubDate>Wed, 18 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/18/process-schedule-problems/</guid>
      <description>&lt;p&gt;Given the max size of a LRU cache and a input array, calculate the miss times.&lt;/p&gt;

&lt;p&gt;## Solution&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public int CacheMiss(int[] array, int size) {
		if(array == null)	
			return 0;
		Queue&amp;lt;Integer&amp;gt; cache = new LinkedList&amp;lt;Integer&amp;gt;();
		HashSet&amp;lt;Integer&amp;gt; hash = new HashSet&amp;lt;&amp;gt;();
		int count = 0;
		for (int i = 0; i &amp;lt; array.length; i++) {
			if(hash.contains(array[i])) {
				cache.remove(array[i]); // if hit it need to move it back, so remove here at first
			} else {
				count++; // miss, increse the count
			}
			cache.add(array[i]);
			hash.add(new Integer(array[i]));
			if (size == cache.size()) // over size, poll the first of queue
				cache.poll();
		}
		return count;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Two Sum Count</title>
      <link>http://xmruibi.github.io/2015/11/18/two-sum-count/</link>
      <pubDate>Wed, 18 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/18/two-sum-count/</guid>
      <description>

&lt;p&gt;Given an array and a target number, count how many pair in this array can sum to that target number.&lt;/p&gt;

&lt;h2 id=&#34;solution:4e4f31a8a2c131093d3fe5e1265a3ff0&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public int countTwoSum(int[] arr, int tar) {
		if(arr == null || arr.length == 0)
			return 0;
		int cnt = 0;
		// store all number in this array
		HashSet&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
		for(int i = 0; i &amp;lt; arr.length; i++) {
			// if any number hit in hashset, that means a pair can sum to the target number
			if(set.contains(tar - arr[i]))
				cnt ++;
			set.add(arr[i]);
		}
		return cnt;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-if-input-integers-has-duplicate:4e4f31a8a2c131093d3fe5e1265a3ff0&#34;&gt;Solution #If input integers has duplicate&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public static int TwoSumCount(int[] nums, int target) {
        if (nums == null || nums.length &amp;lt; 2)    return 0;
        Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;Integer, Integer&amp;gt;();
        int count = 0;
        for (int i = 0; i &amp;lt; nums.length; i++) {
            if (map.containsKey(target - nums[i]))
                count += map.get(target - nums[i]);
            map.put(nums[i], map.containsKey(nums[i]) ? map.get(nums[i]) + 1 : 1);
        }
        return count;
    }
    
    public static void main(String[] args) {
        int rvalue = TwoSumCount(new int[] {1, 1, 2, 3, 4}, 5);
        System.out.println(rvalue);
        return;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Process Schedule Problems</title>
      <link>http://xmruibi.github.io/2015/11/18/process-schedule-problems/</link>
      <pubDate>Wed, 18 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/18/process-schedule-problems/</guid>
      <description>

&lt;p&gt;Process schedule is very important to Operation System. There are several algorithm to deal with such problem. Here we discuss two of them. At first, we are given a process class for coding conveninence.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	private class Process{
		int arrTime;
		int exeTime;
		public Process(int arrTime, int exeTime) {
			this.arrTime = arrTime;
			this.exeTime = exeTime;
		}
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-one:fd5fbfca02af2e560dbb93ca15b4bf95&#34;&gt;Problem One&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Robin Round:&lt;/strong&gt; The question is about the robin round. Given an array with start time of each task and another array represent the executing time of each task and &lt;code&gt;q&lt;/code&gt; for quantum which is allowance of CPU time, means the maximum time for exeuting one task. Write a function, calculate the average waiting time on each task.&lt;/p&gt;

&lt;h2 id=&#34;solution-robin-round:fd5fbfca02af2e560dbb93ca15b4bf95&#34;&gt;Solution #Robin Round&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public double robinRound(int[] arrTime, int[] exeTime, int q) {
		if(arrTime == null || exeTime == null || arrTime.length == 0 || exeTime.length == 0)
			return 0;
		Queue&amp;lt;Process&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
		int idx = 0, waitTime = 0, curTime = 0;
		while(idx &amp;lt; arrTime.length || !queue.isEmpty()) {
			if(queue.isEmpty()) {
				queue.offer(new Process(arrTime[idx], exeTime[idx]));
				curTime = arrTime[idx++];
			}else{
				Process curProcess = queue.poll();
				waitTime += (curTime - curProcess.arrTime);
				curTime += Math.min(curProcess.exeTime, q);
				// push those process which has arrival time less than current time
				while(idx &amp;lt; arrTime.length &amp;amp;&amp;amp; arrTime[idx] &amp;lt; curTime) {
					queue.offer(new Process(arrTime[idx], exeTime[idx++]));
				}
				// if current process didn&#39;t be processed at all, push it back to queue
				if(curProcess.exeTime &amp;gt; q) {
					curProcess.exeTime -= q; 
					queue.offer(curProcess);
				}
			}
		}
		return (double) waitTime / (double) arrTime.length;
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-two:fd5fbfca02af2e560dbb93ca15b4bf95&#34;&gt;Problem Two&lt;/h2&gt;

&lt;p&gt;Given an array with start time of each task and another array represent the executing time of each task. Process these task by the principle that the shortest job should always run firstly. Write a function to achieve that.&lt;/p&gt;

&lt;h2 id=&#34;solution-shortest-job-first:fd5fbfca02af2e560dbb93ca15b4bf95&#34;&gt;Solution #Shortest Job First&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public double robinRound(int[] arrTime, int[] exeTime, int q) {
		if(arrTime == null || exeTime == null || arrTime.length == 0 || exeTime.length == 0)
			return 0;
		PriorityQueue&amp;lt;Process&amp;gt; queue = new PriorityQueue&amp;lt;&amp;gt;(new Comparator&amp;lt;Process&amp;gt;(){
			@Override
			public int compare(Process p1, Process p2) {
				if (p1.exeTime == p2.exeTime)
					return p1.arrTime - p2.arrTime;
				return Integer.compare(p1.exeTime, p2.exeTime);
			}
		});
		int idx = 0, waitTime = 0, curTime = 0;
		while(idx &amp;lt; arrTime.length || !queue.isEmpty()) {
			if(queue.isEmpty()) {
				queue.offer(new Process(arrTime[idx], exeTime[idx]));
				curTime = arrTime[idx++];
			}else{
				Process curProcess = queue.poll();
				waitTime += (curTime - curProcess.arrTime);
				curTime += curProcess.exeTime;
				// push those process which has arrival time less than current time
				while(idx &amp;lt; arrTime.length &amp;amp;&amp;amp; arrTime[idx] &amp;lt;= curTime) {
					queue.offer(new Process(arrTime[idx], exeTime[idx++]));
				}
			}
		}
		return (double) waitTime / (double) arrTime.length;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Rotate Matrix</title>
      <link>http://xmruibi.github.io/2015/11/18/rotate-matrix/</link>
      <pubDate>Wed, 18 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/18/rotate-matrix/</guid>
      <description>

&lt;p&gt;Given A Matrix and rotate by input flag represent the direction of rotation.&lt;/p&gt;

&lt;h2 id=&#34;solution:18934d05988ea6297312db56d76fae0e&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public int[][] rotateMatrix(int[][] matrix, boolean flag) {
		int n = matrix.length - 1;
		// in-place solution
		for (int i = 0; i &amp;lt; n; i++) {
			for (int j = i; j &amp;lt; n - i; j++) {
			// do it in 1/4 area of matrix
				int temp;
				if(flag) {
					temp = matrix[j][n - i];
					matrix[j][n - i] = matrix[i][j];
					matrix[i][j] = matrix[n - j][i];
					matrix[n - j][i] = matrix[n - i][n - j];
					matrix[n - i][n - j] = temp;
				}else{
					temp = matrix[n - i][n - j];
					matrix[n - i][n - j] = matrix[n - j][i];
					matrix[n - j][i] = matrix[i][j];
					matrix[i][j] = matrix[j][n - i];
					matrix[j][n - i] = temp;
				}
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find Loops in Linked List</title>
      <link>http://xmruibi.github.io/2015/11/18/find-loops-in-linked-list/</link>
      <pubDate>Wed, 18 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/18/find-loops-in-linked-list/</guid>
      <description>

&lt;p&gt;Given a linked list, find if it has a loop inside and return the loop beginning if it has the loop&lt;/p&gt;

&lt;h2 id=&#34;solution:a840d91244dfb46c7b1bf7358d4fa1d5&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
    public boolean findLoop(ListNode root) {
        if(root == null || root.next == null)
            return false;
        ListNode runner = root;
        ListNode walker = root;
        while(runner != null &amp;amp;&amp;amp; runner.next != null) {
            runner = runner.next.next;
            walker = walker.next;
            if(runner == walker)
                return true;
        }
        return false;
    }

    public ListNode findLoopEntry(ListNode root){
        if(root == null || root.next == null)
            return root;
        ListNode runner = root;
        ListNode walker = root;
        while(runner != null &amp;amp;&amp;amp; runner.next != null) {
            runner = runner.next.next;
            walker = walker.next;
            if(runner == walker)
                break;
        }
        if(runner == null || runner.next == null)
            return null;
        walker = root;
        while(walker != runner) {
            walker = walker.next;
            runner = runner.next;
        }
        return walker;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>