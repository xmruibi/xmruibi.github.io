<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/topics/algorithm/</link>
    <description>Recent content in Algorithm on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Mon, 09 Nov 2015 20:33:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/topics/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Factor Combinations</title>
      <link>http://xmruibi.github.io/2015/11/09/factor-combinations/</link>
      <pubDate>Mon, 09 Nov 2015 20:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/09/factor-combinations/</guid>
      <description>

&lt;p&gt;Numbers can be regarded as product of its factors. For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;8 = 2 x 2 x 2;
  = 2 x 4.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Write a function that takes an integer n and return all possible combinations of its factors.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;Each combination’s factors must be sorted ascending, for example: The factors of &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;6&lt;/code&gt; is &lt;code&gt;[2, 6]&lt;/code&gt;, not &lt;code&gt;[6, 2]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may assume that n is always positive.&lt;/p&gt;

&lt;p&gt;Factors should be greater than 1 and less than n.&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;input: &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;output: &lt;code&gt;[]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;input: &lt;code&gt;37&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;output: &lt;code&gt;[]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;input: &lt;code&gt;12&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;output:
&lt;code&gt;[ [2, 6], [2, 2, 3], [3, 4] ]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;input: &lt;code&gt;32&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;output:
&lt;code&gt;[ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ]&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;For input value &lt;code&gt;n&lt;/code&gt;, it has possible factors start from &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;Sqrt(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For every factor, we also calculate its factors, like: &lt;code&gt;16 -&amp;gt; 2, 8 -&amp;gt; 2, 2, 4 -&amp;gt; 2, 2, 2, 2, 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Build helper function, the only difference between main recursion and helper recursion function is, in helper, we have to consider about the input value is one of factor which should also include in result list&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; getFactors(int n) {
        // use hashset to avoid replicate
        Set&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new HashSet&amp;lt;&amp;gt;();
        int end = (int) Math.sqrt(n);
        for (int i = 2; i &amp;lt;= end; i++) {
            if (n % i != 0)
                continue;
            List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; prev = helper(n / i);
            for (List&amp;lt;Integer&amp;gt; each : prev) {
                each.add(i);
                // make sure the elements are sorted
                Collections.sort(each);
                res.add(each);
            }
        }
        return  new ArrayList&amp;lt;&amp;gt;(res);
    }

    private List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; helper(int n) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        // add it self which is also a factor
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(n);
        res.add(list);

        int end = (int) Math.sqrt(n);
        for (int i = 2; i &amp;lt;= end; i++) {
            if (n % i != 0)
                continue;
            List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; prev = helper(n / i);
            for (List&amp;lt;Integer&amp;gt; each : prev) {
                each.add(i);
                res.add(each);
            }
        }
        return res;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Delete Digits</title>
      <link>http://xmruibi.github.io/2015/11/09/delete-digits/</link>
      <pubDate>Mon, 09 Nov 2015 19:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/09/delete-digits/</guid>
      <description>

&lt;p&gt;Given string A representative a positive integer which has N digits, remove any k digits of the number, the remaining digits are arranged according to the original order to become a new positive integer.&lt;/p&gt;

&lt;p&gt;Find the smallest integer after remove k digits.&lt;/p&gt;

&lt;p&gt;N &amp;lt;= &lt;code&gt;240&lt;/code&gt; and k &amp;lt;= N,&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given an integer A = &lt;code&gt;&amp;quot;178542&amp;quot;&lt;/code&gt;, k = &lt;code&gt;4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;return a string &lt;code&gt;&amp;quot;12&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Setup a Stack.&lt;/li&gt;
&lt;li&gt;Iterate through input number&lt;/li&gt;
&lt;li&gt;If current digit is less than the peek of stack, pop out the stack until the peek is not larger than current digit.&lt;/li&gt;
&lt;li&gt;Push current digit&lt;/li&gt;
&lt;li&gt;Limit the pop out times by K. That means the pop action is regarded as remove digit. So when the pop out times is not less than K, keep push the digit even if it is less than peek element.&lt;/li&gt;
&lt;li&gt;Rebuild the output string by reading elements in stack.&lt;/li&gt;
&lt;li&gt;Two corner case should be careful:

&lt;ul&gt;
&lt;li&gt;When the iterate through digits finished, the remove(pop out) counter still less than K, we should ignore the first  &lt;code&gt;k-count&lt;/code&gt; element in stack.&lt;/li&gt;
&lt;li&gt;When the output result has the zero on first element, remove the zero.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     *@param A: A positive integer which has N digits, A is a string.
     *@param k: Remove k digits.
     *@return: A string
     */
    public String DeleteDigits(String A, int k) {
        if(A == null || A.length() == 0)
            return &amp;quot;&amp;quot;;
        // setup stack
        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        // read digits from input string
        int removeCnt = 0;
        for(char c : A.toCharArray()) {
            int cur = c - &#39;0&#39;;
            // pop out the digit larger than current digit
            while(!stack.isEmpty() &amp;amp;&amp;amp; removeCnt &amp;lt; k &amp;amp;&amp;amp; stack.peek() &amp;gt; cur) {
                stack.pop();
                removeCnt ++;
            }
            stack.push(cur);
        }
        
        StringBuilder sb = new StringBuilder();
        while(!stack.isEmpty()) {
            // corner case one:
            if(removeCnt &amp;lt; k) {
                stack.pop();
                removeCnt ++;
            }else
                sb.insert(0, &amp;quot;&amp;quot; + stack.pop());
        }
        // corner case two:
        while(sb.charAt(0) == &#39;0&#39;)
            sb.deleteCharAt(0);
        
        return sb.toString();
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Count Univalue Subtrees</title>
      <link>http://xmruibi.github.io/2015/11/09/count-univalue-subtrees/</link>
      <pubDate>Mon, 09 Nov 2015 13:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/09/count-univalue-subtrees/</guid>
      <description>

&lt;p&gt;Given a binary tree, count the number of uni-value subtrees.&lt;/p&gt;

&lt;p&gt;A Uni-value subtree means all nodes of the subtree have the same value.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example:&lt;/h3&gt;

&lt;p&gt;Given binary tree,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    5
   / \
  1   5
 / \   \
5   5   5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return &lt;code&gt;4&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Typical Tree problem with recursion idea&lt;/li&gt;
&lt;li&gt;Four cases in recursion:

&lt;ul&gt;
&lt;li&gt;Leaf node: if true case and increase the counter&lt;/li&gt;
&lt;li&gt;Node with on one child:

&lt;ul&gt;
&lt;li&gt;Left Only: check return value from left child and value of left child should be the same as current node.&lt;/li&gt;
&lt;li&gt;Right Only: check return value from right child and value of right child should be the same as current node.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Node with two children: check return value from both side and both child node value should be the same as current node.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CountUnivalueSubtrees {

    public int countUnivalSubtrees(TreeNode root) {
        if (root == null)
            return 0;
        int[] cnt = new int[1];
        helper(root, cnt);
        return cnt[0];
    }

    private boolean helper(TreeNode node, int[] cnt) {
        if (node.left == null &amp;amp;&amp;amp; node.right == null) {
            cnt[0]++;
            return true;
        } else if (node.left == null) {
            if (helper(node.right, cnt) &amp;amp;&amp;amp; node.right.val == node.val) {
                cnt[0]++;
                return true;
            } else
                return false;
        } else if (node.right == null) {
            if (helper(node.left, cnt) &amp;amp;&amp;amp; node.left.val == node.val) {
                cnt[0]++;
                return true;
            } else
                return false;
        } else {
            if (helper(node.left, cnt) &amp;amp;&amp;amp; helper(node.right, cnt)
                    &amp;amp;&amp;amp; node.left.val == node.val &amp;amp;&amp;amp; node.right.val == node.val) {
                cnt[0]++;
                return true;
            } else
                return false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Group Shifted Strings</title>
      <link>http://xmruibi.github.io/2015/11/09/group-shifted-strings/</link>
      <pubDate>Mon, 09 Nov 2015 09:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/09/group-shifted-strings/</guid>
      <description>

&lt;p&gt;Given a string, we can “shift” each of its letter to its successive letter, for example: &lt;code&gt;“abc”&lt;/code&gt; -&amp;gt; &lt;code&gt;“bcd”&lt;/code&gt;. We can keep “shifting” which forms the sequence:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;abc&amp;quot; -&amp;gt; &amp;quot;bcd&amp;quot; -&amp;gt; ... -&amp;gt; &amp;quot;xyz&amp;quot;&lt;/code&gt;
Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example,&lt;/h3&gt;

&lt;p&gt;given: [&amp;laquo;abc&amp;raquo;, &amp;laquo;bcd&amp;raquo;, &amp;laquo;acef&amp;raquo;, &amp;laquo;xyz&amp;raquo;, &amp;laquo;az&amp;raquo;, &amp;laquo;ba&amp;raquo;, &amp;laquo;a&amp;raquo;, &amp;laquo;z&amp;raquo;], Return:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [&amp;quot;abc&amp;quot;,&amp;quot;bcd&amp;quot;,&amp;quot;xyz&amp;quot;],
  [&amp;quot;az&amp;quot;,&amp;quot;ba&amp;quot;],
  [&amp;quot;acef&amp;quot;],
  [&amp;quot;a&amp;quot;,&amp;quot;z&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##Note
For the return value, each inner list’s elements must follow the lexicographic order.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;There is a regular pattern: if two words are shifted, the distance between two adjacent characters are the same.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    2   3        2   3
    /\ /\        /\ /\
   a  c  f - &amp;gt;  e  g  j 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;So all we need to do is figure out the distance between each character in each word and make these distance as a code to represent the word.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class GroupShiftedString {
    public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; groupStrings(String[] strings) {
        List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        HashMap&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for (String str : strings) {
            String code = getCode(str);
            List&amp;lt;String&amp;gt; val;
            if (!map.containsKey(code)) {
                val = new ArrayList&amp;lt;&amp;gt;();
            } else {
                val = map.get(code);
            }
            val.add(str);
            map.put(code, val);
        }

        for (Map.Entry&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; entry : map.entrySet()) {
            List&amp;lt;String&amp;gt; val = entry.getValue();
            Collections.sort(val);
            res.add(val);
        }
        return res;
    }

    private String getCode(String s) {
        StringBuilder sb = new StringBuilder();
        sb.append(&amp;quot;#&amp;quot;);
        for (int i = 1; i &amp;lt; s.length(); i++) {
            int tmp = ((s.charAt(i) - s.charAt(i - 1)) + 26) % 26;
            sb.append(tmp).append(&amp;quot;#&amp;quot;);
        }
        return sb.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Shortest Word Distance</title>
      <link>http://xmruibi.github.io/2015/11/09/shortest-word-distance/</link>
      <pubDate>Mon, 09 Nov 2015 09:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/09/shortest-word-distance/</guid>
      <description>

&lt;p&gt;Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.&lt;/p&gt;

&lt;h2 id=&#34;problem-i&#34;&gt;Problem I&lt;/h2&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Assume that words = &lt;code&gt;[&amp;quot;practice&amp;quot;, &amp;quot;makes&amp;quot;, &amp;quot;perfect&amp;quot;, &amp;quot;coding&amp;quot;, &amp;quot;makes&amp;quot;]&lt;/code&gt;.
Given word1 = &lt;code&gt;“coding”&lt;/code&gt;, word2 = &lt;code&gt;“practice”&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;.
Given word1 = &lt;code&gt;&amp;quot;makes&amp;quot;&lt;/code&gt;, word2 = &lt;code&gt;&amp;quot;coding&amp;quot;&lt;/code&gt;, return &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.&lt;/p&gt;

&lt;h3 id=&#34;think&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The problem can be solved by one-pass of the array.&lt;/li&gt;
&lt;li&gt;Iterate through the array, use two pointers pointing to the index of the word1 and word2, maintain the minimum distance.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	 public int shortestDistance(String[] words, String word1, String word2) {
		 if(words == null)
		    throw new IllegalArgumentException(&amp;quot;Invalid Input!&amp;quot;);
		 int w1Idx = -1, w2Idx = -1;
		 int min = Integer.MAX_VALUE;
		 for(int i = 0; i &amp;lt; words.length; i++) {
			 if(words[i].equals(word1))
				 w1Idx = i;
			 else if(words[i].equals(word2))
				 w2Idx = i;
			 if(w1Idx!=-1 &amp;amp;&amp;amp; w2Idx!=-1){
				 min = Math.min(min, Math.abs(w2Idx-w1Idx));
			 }
		 }
		 return min;
	 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;This is a follow up of Problem I.The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?
Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.&lt;/p&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example,&lt;/h3&gt;

&lt;p&gt;Assume that words = &lt;code&gt;[&amp;quot;practice&amp;quot;, &amp;quot;makes&amp;quot;, &amp;quot;perfect&amp;quot;, &amp;quot;coding&amp;quot;, &amp;quot;makes&amp;quot;]&lt;/code&gt;.
Given word1 = &lt;code&gt;&amp;quot;coding&amp;quot;&lt;/code&gt;, word2 = &lt;code&gt;&amp;quot;practice&amp;quot;&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;.
Given word1 = &lt;code&gt;&amp;quot;makes&amp;quot;&lt;/code&gt;, word2 = &lt;code&gt;&amp;quot;coding&amp;quot;&lt;/code&gt;, return &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;think-1&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Since the calls are from different words, we have to save the index for each word. So HashMap is a good choice.&lt;/li&gt;
&lt;li&gt;Save the word and its indexes as key and value in constructor.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-1&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ShortestWordDistance {
    // here is thread safe, since only constructor contains writing method
    private final HashMap&amp;lt;String, List&amp;lt;Integer&amp;gt;&amp;gt; map;

	public ShortestWordDistance(String[] words) {
		map = new HashMap&amp;lt;&amp;gt;();
		for (int i = 0; i &amp;lt; words.length; i++) {
			List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
			if (map.containsKey(words[i]))
				list = map.get(words[i]);
			list.add(i);
			map.put(words[i], list);
		}
	}

	public int shortestDistanceII(String word1, String word2) {
		int min = Integer.MAX_VALUE;
		if (!map.containsKey(word1) || !map.containsKey(word2))
			return min;
		for (int i : map.get(word1)) {
			for (int j : map.get(word2)) {
				min = Math.min(min, Math.abs(i - j));
			}
		}
		return min;
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-iii&#34;&gt;Problem III&lt;/h2&gt;

&lt;p&gt;This is a follow up of Problem I. The only difference is &lt;strong&gt;now word1 could be the same as word2&lt;/strong&gt;.
Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.
word1 and word2 may be the same and they represent two individual words in the list.&lt;/p&gt;

&lt;h3 id=&#34;example-2&#34;&gt;Example,&lt;/h3&gt;

&lt;p&gt;Assume that words = &lt;code&gt;[&amp;quot;practice&amp;quot;, &amp;quot;makes&amp;quot;, &amp;quot;perfect&amp;quot;, &amp;quot;coding&amp;quot;, &amp;quot;makes&amp;quot;]&lt;/code&gt;.
Given word1 = &lt;code&gt;&amp;quot;makes&amp;quot;&lt;/code&gt;, word2 = &lt;code&gt;&amp;quot;coding&amp;quot;&lt;/code&gt;, return &lt;code&gt;1&lt;/code&gt;.
Given word1 = &lt;code&gt;&amp;quot;makes&amp;quot;&lt;/code&gt;, word2 = &lt;code&gt;&amp;quot;makes&amp;quot;&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;think-2&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Most code should remain the same as the Problem I. But need to deal with the situation that word1 and word2 are the same.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w1Idx&lt;/code&gt; always record the index when &lt;code&gt;word[i].equals(word1)&lt;/code&gt; but &lt;code&gt;w2Idx&lt;/code&gt; should be assigned as the value from &lt;code&gt;w1Idx&lt;/code&gt; when &lt;code&gt;word1 == word2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-2&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	 public int shortestDistance(String[] words, String word1, String word2) {
		 if(words == null)
		    throw new IllegalArgumentException(&amp;quot;Invalid Input!&amp;quot;);
		 int w1Idx = -1, w2Idx = -1;
		 int min = Integer.MAX_VALUE;
		 for(int i = 0; i &amp;lt; words.length; i++) {
			 if(words[i].equals(word1))
				 w1Idx = i;
			 else if(words[i].equals(word2)) // else if to avoid w2Idx be recorded whrn word1==word2
				 w2Idx = i;
			 if(w1Idx!=-1 &amp;amp;&amp;amp; w2Idx!=-1 &amp;amp;&amp;amp; w1Idx != w2Idx){
				 min = Math.min(min, Math.abs(w2Idx-w1Idx));
			 }
			 if(word2.equals(word1))
			    w2Idx = w1Idx; // update previous index record
		 }
		 return min;
	 }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Strobogrammatic Number</title>
      <link>http://xmruibi.github.io/2015/11/08/strobogrammatic-number/</link>
      <pubDate>Sun, 08 Nov 2015 22:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/08/strobogrammatic-number/</guid>
      <description>

&lt;p&gt;A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).&lt;/p&gt;

&lt;h2 id=&#34;problem-i&#34;&gt;Problem I&lt;/h2&gt;

&lt;p&gt;Write a function to determine if a number is strobogrammatic. The number is represented as a string.&lt;/p&gt;

&lt;p&gt;For example, the numbers &lt;code&gt;&amp;quot;69&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;88&amp;quot;&lt;/code&gt;, and &lt;code&gt;&amp;quot;818&amp;quot;&lt;/code&gt; are all strobogrammatic.&lt;/p&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Strobogrammatic {
	public boolean isStrobogrammatic(String num) {
		if (num == null || num.length() == 0)
			return true;
		int l = 0, r = num.length() - 1;
		while (l &amp;lt; r) {
			if (isEqual(num.charAt(l), num.charAt(r))) {
				l++;
				r--;
			} else
				return false;
		}
		return true;
	}

	private boolean isEqual(char l, char r) {
		if ((l == &#39;9&#39; &amp;amp;&amp;amp; r == &#39;6&#39;) || (l == &#39;6&#39; &amp;amp;&amp;amp; r == &#39;9&#39;)
				|| (l == &#39;1&#39; &amp;amp;&amp;amp; r == &#39;1&#39;) || (l == &#39;8&#39; &amp;amp;&amp;amp; r == &#39;8&#39;)
				|| (l == &#39;0&#39; &amp;amp;&amp;amp; r == &#39;0&#39;))
			return true;
		else
			return false;
	}
	
    // Use HashMap
	public boolean isStrobogrammatic(String num) {
        if(num == null || num.length() == 0) {
            return true;
        }
         
        Map&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&#39;0&#39;, &#39;0&#39;);
        map.put(&#39;1&#39;, &#39;1&#39;);
        map.put(&#39;8&#39;, &#39;8&#39;);
        map.put(&#39;6&#39;, &#39;9&#39;);
        map.put(&#39;9&#39;, &#39;6&#39;);
         
        int lo = 0;
        int hi = num.length() - 1;
         
        while (lo &amp;lt;= hi) {
            char c1 = num.charAt(lo);
            char c2 = num.charAt(hi);
             
            if (!map.containsKey(c1) || map.get(c1) != c2) {
                return false;
            }
             
            lo++;
            hi--;
        }
         
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Find all strobogrammatic numbers that are of length = n.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example,&lt;/h3&gt;

&lt;p&gt;Given n = 2, return &lt;code&gt;[&amp;quot;11&amp;quot;,&amp;quot;69&amp;quot;,&amp;quot;88&amp;quot;,&amp;quot;96&amp;quot;]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;think&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Typical backtracking to generate something question&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-1&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public static List&amp;lt;String&amp;gt; findStrobogrammatic(int n) {
        Map&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&#39;0&#39;, &#39;0&#39;);
        map.put(&#39;1&#39;, &#39;1&#39;);
        map.put(&#39;8&#39;, &#39;8&#39;);
        map.put(&#39;6&#39;, &#39;9&#39;);
        map.put(&#39;9&#39;, &#39;6&#39;);
        List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        // two cases: even or odd
        if(n%2==0)
        		generate(res, map, &amp;quot;&amp;quot;, n);
        else{
            // the central digit can be any number
        	for(int i = 0; i &amp;lt;= 9; i++)
        		generate(res, map, &amp;quot;&amp;quot;+i, n);
        }
        return res;
	}
	
	private static void generate(List&amp;lt;String&amp;gt; res, Map&amp;lt;Character, Character&amp;gt; map, String cur, int n) {
		if(cur.length() == n) {
			res.add(new String(cur));
			return;
		}
		
		for(Map.Entry&amp;lt;Character, Character&amp;gt; entry : map.entrySet()) {
			String origin = new String(cur);
			cur = entry.getKey() + cur + entry.getValue();
			generate(res, map, cur, n);
			cur = origin;
		}
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-iii&#34;&gt;Problem III&lt;/h2&gt;

&lt;p&gt;A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).&lt;/p&gt;

&lt;p&gt;Write a function to count the total strobogrammatic numbers that exist in the range of low &amp;lt;= num &amp;lt;= high.&lt;/p&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given low = &amp;laquo;50&amp;raquo;, high = &amp;laquo;100&amp;raquo;, return 3. Because 69, 88, and 96 are three strobogrammatic numbers.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;Because the range might be a large number, the low and high numbers are represented as string.&lt;/p&gt;

&lt;h3 id=&#34;solution-2&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static int strobogrammaticInRange(String low, String high) {
		Map&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
		map.put(&#39;0&#39;, &#39;0&#39;);
		map.put(&#39;1&#39;, &#39;1&#39;);
		map.put(&#39;8&#39;, &#39;8&#39;);
		map.put(&#39;6&#39;, &#39;9&#39;);
		map.put(&#39;9&#39;, &#39;6&#39;);
		int[] cnt = new int[1];
		for (int n = low.length(); n &amp;lt;= high.length(); n++) {
			if (n % 2 == 0)
				generateII(cnt, map, &amp;quot;&amp;quot;, n, low, high);
			else {
				for (int i = 0; i &amp;lt;= 9; i++)
					generateII(cnt, map, &amp;quot;&amp;quot; + i, n, low, high);
			}
		}
		return cnt[0];
	}

	private static void generateII(int[] cnt,
			Map&amp;lt;Character, Character&amp;gt; map, String cur, int n, String low,
			String high) {
		if (cur.length() == n) {
			if (cur.charAt(0) != &#39;0&#39; &amp;amp;&amp;amp; compare(low, cur) &amp;lt; 0
					&amp;amp;&amp;amp; compare(cur, high) &amp;lt; 0)
				cnt[0]++;
			return;
		}

		for (Map.Entry&amp;lt;Character, Character&amp;gt; entry : map.entrySet()) {
			String origin = new String(cur);
			cur = entry.getKey() + cur + entry.getValue();
			generateII(cnt, map, cur, n, low, high);
			cur = origin;
		}
	}

	private static int compare(String s1, String s2) {
		return Integer.compare(Integer.parseInt(s1), Integer.parseInt(s2));
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Maximum Subarray III</title>
      <link>http://xmruibi.github.io/2015/11/07/maximum-subarray-iii/</link>
      <pubDate>Sat, 07 Nov 2015 19:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/07/maximum-subarray-iii/</guid>
      <description>

&lt;p&gt;Given an array of integers and a number k, find k non-overlapping subarrays which have the largest sum.&lt;/p&gt;

&lt;p&gt;The number in each subarray should be contiguous.&lt;/p&gt;

&lt;p&gt;Return the largest sum.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;[-1,4,-2,3,-2,3]&lt;/code&gt;, k=&lt;code&gt;2&lt;/code&gt;, return &lt;code&gt;8&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The subarray should contain at least one number&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;State: &lt;code&gt;memo[k][i]&lt;/code&gt; means the max subarray sum value from index 0 to i-1 with taken k subarrays&lt;/li&gt;
&lt;li&gt;Since &lt;code&gt;k&lt;/code&gt; is the amount of subarray, so at least we have to take &lt;code&gt;k&lt;/code&gt; elements in array&lt;/li&gt;
&lt;li&gt;Initilize with two case:

&lt;ul&gt;
&lt;li&gt;Taken first &lt;code&gt;k&lt;/code&gt; elements, each element is a subarray, so we only consider first kth element.&lt;/li&gt;
&lt;li&gt;Taken only one subarray, with two cases: start from previous to current  or start from itself.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;For the rest of elements, consider two cases:

&lt;ul&gt;
&lt;li&gt;Taken from the previous element with no subarray amount increase (&lt;code&gt;memo[k][i-1] + current element&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Taken from current element but increase &lt;code&gt;k&lt;/code&gt; so &lt;code&gt;memo[k-1][n] + current element&lt;/code&gt;, however, here &lt;code&gt;n&lt;/code&gt; can be any number from  &lt;code&gt;k-1&lt;/code&gt; to &lt;code&gt;current index - 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nums: A list of integers
     * @param k: An integer denote to find k non-overlapping subarrays
     * @return: An integer denote the sum of max k non-overlapping subarrays
     */
    public int maxSubArray(ArrayList&amp;lt;Integer&amp;gt; nums, int k) {
        
        // like backpack, memo[k][i] means the max value from index 0 to i-1 with taken k subarray 
        int[][] memo = new int[k+1][nums.size()];
        
        // count previous kth num, which means the each item as a subarray
        for(int i = 1; i&amp;lt;= k; i++) {
            int sum = 0;
            for(int j = 0; j &amp;lt; i; j++) {
                sum += nums.get(j);
            }
            memo[i][i-1] = sum;
        }
        
        // when k = 1, calculate the max value has two choices:
        // 1) max value from previous index (also come from two choices) and current index
        // 2) just start from current index
        for(int i = 1; i &amp;lt; nums.size(); i++) {
            memo[1][i] = Math.max(memo[1][i-1] + nums.get(i), nums.get(i));
        }
        
        // also has two cases: 
        // 1) continous get from previous index to current
        // 2) not continuous but we have to scan each index between current and (k-1) position 
        for(int subarr = 2; subarr &amp;lt;= k; subarr++) {
            for(int j = subarr; j &amp;lt; nums.size(); j++) {
                // 1) continous get so directly add current number
                memo[subarr][j] =  memo[subarr][j-1] + nums.get(j);
                // 2) resume in previous index from subarr - 2 (one more minus for index)
                for(int s = subarr - 2; s &amp;lt; j; s++) {
                    memo[subarr][j] = Math.max(memo[subarr][j], memo[subarr-1][s] + nums.get(j));
                }
            }
        }
        
        // pass through all case from k-1 to array length
        int max = Integer.MIN_VALUE;
        for(int i = k-1; i &amp;lt; nums.size(); i++) {
            max = Math.max(max, memo[k][i]);
        }
        return max;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Paint House</title>
      <link>http://xmruibi.github.io/2015/11/07/paint-house/</link>
      <pubDate>Sat, 07 Nov 2015 19:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/07/paint-house/</guid>
      <description>

&lt;h2 id=&#34;paint-fence&#34;&gt;Paint Fence&lt;/h2&gt;

&lt;p&gt;There is a fence with &lt;code&gt;n&lt;/code&gt; posts, each post can be painted with one of the &lt;code&gt;k&lt;/code&gt; colors.&lt;/p&gt;

&lt;p&gt;You have to paint all the posts such that &lt;strong&gt;no more than two adjacent fence posts&lt;/strong&gt; have the same color.&lt;/p&gt;

&lt;p&gt;Return the total number of ways you can paint the fence.&lt;/p&gt;

&lt;h4 id=&#34;note&#34;&gt;Note&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are non-negative integers.&lt;/p&gt;

&lt;h3 id=&#34;think&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Two cases:

&lt;ul&gt;
&lt;li&gt;If &lt;code&gt;[n-1] == [n]&lt;/code&gt;, &lt;code&gt;[n]&lt;/code&gt; has &lt;code&gt;1&lt;/code&gt; choices&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;[n-1] != [n]&lt;/code&gt;, &lt;code&gt;[n]&lt;/code&gt; has &lt;code&gt;k-1&lt;/code&gt; choices with consider the result from both &lt;code&gt;[n-2] == [n-1]&lt;/code&gt; OR &lt;code&gt;[n-2] != [n-1]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int numWays(int n, int k) {  
        if(n == 0 || k == 0)  
            return 0;  
        int same = k;
        if(n == 1)
            return same;
        int noSame = k*(k-1);
        for(int i = 2; i &amp;lt; n; i++) {
            int tmp = noSame;
            noSame = (same + noSame) * (k-1);
            same = tmp * 1;
        }
        return noSame + same;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;paint-house&#34;&gt;Paint House&lt;/h2&gt;

&lt;p&gt;There are a row of n houses, each house can be painted with one of the three colors: &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt; or &lt;code&gt;green&lt;/code&gt;. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.&lt;/p&gt;

&lt;p&gt;The cost of painting each house with a certain color is represented by a &lt;code&gt;n x 3&lt;/code&gt; cost matrix. For example, &lt;code&gt;costs[0][0]&lt;/code&gt; is the cost of painting house 0 with color red; &lt;code&gt;costs[1][2]&lt;/code&gt; is the cost of painting house 1 with color green, and so on&amp;hellip; Find the minimum cost to paint all houses.&lt;/p&gt;

&lt;h3 id=&#34;follow-up-2-colors-k-colors&#34;&gt;Follow Up: 2 Colors -&amp;gt; K Colors&lt;/h3&gt;

&lt;p&gt;There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.&lt;/p&gt;

&lt;p&gt;The cost of painting each house with a certain color is represented by a &lt;code&gt;n x k&lt;/code&gt; cost matrix. For example, &lt;code&gt;costs[0][0]&lt;/code&gt; is the cost of painting house 0 with color 0; &lt;code&gt;costs[1][2]&lt;/code&gt; is the cost of painting house 1 with color 2, and so on… Find the minimum cost to paint all houses.&lt;/p&gt;

&lt;h3 id=&#34;think-1&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Current paint only come from the previous different paint cost&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minCost[i][j] = costs[i][j] + min(minCost[i-1][k])&lt;/code&gt; (k != j)&lt;/li&gt;
&lt;li&gt;We can do it in-place, update the newest value on the original memorized array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-general-for-two-cases-2-or-k-colors&#34;&gt;Solution (General for Two Cases: 2 or K colors)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; public int minCost(int[][] costs) {
    if (costs == null || costs.length == 0) 
            return 0;
    
    for(int i = 1; i &amp;lt; costs.length; i++) {
        for(int j = 0; j &amp;lt; costs[i].length; j++) {
            int cur = Integer.MIN_VALUE;
            for(int k = 0; j &amp;lt; costs[i].length; k++) {
                if(k == j)
                    continue;
                cur = Math.max(cur, costs[i-1][k] + costs[i][j]);
            }
            costs[i][j] = cur;
        }
    }
    
    int max = 0;
    for(int i = 0; i &amp;lt; costs[costs.length - 1].length; i++)
        max = Math.max(max, costs[costs.length - 1][i]);
    
    return max;
 }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Scramble String</title>
      <link>http://xmruibi.github.io/2015/11/06/scramble-string/</link>
      <pubDate>Fri, 06 Nov 2015 22:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/06/scramble-string/</guid>
      <description>

&lt;p&gt;Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.&lt;/p&gt;

&lt;p&gt;Below is one possible representation of s1 = &lt;code&gt;&amp;quot;great&amp;quot;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To scramble the string, we may choose any non-leaf node and swap its two children.&lt;/p&gt;

&lt;p&gt;For example, if we choose the node &amp;laquo;gr&amp;raquo; and swap its two children, it produces a scrambled string &lt;code&gt;&amp;quot;rgeat&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We say that &lt;code&gt;&amp;quot;rgeat&amp;quot;&lt;/code&gt; is a scrambled string of &lt;code&gt;&amp;quot;great&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Similarly, if we continue to swap the children of nodes &amp;laquo;eat&amp;raquo; and &amp;laquo;at&amp;raquo;, it produces a scrambled string &lt;code&gt;&amp;quot;rgtae&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We say that &lt;code&gt;&amp;quot;rgtae&amp;quot;&lt;/code&gt; is a scrambled string of &lt;code&gt;&amp;quot;great&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think-dp-version&#34;&gt;Think - DP Version&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Ignore two situations: both length not equal and the characters not the same&lt;/li&gt;
&lt;li&gt;Two sequence but 3-D memorized array&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memo[i][j][k]&lt;/code&gt; means state: for s1.substring(i, i + k) and s2.substring(j, j + k), if they are scramble string&lt;/li&gt;
&lt;li&gt;Two conditions we can regard as scramble, for range of &lt;code&gt;word1(i -&amp;gt; i+k)&lt;/code&gt; or &lt;code&gt;word2(j -&amp;gt; j+k)&lt;/code&gt;:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i -&amp;gt; i + split&lt;/code&gt; = &lt;code&gt;j -&amp;gt; j + split&lt;/code&gt; (len = split) and &lt;code&gt;split + i -&amp;gt; i + k&lt;/code&gt; = &lt;code&gt;split + i -&amp;gt; j + k&lt;/code&gt; (len = k - split)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i -&amp;gt; i + split&lt;/code&gt; = &lt;code&gt;j + (k - split) -&amp;gt; j+k&lt;/code&gt; [len = split] and &lt;code&gt;i + split -&amp;gt; i+k&lt;/code&gt; = &lt;code&gt;j -&amp;gt; j + (k - split)&lt;/code&gt;(len = k - split)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Consider about the initialization:

&lt;ul&gt;
&lt;li&gt;for &lt;code&gt;k == 1&lt;/code&gt;, we only check if &lt;code&gt;word1[i] == word2[j]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param s1 A string
     * @param s2 Another string
     * @return whether s2 is a scrambled string of s1
     */
    public boolean isScramble(String s1, String s2) {
        // check length
        if(s1==null||s2==null||s1.length()!=s2.length())
            return false;
        // check anagram
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        Arrays.sort(c1);
        Arrays.sort(c2);
        if (!Arrays.equals(c1, c2))
			return false;
			
        if(s1.length() != s2.length())
            return false;
        int len = s1.length();
        
        // state: for s1.substring(i, i + k) and s2.substring(j, j + k), if they are scramble string
        boolean[][][] memo = new boolean[len][len][len+1];
        
        // initial, only check if s1[i] == s2[j] 
        for(int i=0;i&amp;lt;s1.length();i++)
            for(int j=0;j&amp;lt;s2.length();j++)
                memo[i][j][1] = (s1.charAt(i) == s2.charAt(j));
                
        for(int k = 2; k &amp;lt;= len; k++) {
            
            for(int i = 0; i &amp;lt;= len - k; i++) {
                for(int j = 0; j &amp;lt;= len - k; j++) {
                    // split point should start from 1 to k - 1
                    for(int split = 1; split &amp;lt; k; split++) {
                        memo[i][j][k] |= (memo[i][j][split]&amp;amp;&amp;amp;memo[i+split][j+split][k-split])||(memo[i][j+(k - split)][split]&amp;amp;&amp;amp;memo[i+split][j][k-split]);
                    }
                }
            }
        }
        return memo[0][0][len];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Word Break</title>
      <link>http://xmruibi.github.io/2015/11/06/word-break/</link>
      <pubDate>Fri, 06 Nov 2015 20:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/06/word-break/</guid>
      <description>

&lt;p&gt;Given a string s and a dictionary of words dict, determine if s can be break into a space-separated sequence of one or more dictionary words.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given s = &lt;code&gt;&amp;quot;lintcode&amp;quot;&lt;/code&gt;, dict = &lt;code&gt;[&amp;quot;lint&amp;quot;, &amp;quot;code&amp;quot;]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Return true because &amp;laquo;lintcode&amp;raquo; can be break as &amp;laquo;lint code&amp;raquo;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;One sequence DP, a 1-D boolean array.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memo[i]&lt;/code&gt; means from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;i&lt;/code&gt; has valid word break or not.&lt;/li&gt;
&lt;li&gt;Tricky part is when we pass at &lt;code&gt;i&lt;/code&gt; position, we don&amp;rsquo;t need to use &lt;code&gt;j&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;i&lt;/code&gt; for checking word existed in dictionary. We can use the length of word in dictionary as an length evaluation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param s: A string s
     * @param dict: A dictionary of words dict
     */
    public boolean wordBreak(String s, Set&amp;lt;String&amp;gt; dict) {
    
        if(s == null || s.length() == 0){
            if(dict == null || dict.size() == 0)
                return true;
            return false;
        }
        
        boolean[] memo = new boolean[s.length() + 1];
        memo[0] = true;
        for(int i = 1; i &amp;lt;= s.length(); i ++) {
            for(String ss : dict){
                int start = i - ss.length();
                if( start &amp;gt;= 0 &amp;amp;&amp;amp; memo[start]){
                    String str = s.substring(start, i);
                    if(dict.contains(str))
                         memo[i] = true;
                }
            }
        }
        return memo[s.length()];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>House Robber</title>
      <link>http://xmruibi.github.io/2015/11/06/house-robber/</link>
      <pubDate>Fri, 06 Nov 2015 13:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/06/house-robber/</guid>
      <description>

&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and &lt;strong&gt;it will automatically contact the police if two adjacent houses were broken into on the same night&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;[3, 8, 4]&lt;/code&gt;, return 8.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;$O(n)$ time and $O(1)$ memory.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;When Rob meet a house, he has two choices: taken or not taken, but if he had stolen the previous house, it cannnot taken.&lt;/li&gt;
&lt;li&gt;Set two variable: &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include&lt;/code&gt; means it has taken the previous house, while the &lt;code&gt;exclude&lt;/code&gt; means it didn&amp;rsquo;t take in previous house.&lt;/li&gt;
&lt;li&gt;So each time we consider about the &lt;code&gt;exclude + cur_value&lt;/code&gt; and &lt;code&gt;include&lt;/code&gt;, the max of them should be new &lt;code&gt;include&lt;/code&gt; while the new &lt;code&gt;exclude&lt;/code&gt; come from the max value of original &lt;code&gt;include&lt;/code&gt; (last taken, current not taken) and original &lt;code&gt;exclude&lt;/code&gt; (not taken in both last and current house)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param A: An array of non-negative integers.
     * return: The maximum amount of money you can rob tonight
     */
    public long houseRobber(int[] A) {
        if(A == null)
            return 0L;
        long exclude = 0L;
        long include = 0L;
        
        for(int i = 0; i &amp;lt; A.length; i++) {
            long tmp = include;
            include = Math.max(include, exclude + A[i]);
            exclude = Math.max(tmp, exclude);
        }
        
        return Math.max(include, exclude);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;follow-up&#34;&gt;Follow Up&lt;/h2&gt;

&lt;p&gt;After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.&lt;/p&gt;

&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;

&lt;h3 id=&#34;think-1&#34;&gt;Think&lt;/h3&gt;

&lt;p&gt;The houses are in a cycle,so that when pick up the first element we cannot pick the last element because they are adjacent. So just seperate two parts for calculating: &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;last second element&lt;/code&gt;, and &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;last element&lt;/code&gt;, find the maximum from them.&lt;/p&gt;

&lt;h3 id=&#34;solution-1&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int rob(int[] nums) {
        if(nums==null||nums.length==0)
            return 0;
        if(nums.length==1)
            return nums[0];
        return Math.max(helper(0, nums.length-2, nums), helper(1,nums.length-1,nums));
    }
    
    private int helper(int l, int r, int[] nums){
        if(nums==null||nums.length==0)
            return 0;
        int incl = 0;
        int excl = 0;
        for(int i = l;i&amp;lt;=r;i++){
            int tmp = incl;
            incl = excl+nums[i];
            excl = Math.max(excl, tmp);
        }
        return Math.max(incl, excl);
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Maximal Square</title>
      <link>http://xmruibi.github.io/2015/11/05/maximal-square/</link>
      <pubDate>Thu, 05 Nov 2015 20:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/05/maximal-square/</guid>
      <description>

&lt;p&gt;Given a 2D binary matrix filled with 0&amp;rsquo;s and 1&amp;rsquo;s, find the largest square containing all 1&amp;rsquo;s and return its area.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For example, given the following matrix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1 0 1 0 0
    1 0 1 1 1
    1 1 1 1 1
    1 0 0 1 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Return &lt;code&gt;4&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use itself as memorized array (modifying value directly on matrix)&lt;/li&gt;
&lt;li&gt;Ignore the top and left boundary&lt;/li&gt;
&lt;li&gt;If current point &lt;code&gt;[i][j]&lt;/code&gt; is one, look up all three directions from &lt;code&gt;[i-1][j]&lt;/code&gt;, &lt;code&gt;[i-1][j-1]&lt;/code&gt; and &lt;code&gt;[i][j-1]&lt;/code&gt; are not zero, get the minimum value from them so that the value plus one is the maximum length of square on current point.&lt;/li&gt;
&lt;li&gt;However, if one of three is zero, current point should keep zero or one&lt;/li&gt;
&lt;li&gt;Set a max value to track the max length.&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t forget make a square on final max result, since that result is just for length&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param matrix: a matrix of 0 and 1
     * @return: an integer
     */
    public int maxSquare(int[][] matrix) {
        if(matrix == null || matrix.length == 0)
            return 0;
        
        int max = 0;
        for(int i = 0; i &amp;lt; matrix.length; i++) {
            for(int j = 0; j &amp;lt; matrix[i].length; j++) {
                if(i != 0 &amp;amp;&amp;amp; j != 0 &amp;amp;&amp;amp; matrix[i][j]!=0 &amp;amp;&amp;amp; matrix[i-1][j] != 0 &amp;amp;&amp;amp; matrix[i][j-1] != 0 &amp;amp;&amp;amp; matrix[i-1][j-1] != 0) 
                    matrix[i][j] = 1 + Math.min(matrix[i-1][j-1],Math.min(matrix[i-1][j],matrix[i][j-1]));
                max = Math.max(max, matrix[i][j]);
            }
        }
        return max*max;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Palindrome Partitioning</title>
      <link>http://xmruibi.github.io/2015/11/05/palindrome-partitioning/</link>
      <pubDate>Thu, 05 Nov 2015 20:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/05/palindrome-partitioning/</guid>
      <description>

&lt;h2 id=&#34;problem-i&#34;&gt;Problem I&lt;/h2&gt;

&lt;p&gt;Given a string s, partition s such that every substring of the partition is a palindrome.&lt;/p&gt;

&lt;p&gt;Return all possible palindrome partitioning of &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;Given s = &lt;code&gt;&amp;quot;aab&amp;quot;&lt;/code&gt;, return:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;],
  [&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;think&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Set a boolean matrix for check word segment is prlindrome or not. &lt;code&gt;[i][j]&lt;/code&gt; -&amp;gt; &lt;code&gt;word(i, j)&lt;/code&gt; is palindrome&lt;/li&gt;
&lt;li&gt;DFS to build up all palindrome partition solutions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param s: A string
     * @return: A list of lists of string
     */
    public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; partition(String s) {
        List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(s == null || s.length() == 0)
            return res;
        // get palindrome boolean matrix [i][j] -&amp;gt; word(i, j) is palindrome
        boolean[][] memo = new boolean[s.length()][s.length()];
        for(int i = s.length() - 1; i &amp;gt;= 0; i--) 
            for(int j = i; j &amp;lt; s.length(); j++) 
                memo[i][j] |= (j - i &amp;lt; 2 || memo[i+1][j-1]) &amp;amp;&amp;amp; s.charAt(i) == s.charAt(j);
        
        // setup dfs method     
        helper(res, new ArrayList&amp;lt;String&amp;gt;(), memo, s, 0);
        return res;
    }
    
    private void helper(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; res, List&amp;lt;String&amp;gt; list, boolean[][] memo, String s, int idx) {
        if(idx &amp;gt;= s.length()) {
            res.add(new ArrayList&amp;lt;&amp;gt;(list));
            return;
        }
        
        for(int i = idx; i &amp;lt; s.length(); i++) {
            if(memo[idx][i]) {
                String substr = s.substring(idx,i+1);
                list.add(substr);
                helper(res, list, memo, s, i+1);
                list.remove(list.size() - 1);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;Given a string s, cut s into some substrings such that every substring is a palindrome.&lt;/p&gt;

&lt;p&gt;Return the &lt;strong&gt;minimum cuts&lt;/strong&gt; needed for a palindrome partitioning of s.&lt;/p&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;For example, given s = &lt;code&gt;&amp;quot;aab&amp;quot;&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;Return 1 since the palindrome partitioning &lt;code&gt;[&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;]&lt;/code&gt; could be produced using 1 cut.&lt;/p&gt;

&lt;h3 id=&#34;think-1&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;First step should be set up boolean matrix for check word segment is prlindrome or not. &lt;code&gt;[i][j]&lt;/code&gt; -&amp;gt; &lt;code&gt;word(i, j)&lt;/code&gt; is palindrome&lt;/li&gt;
&lt;li&gt;Then we need to have a array &lt;code&gt;res[i]&lt;/code&gt; to memorize the minimum cut from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;i&lt;/code&gt; position.&lt;/li&gt;
&lt;li&gt;Initial the first element in memorized array  as &lt;code&gt;0&lt;/code&gt; (no cut needed)&lt;/li&gt;
&lt;li&gt;Pass all position &lt;code&gt;i&lt;/code&gt; from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;When at &lt;code&gt;i&lt;/code&gt; position, we should try &lt;code&gt;j&lt;/code&gt; reversely (avoid update) from &lt;code&gt;j = i&lt;/code&gt; to &lt;code&gt;j = 0&lt;/code&gt; and check if &lt;code&gt;word(j, i-1)&lt;/code&gt; is palindrome.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;word(j, i-1)&lt;/code&gt; is palindrome, and &lt;code&gt;res[j]&lt;/code&gt; has valid minimum cut. Update &lt;code&gt;res[i]&lt;/code&gt; is necessary.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-1&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param s a string
     * @return an integer
     */
    public int minCut(String s) {
        if( s == null || s.length() == 0)
            return 0;
        // step one: boolean matrix for check word segment is prlindrome or not
        boolean[][] memo = new boolean[s.length()][s.length()];
        for(int i = s.length() - 1; i &amp;gt;= 0; i--) 
            for(int j = i; j &amp;lt; s.length(); j++) 
                memo[i][j] |= (j - i &amp;lt; 2 || memo[i+1][j-1]) &amp;amp;&amp;amp; s.charAt(i) == s.charAt(j);
        // step two: cut[i] memorized the minimum cut from `1` to `i` position
        int[] cut = new int[s.length() + 1];
        cut[0] = 0;
        for(int i = 0; i &amp;lt; s.length(); i++) {
            cut[i + 1] = Integer.MAX_VALUE; 
            for(int j = i; j &amp;gt;= 0; j --) {
                cut[i + 1] = memo[j][i] &amp;amp;&amp;amp; cut[j] != Integer.MAX_VALUE ?  Math.min(cut[i+1], cut[j] + 1) : cut[i+1];
            }
        }
        return cut[s.length()] - 1;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Coins in a Line</title>
      <link>http://xmruibi.github.io/2015/11/05/coins-in-a-line/</link>
      <pubDate>Thu, 05 Nov 2015 13:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/05/coins-in-a-line/</guid>
      <description>

&lt;h2 id=&#34;problem-i&#34;&gt;Problem I&lt;/h2&gt;

&lt;p&gt;There are n coins in a line. Two players take turns to take one or two coins from right side until there are no more coins left. The player who take the last coin wins.&lt;/p&gt;

&lt;p&gt;Could you please decide the first play will win or lose?&lt;/p&gt;

&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;n = &lt;code&gt;1&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;n = &lt;code&gt;2&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;n = &lt;code&gt;3&lt;/code&gt;, return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;n = &lt;code&gt;4&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;n = &lt;code&gt;5&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;challenge&#34;&gt;Challenge&lt;/h4&gt;

&lt;p&gt;$O(n)$ time and $$O(1)$$ memory&lt;/p&gt;

&lt;h3 id=&#34;think&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Only if the amount of coin is the multiply of &lt;code&gt;3&lt;/code&gt;, first player cannot win.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param n: an integer
     * @return: a boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int n) {
        return n%3!=0;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;There are n coins with different value in a line. Two players take turns to take one or two coins from left side until there are no more coins left. The player who take the coins with the most value wins.&lt;/p&gt;

&lt;p&gt;Could you please decide the first player will win or lose?&lt;/p&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;Given values array A = &lt;code&gt;[1,2,2]&lt;/code&gt;, return true.&lt;/p&gt;

&lt;p&gt;Given A = &lt;code&gt;[1,2,4]&lt;/code&gt;, return false.&lt;/p&gt;

&lt;h3 id=&#34;think-1&#34;&gt;Think&lt;/h3&gt;

&lt;h5 id=&#34;state&#34;&gt;State&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;dp[i]&lt;/code&gt; represent the max value it can get from &lt;code&gt;i&lt;/code&gt; to the end&lt;/p&gt;

&lt;h5 id=&#34;function&#34;&gt;Function&lt;/h5&gt;

&lt;p&gt;Each time when iterate &lt;code&gt;i&lt;/code&gt;, we have two choice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;takes &lt;code&gt;values[i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;takes &lt;code&gt;values[i] + values[i+1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are what we need to think:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.If we took &lt;code&gt;values[i]&lt;/code&gt;, opposite has two choice:  &lt;code&gt;values[i+1]&lt;/code&gt; or &lt;code&gt;values[i+1] + values[i+2]&lt;/code&gt; so the rest values for our own sides are &lt;code&gt;DP[i+2]&lt;/code&gt; or &lt;code&gt;DP[i+3]&lt;/code&gt;, however it should choose the minimum so that the opposite can get the maximum.&lt;/p&gt;

&lt;p&gt;$$value1 = values[i] + min(DP[i+2], DP[i+3])$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2.If we took  &lt;code&gt;values[i] + values[i+1]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;$$value2 = values[i] + values[i+1] + min(DP[i+3], DP[i+4])$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;3.&lt;/p&gt;

&lt;p&gt;$$dp[I] = max(value1, value2)$$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-1&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param values: an array of integers
     * @return: a boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int[] values) {
        if (values == null || values.length &amp;lt;= 2) {
            return true;
        }
        int dp[] = new int[values.length];
        
        dp[values.length-1] = values[values.length-1];
        dp[values.length-2] = values[values.length-1] + values[values.length-2];
        int total = dp[values.length-2];
        
        for(int i = values.length - 3; i &amp;gt;= 0; i--) {
            total += values[i];
            int value1 = values[i] + Math.min(dp[i+2], i+3&amp;lt;values.length?dp[i+3]:0);
            int value2 = values[i] + values[i+1] + Math.min(i+3&amp;lt;values.length?dp[i+3]:0, i+4&amp;lt;values.length?dp[i+4]:0);
            dp[i] = Math.max(value1, value2);
        }
        
        return dp[0] &amp;gt; (total - dp[0]);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-iii&#34;&gt;Problem III&lt;/h2&gt;

&lt;p&gt;There are n coins in a line. Two players take turns to take a coin from one of the ends of the line until there are no more coins left. The player with the larger amount of money wins.&lt;/p&gt;

&lt;p&gt;Could you please decide the first player will win or lose?&lt;/p&gt;

&lt;h4 id=&#34;example-2&#34;&gt;Example&lt;/h4&gt;

&lt;p&gt;Given array A = &lt;code&gt;[3,2,2]&lt;/code&gt;, return true.&lt;/p&gt;

&lt;p&gt;Given array A = &lt;code&gt;[1,2,4]&lt;/code&gt;, return true.&lt;/p&gt;

&lt;p&gt;Given array A = &lt;code&gt;[1,20,4]&lt;/code&gt;, return false.&lt;/p&gt;

&lt;h4 id=&#34;challenge-1&#34;&gt;Challenge&lt;/h4&gt;

&lt;p&gt;Follow Up Question: If &lt;code&gt;n&lt;/code&gt; is even. Is there any hacky algorithm that can decide whether first player will win or lose in $$O(1)$$ memory and $O(n)$ time?&lt;/p&gt;

&lt;h3 id=&#34;think-2&#34;&gt;Think&lt;/h3&gt;

&lt;h5 id=&#34;state-1&#34;&gt;State&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;dp[i][j]&lt;/code&gt; represent the max value it can get from &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sum[i][j]&lt;/code&gt; represent the sum value from &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&#34;function-1&#34;&gt;Function&lt;/h5&gt;

&lt;p&gt;Each time when taken coins, we have two choice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;takes &lt;code&gt;values[i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;takes &lt;code&gt;values[j]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$dp[i][j]=max(values[i]+sum[i+1][j]-dp[i+1][j], values[j]+sum[i][j-1]-dp[i][j-1])$$&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;values[i]+sum[i+1][j]&lt;/code&gt; or &lt;code&gt;values[j]+sum[i][j-1]&lt;/code&gt; equals to &lt;code&gt;sum[i][j]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So the equation can be $dp[i][j] = sum[i][j] - min(dp[i+1][j],dp[i][j-1])$&lt;/p&gt;

&lt;h3 id=&#34;solution-2&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param values: an array of integers
     * @return: a boolean which equals to true if the first player will win
     */
    public boolean firstWillWin(int[] values) {
        if (values == null || values.length &amp;lt;= 2) {
            return true;
        }
        
        int[][] dp = new int[values.length][values.length];
        int[][] sum = new int[values.length][values.length];
        // get the sum of i to j
        for(int i = 0; i &amp;lt; values.length; i++){
            for(int j  = i; j &amp;lt; values.length; j++) {
                if(i == j)
                    sum[i][j] = values[i];
                else
                    sum[i][j] = values[j] + sum[i][j-1];
            }
        }
        
        // to do the dp 
        for(int i = values.length - 1; i &amp;gt;= 0; i--){
            for(int j  = i; j &amp;lt; values.length; j++) {
                if(i == j)
                    dp[i][j] = values[i];
                else
                    dp[i][j] = sum[i][j] - Math.min(dp[i+1][j],dp[i][j-1]);
            }
        }
        
        return dp[0][values.length - 1] &amp;gt; sum[0][values.length - 1] - dp[0][values.length - 1];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Distinct Subsequences</title>
      <link>http://xmruibi.github.io/2015/11/05/distinct-subsequences/</link>
      <pubDate>Thu, 05 Nov 2015 13:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/05/distinct-subsequences/</guid>
      <description>

&lt;p&gt;Given a string S and a string T, count the number of distinct subsequences of T in S.&lt;/p&gt;

&lt;p&gt;A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &amp;laquo;ACE&amp;raquo; is a subsequence of &amp;laquo;ABCDE&amp;raquo; while &amp;laquo;AEC&amp;raquo; is not).&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given S = &amp;laquo;rabbbit&amp;raquo;, T = &amp;laquo;rabbit&amp;raquo;, return 3.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it in $O(n^2)$ time and $O(n)$ memory.&lt;/p&gt;

&lt;p&gt;$O(n^2)$ memory is also acceptable if you do not know how to optimize memory.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Two sequence DP, setup 2-D array for memorizing&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dp[i][j]&lt;/code&gt; means the distinct count when &lt;code&gt;S(1,i)&lt;/code&gt; and &lt;code&gt;T(1,j)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If S has non character &lt;code&gt;dp[0][j]&lt;/code&gt; should be 0, while T has non character &lt;code&gt;dp[i][0]&lt;/code&gt; should be 1.&lt;/li&gt;
&lt;li&gt;Each time we add &lt;code&gt;S[i]&lt;/code&gt; on &lt;code&gt;dp[i-1][j]&lt;/code&gt;, iterate &lt;code&gt;j&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;len - 1&lt;/code&gt;, if &lt;code&gt;S[i] == T[j]&lt;/code&gt; we should look up the the result from &lt;code&gt;dp[i-1][j-1]&lt;/code&gt; and add it on &lt;code&gt;dp[i-1][j]&lt;/code&gt;, otherwise we add nothing.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    /**
     * @param S, T: Two string.
     * @return: Count the number of distinct subsequences
     */
    public int numDistinct(String S, String T) {
        int[][] memo = new int[S.length() + 1][T.length() + 1];
        for(int i = 0; i &amp;lt;= S.length(); i++) {
            for(int j = 0; j &amp;lt;= T.length(); j++) {
                if(i == 0)
                    memo[i][j] = 0;
                if(j == 0)
                    memo[i][j] = 1;
                else{
                    memo[i][j] = memo[i-1][j] + (S.charAt(i-1) == T.charAt(j-1)) ? memo[i-1][j-1] : 0;
                }
            }
        }
        return memo[S.length()][T.length()];
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>