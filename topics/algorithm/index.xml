<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Geek Think</title>
    <link>http://xmruibi.github.io/topics/algorithm/</link>
    <description>Recent content in Algorithm on Geek Think</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Tue, 17 Nov 2015 22:43:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/topics/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Is Subtree</title>
      <link>http://xmruibi.github.io/2015/11/17/is-subtree/</link>
      <pubDate>Tue, 17 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/17/is-subtree/</guid>
      <description>

&lt;p&gt;Given a tree root node and another root node of tree, check if another tree is the subtree of the given tree.&lt;/p&gt;

&lt;h2 id=&#34;solution:9117bbf9480bc8a6d399845a198d0d79&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
    public boolean isSubtree(TreeNode root, TreeNode node) {
        if(root == null &amp;amp;&amp;amp; node  == null)
            return true;
        else if(root == null || node == null)
            return false;
        return checkNodes(root, node) || isSubtree(root.left, node) ||isSubtree(root.right, node);
    }

    private boolean checkNodes(TreeNode r1, TreeNode r2) {
        if(r1 == null &amp;amp;&amp;amp; r2  == null)
            return true;
        else if(r1 == null || r2 == null)
            return false;
        return (r1.val == r2.val) &amp;amp;&amp;amp; checkNodes(r1.left, r2.left) &amp;amp;&amp;amp; chechNodes(r1.right, r2.right);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Reverse Half of Linked List</title>
      <link>http://xmruibi.github.io/2015/11/17/reverse-half-of-linked-list/</link>
      <pubDate>Tue, 17 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/17/reverse-half-of-linked-list/</guid>
      <description>

&lt;p&gt;Given a linked list, reverse the half rear linked list.&lt;/p&gt;

&lt;h2 id=&#34;solution:4b7b94f93aabe077e4bae2445c410224&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	
	public ListNode reverseHalf(ListNode node) {
		if(node == null || node.next == null)
			return node;

		ListNode runner = node;
		ListNode pre = new ListNode(0);
		pre.next = node;
		ListNode walker = pre;

		// find the middle point: the index of head of half rear node should according to the question requirement:
		// here I just define the real middle one is the head of rear half 
		while(runner != null &amp;amp;&amp;amp; runner.next != null) {
			runner = runner.next.next;
			walker = walker.next;
		} 

		// reverse the rear half
		walker.next = reverse(walker.next);
		return node;
	}

	private ListNode reverse(ListNode node) {
		ListNode head = null;
		while(node != null) {
			ListNode next = node.next;
			node.next = head;
			head = node;
			node = next;
		}	
		return head;
	}

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Compact Tree Builder</title>
      <link>http://xmruibi.github.io/2015/11/15/compact-tree-builder/</link>
      <pubDate>Sun, 15 Nov 2015 20:33:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/compact-tree-builder/</guid>
      <description>

&lt;p&gt;Given a root of a binary tree. Transform it in a way that each node(except probably one) would either have N or 0 children.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   * A               A                 A                         A
     *  |               |                 |_B                       |_B
     *  |_B             |_B                  |_C                    |
     *     |            |  |                    |_D                 |_C
     *     |            |  |_D                     |_E              |
     *     |            |  |                          |_F           |_D
     *     |_C          |  |_E                           |_G        |
     *     | |_D        |    |_H                            |_H     |_E
     *     |    |_F     |                                           |
     *     |            |_C                                         |_F
     *     |_E            |                                         |
     *       |_G          |_F                                       |_G
     *       |            |                                         |
     *       |_H          |_G                                       |_H
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:397f4eeb84727cbe660f274d6bea7a6c&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;BFS entire tree into a queue.&lt;/li&gt;
&lt;li&gt;Read that queue and build posssible children according to the limit and add it into the root.&lt;/li&gt;
&lt;li&gt;Record the next root in another queue.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:397f4eeb84727cbe660f274d6bea7a6c&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	private static CTree compact(TreeNode node, int limit) {

		// bfs the original tree into a queue
		List&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
		queue.add(node);
		int idx = 0;
		while (idx &amp;lt; queue.size()) {
			TreeNode cur = queue.get(idx++);
			if (cur.left != null)
				queue.add(cur.left);
			if (cur.right != null)
				queue.add(cur.right);
		}
		// get the root for final return
		CTree root = new CTree(queue.remove(0).val);
		// build a queue for store the new type tree
		Queue&amp;lt;CTree&amp;gt; helperQueue = new LinkedList&amp;lt;&amp;gt;();
		helperQueue.add(root);
		while (!queue.isEmpty()) {
			CTree cRoot = helperQueue.remove();
			// build the children for current CTree
			int curLv = 0; // make sure the amount of children
			List&amp;lt;CTree&amp;gt; nexlv = new ArrayList&amp;lt;&amp;gt;();
			while (curLv &amp;lt; limit &amp;amp;&amp;amp; !queue.isEmpty()) {
				nexlv.add(new CTree(queue.remove(0).val));
				helperQueue.offer(nexlv.get(curLv++));
			}			
			cRoot.nodes = nexlv;
		}	
		return root;
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Convert BST to Sorted Doubly-Linked List</title>
      <link>http://xmruibi.github.io/2015/11/15/convert-bst-to-sorted-doubly-linked-list/</link>
      <pubDate>Sun, 15 Nov 2015 17:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/convert-bst-to-sorted-doubly-linked-list/</guid>
      <description>

&lt;p&gt;Given a Binary Tree (BT), convert it to a Doubly Linked List(DLL) In-Place. The left and right pointers in nodes are to be used as previous and next pointers respectively in converted DLL. The order of nodes in DLL must be same as Inorder of the given Binary Tree. The first node of Inorder traversal (left most node in BT) must be head node of the DLL.&lt;/p&gt;

&lt;h2 id=&#34;think:9391617169eedec55b65d518b5c0a515&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Inorder traversal&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-stack:9391617169eedec55b65d518b5c0a515&#34;&gt;Solution #Stack&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	private static Node convertBST2DoublyLinkedList(Node root) {
		Node dummy = new Node(0);
		Node prev = dummy;
		java.util.Stack&amp;lt;Node&amp;gt; stack = new java.util.Stack&amp;lt;&amp;gt;();

		do {
			while (root != null) {
				stack.push(root);
				root = root.prev;
			}
			Node cur = stack.pop();
			prev.next = cur;
			cur.prev = prev;
			prev = prev.next;
			if (cur.next != null)
				root = cur.next;
			else
				root = null;
		} while (!stack.isEmpty() || root != null);

		return dummy.next;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-recursion:9391617169eedec55b65d518b5c0a515&#34;&gt;Solution #Recursion&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
    static Node dummy = new Node(0);
    static Node pre = dummy;

    private static Node convertII(Node root) {
        if (root == null)
            return root;
        Node prev = convertII(root.prev);
        pre.next = root;
        root.prev = pre;
        pre = root;
        Node next = convertII(root.next);
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Palindromic Subsequence</title>
      <link>http://xmruibi.github.io/2015/11/15/longest-palindromic-subsequence/</link>
      <pubDate>Sun, 15 Nov 2015 14:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/longest-palindromic-subsequence/</guid>
      <description>

&lt;p&gt;Given a sequence, find the length of the longest palindromic subsequence in it. For example, if the given sequence is &lt;code&gt;“BBABCBCAB”&lt;/code&gt;, then the output should be 7 as &lt;code&gt;“BABCBAB”&lt;/code&gt; is the longest palindromic subseuqnce in it. &lt;code&gt;“BBBBB”&lt;/code&gt; and &lt;code&gt;“BBCBB”&lt;/code&gt; are also palindromic subsequences of the given sequence, but not the longest ones.&lt;/p&gt;

&lt;h2 id=&#34;solution-dynamic-programming:0dddaebd549f2b96d7e1c402abcf8d05&#34;&gt;Solution #Dynamic Programming&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static int longestSubsequence(String str) {
		// memo[len][i] represent from index &#39;i&#39; with length &#39;len&#39; has how many
		// palindromic subsequence
		int[][] memo = new int[str.length() + 1][str.length() + 1];

		// initial len with 1 as 1, since for every index it has 1 len
		// palindromic subsequence
		for (int i = 0; i &amp;lt; str.length(); i++)
			memo[1][i] = 1;

		// iterate the str with different length setting
		for (int len = 2; len &amp;lt;= str.length(); len++) {
			for (int i = 0; i &amp;lt;= str.length() - len; i++) {
				int tar = i + len - 1;
				if (len == 2 &amp;amp;&amp;amp; str.charAt(i) == str.charAt(tar))
					memo[len][i] = 2;
				else if (str.charAt(i) == str.charAt(tar))
					memo[len][i] = 2 + memo[len - 2][i + 1];
				else
					memo[len][i] = Math.max(memo[len - 1][i],
							memo[len - 1][i + 1]);
			}
		}
		return memo[str.length()][0];
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-recursive:0dddaebd549f2b96d7e1c402abcf8d05&#34;&gt;Solution # Recursive&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int calculateRecursive(char str[],int start,int len){
        if(len == 1){
            return 1;
        }
        if(len ==0){
            return 0;
        }
        if(str[start] == str[start+len-1]){
            return 2 + calculateRecursive(str,start+1,len-2);
        }else{
            return Math.max(calculateRecursive(str, start+1, len-1), calculateRecursive(str, start, len-1));
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Pow() and Sqrt()</title>
      <link>http://xmruibi.github.io/2015/11/15/pow-and-sqrt/</link>
      <pubDate>Sun, 15 Nov 2015 13:11:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/pow-and-sqrt/</guid>
      <description>

&lt;p&gt;Write function to get the power &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt; and the square root of &lt;code&gt;x&lt;/code&gt;;&lt;/p&gt;

&lt;h2 id=&#34;solution-pow:8f114c26f536717def87e4afa082746d&#34;&gt;Solution # Pow&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	// basic  
	public float pow(float x, int n) {
	    if(n==0)
            return 1.0;
		if (n == 1)
			return x;
		if (n % 2 == 0)
			return pow(x, n / 2) * pow(x, n / 2);
		else
			return x * pow(x, n / 2) * pow(x, n / 2);
	}

	// improved
	public double pow(double x, int n) {
        if(n==0)
            return 1.0;
        boolean neg = false;
        if(n&amp;lt;0)
            neg = true;
        double res = 1.0;
        while(n != 0){
            if(n%2 != 0){
                res *= x;
            }
            x *= x;
            n /= 2;
        }
        return neg?1.0/res:res;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-sqrt:8f114c26f536717def87e4afa082746d&#34;&gt;Solution # Sqrt&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public float sqrt(float n) {
        float low = 0, high = n;
        float mid = low + (high - low) / 2;
        while (Math.abs(mid * mid - n) &amp;gt; 0.00001) {
            if (mid * mid &amp;lt; n)
                low = mid;
            else if (mid * mid &amp;gt; n)
                high = mid;
            mid = low + (high - low) / 2;
        }
        return mid;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Max Points on a Line</title>
      <link>http://xmruibi.github.io/2015/11/15/max-points-on-a-line/</link>
      <pubDate>Sun, 15 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/max-points-on-a-line/</guid>
      <description>

&lt;p&gt;Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.&lt;/p&gt;

&lt;h2 id=&#34;think:0468874f3f0719bf48609e7d9f0fd5fc&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Represent line by ratio. Compare point to point by a nested two loop.&lt;/li&gt;
&lt;li&gt;Think about four cases:

&lt;ul&gt;
&lt;li&gt;Same point, count the same point amount&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; axis are the same&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt; axis are the same&lt;/li&gt;
&lt;li&gt;normal case &lt;code&gt;(y1 - y2)/(x1 - x2)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:0468874f3f0719bf48609e7d9f0fd5fc&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MaxPointOnAline {

    public int getMaxLine(List&amp;lt;FloatPoint&amp;gt; points) {
        if (points == null || points.size() == 0)
            return 0;

        int max = 0;
        for (int i = 0; i &amp;lt; points.size(); i++) {
            FloatPoint cur = points.get(i);
            Map&amp;lt;Double, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
            int same = 0, localMax = 1;
            for (int j = i + 1; j &amp;lt; points.size(); j++) {
                FloatPoint tar = points.get(j);
                if (cur.x == tar.x &amp;amp;&amp;amp; cur.y == tar.y) {
                    same++;
                }else if (cur.x == tar.x) {
                    double maxr = Double.MAX_VALUE;
                    map.put(maxr, map.containsKey(maxr) ? map.get(maxr) + 1 : 2);
                } else if (cur.y == tar.y) {
                    map.put(0.0, map.containsKey(0.0) ? map.get(0.0) + 1 : 2);
                } else {
                    double ratio = (cur.y - tar.y) / (cur.x - tar.x);
                    map.put(ratio, map.containsKey(ratio) ? map.get(ratio) + 1
                            : 2);
                }
            }
            for (Map.Entry&amp;lt;Double, Integer&amp;gt; entry : map.entrySet())
                localMax = Math.max(localMax, entry.getValue());
            max = Math.max(localMax + same, max);
        }
        return max;
    }
}

class FloatPoint {
    float x, y; // float may not suitable for accurate computation

    public FloatPoint(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Max Stack</title>
      <link>http://xmruibi.github.io/2015/11/15/max-stack/</link>
      <pubDate>Sun, 15 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/max-stack/</guid>
      <description>

&lt;p&gt;Design a stack, which makes the following function, try to reduce the time compaxity less than &lt;code&gt;O(n)&lt;/code&gt;
- &lt;code&gt;pop()&lt;/code&gt; pop the top of stack
- &lt;code&gt;push()&lt;/code&gt; push a element into stack
- &lt;code&gt;peek()&lt;/code&gt; peek the top of stack
- &lt;code&gt;peekMax()&lt;/code&gt; peek the max element of stack
- &lt;code&gt;popMax()&lt;/code&gt; pop the max element of stack&lt;/p&gt;

&lt;h2 id=&#34;think:0c76a512774b6e4792fd578d8968c8bd&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Typically, we can think about using one stacks and one heap. One of value, one of tracking the max stack.&lt;/li&gt;
&lt;li&gt;The most tricky part is pop max function. Make the node removal in O(n) should use the doubly linked list.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:0c76a512774b6e4792fd578d8968c8bd&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MaxStack {
    Stack elem = new Stack();
    PriorityQueue&amp;lt;ListNode&amp;gt; heap = new PriorityQueue&amp;lt;ListNode&amp;gt;((o1,o2) -&amp;gt; Integer.compare(o2.val, o1.val));
    
    // take O(logn): the depth of heap tree 
    public void push(int val) {
        ListNode newnode = new ListNode(val);
        heap.add(newnode); 
        elem.push(newnode);
    }
    
    // take O(logn): the depth of heap tree 
    public void pop() {
        ListNode remove = elem.pop();
        heap.remove(remove); 
    }
    
    // O(1) time
    public int peek() {
        return elem.peek().val;
    }

    // O(1) time
    public int peekMax() {
        return heap.peek().val; 
    }

    // take O(logn): the depth of heap tree 
    public void popMax() {
        ListNode node = heap.poll(); 
        elem.remove(node);
    }

    public static void main(String[] args) {
        MaxStack ms = new MaxStack();
        ms.push(1);
        ms.push(3);
        ms.push(2);
        System.out.println(ms.peekMax()); // == 3
        ms.popMax();
        System.out.println(ms.peekMax()); // == 2
        ms.push(4);
        ms.push(8);
        ms.pop();
        System.out.println(ms.peekMax()); // == 4
    }
}

class Stack {
    ListNode head, rear;

    public Stack() {
        head = new ListNode(0);
        rear = new ListNode(0);
        head.next = rear;
        rear.prev = head;
    }

    public void push(ListNode newnode) {
        rear.prev.next = newnode;
        newnode.prev = rear.prev;
        newnode.next = rear;
        rear.prev = newnode;
    }

    public ListNode pop() {
        if (isEmpty())
            return null;
        ListNode remove = rear.prev;
        rear.prev = remove.prev;
        remove.prev.next = rear;
        return remove;
    }

    public ListNode peek() {
        if (isEmpty())
            return null;
        ListNode peek = rear.prev;
        return peek;
    }

    public void remove(ListNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    public boolean isEmpty() {
        return head.next == rear;
    }
}

class ListNode {
    int val;
    ListNode prev, next;

    public ListNode(int val) {
        this.val = val;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find Union and Intersection by Iterators</title>
      <link>http://xmruibi.github.io/2015/11/15/find-union-and-intersection-by-iterators/</link>
      <pubDate>Sun, 15 Nov 2015 10:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/find-union-and-intersection-by-iterators/</guid>
      <description>

&lt;p&gt;Given two iterators, find their union and intersection.&lt;/p&gt;

&lt;h2 id=&#34;solution:d67777c39d54b3f8295734245ce89a09&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    private static List&amp;lt;Integer&amp;gt; union(Iterator&amp;lt;Integer&amp;gt; itr1,
            Iterator&amp;lt;Integer&amp;gt; itr2) {
        Integer num1 = itr1.hasNext() ? itr1.next() : null;
        Integer num2 = itr2.hasNext() ? itr2.next() : null;
        List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        while (num1 != null || num2 != null) {
            if (num1 != null &amp;amp;&amp;amp; num2 != null) {
                if (num1 &amp;lt; num2) {
                    res.add(num1);
                    num1 = itr1.hasNext() ? itr1.next() : null;
                } else if (num1 &amp;gt; num2) {
                    res.add(num2);
                    num2 = itr2.hasNext() ? itr2.next() : null;
                } else {
                    res.add(num1);
                    num1 = itr1.hasNext() ? itr1.next() : null;
                    num2 = itr2.hasNext() ? itr2.next() : null;
                }
            } else if (num1 != null) {
                res.add(num1);
                num1 = itr1.hasNext() ? itr1.next() : null;
            } else {
                res.add(num2);
                num2 = itr2.hasNext() ? itr2.next() : null;
            }
        }
        return res;
    }

    private static List&amp;lt;Integer&amp;gt; intersection(Iterator&amp;lt;Integer&amp;gt; itr1,
            Iterator&amp;lt;Integer&amp;gt; itr2) {
        Integer num1 = itr1.hasNext() ? itr1.next() : null;
        Integer num2 = itr2.hasNext() ? itr2.next() : null;
        List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        while (num1 != null &amp;amp;&amp;amp; num2 != null) {
            if (num1 &amp;lt; num2) {
                num1 = itr1.hasNext() ? itr1.next() : null;
            } else if (num1 &amp;gt; num2) {
                num2 = itr2.hasNext() ? itr2.next() : null;
            } else {
                res.add(num1);
                num1 = itr1.hasNext() ? itr1.next() : null;
                num2 = itr2.hasNext() ? itr2.next() : null;
            }
        }
        return res;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Iterator for Merging Sorted Stream</title>
      <link>http://xmruibi.github.io/2015/11/15/iterator-for-merging-sorted-stream/</link>
      <pubDate>Sun, 15 Nov 2015 10:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/iterator-for-merging-sorted-stream/</guid>
      <description>

&lt;p&gt;Design a iterator, with input a list and a hop parameter. Then output the element according to that hop number. List: &lt;code&gt;1, 2, 3, 4, 5, 6, 7, 8, 9; hop = 2&lt;/code&gt; -&amp;gt; &lt;code&gt;2, ,4, 6, 8&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution:c20097de2cc12809c8a9177ae4edd63e&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HopIterator&amp;lt;E&amp;gt; implements Iterator&amp;lt;E&amp;gt; {
	int hop;
	Iterator&amp;lt;E&amp;gt; itr;

	public HopIterator(Collection&amp;lt;E&amp;gt; list, int hop) {
		this.itr = list.iterator();
		this.hop = hop;
	}

	@Override
	public boolean hasNext() {
		int k = 1;
		while (k &amp;lt; hop &amp;amp;&amp;amp; itr.hasNext()) {
			k++;
			itr.next();
		}
		return k == hop &amp;amp;&amp;amp; itr.hasNext();
	}

	@Override
	public E next() {
		return itr.next();
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Iterator for Merging Sorted Stream</title>
      <link>http://xmruibi.github.io/2015/11/15/iterator-for-merging-sorted-stream/</link>
      <pubDate>Sun, 15 Nov 2015 10:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/iterator-for-merging-sorted-stream/</guid>
      <description>

&lt;p&gt;Given a &lt;code&gt;Merge Sorted Stream&lt;/code&gt; class contains some sorted stream which implements iterator interface. Each sorted stream class has some methods: &lt;code&gt;hasNext()&lt;/code&gt;, &lt;code&gt;next()&lt;/code&gt;. Sorted Stream defines the stream read data by ascending order, so that in &lt;code&gt;Merge Sorted Stream&lt;/code&gt; when call &lt;code&gt;next()&lt;/code&gt; method, it will return values by ascending order. Pleas complete the following codes.&lt;/p&gt;

&lt;h3 id=&#34;partital-code:29d87af7cc40b904c89fba965c56caf1&#34;&gt;Partital Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class SortedStream implments Iterator&amp;lt;Integer&amp;gt;{
	List&amp;lt;Integer&amp;gt; content;
	int cursor;
	public SortedStream(List&amp;lt;Integer&amp;gt; content){
		if(content == null)
			throw new IllegalArgumentException(&amp;quot;Null Input&amp;quot;);
		this.content = content;
		this.cursor = 0;
	}

	public boolean hasNext(){return cursor &amp;lt; content.size();}

	public int next(){return content.get(cursor++);}
}

class MergeSortedStream implments Iterator&amp;lt;SortedStream&amp;gt;{
    List&amp;lt;SortedStream&amp;gt; content;
	SortedStream cursor;
	public MergeSortedStream(List&amp;lt;SortedStream&amp;gt; content){...}
	
	public boolean hasNext(){...};

	public int next(){...};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:29d87af7cc40b904c89fba965c56caf1&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Implement a new wrapper class for original iterator class and make it comparable.&lt;/li&gt;
&lt;li&gt;The new wrapper class is just like peek iterator, and implement &lt;code&gt;compareTo()&lt;/code&gt; method with comparing the peek element.&lt;/li&gt;
&lt;li&gt;Put all new iterator class in a minheap.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:29d87af7cc40b904c89fba965c56caf1&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MergeKSortedIterator implements Iterable&amp;lt;Integer&amp;gt; {

    Collection&amp;lt;Iterator&amp;lt;Integer&amp;gt;&amp;gt; listOfItr;

    public MergeKSortedIterator(Collection&amp;lt;Iterator&amp;lt;Integer&amp;gt;&amp;gt; lists) {
        this.listOfItr = lists;
    }

    @Override
    public Iterator&amp;lt;Integer&amp;gt; iterator() {
        Queue&amp;lt;NewIterator&amp;gt; minHeap = new PriorityQueue&amp;lt;NewIterator&amp;gt;(
                listOfItr.size());
        for (Iterator&amp;lt;Integer&amp;gt; it : listOfItr)
            minHeap.add(new NewIterator(it));

        return new Iterator&amp;lt;Integer&amp;gt;() {
            @Override
            public boolean hasNext() {
                return !minHeap.isEmpty();
            }

            @Override
            public Integer next() {
                NewIterator pop = minHeap.poll();
                int res = pop.next();
                if (pop.hasNext()) {
                    minHeap.add(pop);
                }
                return res;
            }

        };
    }

    class NewIterator implements Comparable&amp;lt;NewIterator&amp;gt;, Iterator&amp;lt;Integer&amp;gt; {
        Integer cur;
        Iterator&amp;lt;Integer&amp;gt; itr;

        public NewIterator(Iterator&amp;lt;Integer&amp;gt; itr) {
            this.itr = itr;
            cur = itr.hasNext() ? itr.next() : null;
        }

        @Override
        public int compareTo(NewIterator o) {
            return Integer.compare(this.peek(), o.peek());
        }

        @Override
        public boolean hasNext() {
            return cur != null;
        }

        @Override
        public Integer next() {
            int res = cur;
            cur = itr.hasNext() ? itr.next() : null;
            return res;
        }

        public Integer peek() {
            return cur;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Balanced Point in Array</title>
      <link>http://xmruibi.github.io/2015/11/14/balanced-point-in-array/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/balanced-point-in-array/</guid>
      <description>

&lt;p&gt;Balanced index of an array is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes.&lt;/p&gt;

&lt;h3 id=&#34;example:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;In an arrya A:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A[0] = -7, A[1] = 1, A[2] = 5, A[3] = 2, A[4] = -4, A[5] = 3, A[6]=0
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;3&lt;/code&gt; is an Balanced index, because: &lt;code&gt;A[0] + A[1] + A[2] = A[4] + A[5] + A[6]&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;6&lt;/code&gt; is also an Balanced index, because sum of zero elements is zero, i.e., &lt;code&gt;A[0] + A[1] + A[2] + A[3] + A[4] + A[5]=0&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;7&lt;/code&gt; is not an Balanced index, because it is not a valid index of array A.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Write a function int &lt;code&gt;balancedPoint(int[] arr)&lt;/code&gt;; that given a sequence arr[] of size n, returns an Balanced index (if any) or -1 if no Balanced indexes exist.&lt;/p&gt;

&lt;h2 id=&#34;think:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;The idea is to get total sum of array first. Then Iterate through the array and keep updating the left sum which is initialized as zero. In the loop, we can get right sum by subtracting the elements one by one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1) Initialize leftsum  as 0
2) Get the total sum of the array as sum
3) Iterate through the array and for each index i, do following.
    a)  Update sum to get the right sum.  
           sum = sum - arr[i] 
       // sum is now right sum
    b) If leftsum is equal to sum, then return current index. 
    c) leftsum = leftsum + arr[i] // update leftsum for next iteration.
4) return -1 // If we come out of loop without returning then
             // there is no equilibrium index
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	// find all balance point in an array return balanced index
	public List&amp;lt;Integer&amp;gt; findBalancedPoint(int[] arr) {
		int leftsum = 0, rightsum = 0;
		List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

		for (int i = 0; i &amp;lt; arr.length; i++) 
			leftsum += arr[i];
		
		for (int i = arr.length - 1; i&amp;gt;=0; i--) {
			leftsum -= arr[i];
			if(leftsum == rightsum)
				res.add(i);
			rightsum+=arr[i];
		}
		return -1;
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find Valid IP Address in a File</title>
      <link>http://xmruibi.github.io/2015/11/14/find-valid-ip-address-in-a-file/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/find-valid-ip-address-in-a-file/</guid>
      <description>

&lt;p&gt;Given a file with many lines of Strings, find those valid IP address from them.&lt;/p&gt;

&lt;h2 id=&#34;solution:ed817a74e0c3a1097fc0cfb76d5d85e1&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ValidIPAddress {

    public List&amp;lt;String&amp;gt; findValidIPAddr(String filePath) throws IOException {
        List&amp;lt;String&amp;gt; addresses = new ArrayList&amp;lt;&amp;gt;();
        Scanner sc = new Scanner(new File(filePath));
        while (sc.hasNext()) {
            String line = sc.next();
            if(validIP(line))
                addresses.add(line);
        }
        return addresses;
    }

    private boolean validIP(String str) {
        try {
            String[] parts = str.split(&amp;quot;.&amp;quot;);
            // check segment length;
            if (parts.length != 4 || str.endsWith(&amp;quot;.&amp;quot;))
                return false;

            // check each segment valid or not
            for (int i = 0; i &amp;lt; parts.length; i++) {
                String s = parts[i];
                int val = Integer.parseInt(s);
                if ((s.charAt(0) == &#39;0&#39;) || (val &amp;lt; 0 || val &amp;gt; 255)
                        || (i == 0 &amp;amp;&amp;amp; val == 0))
                    return false;
            }
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Isomorphic Pair</title>
      <link>http://xmruibi.github.io/2015/11/14/isomorphic-pair/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/isomorphic-pair/</guid>
      <description>

&lt;p&gt;Given two words as Strings, determine if they are isomorphic. Two words are called isomorphic if the letters in one word can be remapped to get the second word. Remapping a letter means replacing all occurrences of it with another letter while the ordering of the letters remains unchanged. No two letters may map to the same letter, but a letter may map to itself.&lt;/p&gt;

&lt;h2 id=&#34;think-1:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Two Hashmap for mapping A-B and B-A.&lt;/li&gt;
&lt;li&gt;make sure both mapping are correct if any character appear in its corresponding mapping.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public boolean isomorphicString(String str1, String str2) {
		if (str1 == null || str2 == null || str1.length() != str2.length())
			return false;
		HashMap&amp;lt;Character, Character&amp;gt; mapAB = new HashMap&amp;lt;&amp;gt;();
		HashMap&amp;lt;Character, Character&amp;gt; mapBA = new HashMap&amp;lt;&amp;gt;();
		for (int i = 0; i &amp;lt; str1.length(); i++) {
			char a = str1.charAt(i);
			char b = str2.charAt(i);
			if (!mapAB.containsKey(a) &amp;amp;&amp;amp; !mapBA.containsKey(b)) {
				mapAB.put(a, b);
				mapBA.put(b, a);
			} else {
				if (mapAB.containsKey(a) &amp;amp;&amp;amp; mapAB.get(a) != b)
					return false;
				if (mapBA.containsKey(b) &amp;amp;&amp;amp; mapBA.get(b) != a)
					return false;
			}
		}
		return true;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;One Hashmap&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public boolean isomorphicStringII(String str1, String str2) {
		if ((str1 == null &amp;amp;&amp;amp; str2 == null)
				|| (str1.length() == 0 &amp;amp;&amp;amp; str2.length() == 0)
				|| str1.equals(str2))
			return true;
		if (str1 == null || str2 == null || str1.length() != str2.length())
			return false;
		HashMap&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
		int i = 0;
		while (i &amp;lt; str1.length()) {
			char a = str1.charAt(i);
			char b = str2.charAt(i);
			if (map.containsKey(a)) {
				if (map.get(a) != b)
					return false;
			} else {
				if (map.containsValue(b))
					return false;
				map.put(a, b);
			}
			i++;
		}
		return true;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-3:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Think #3&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Integer Array with 512 length&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-3:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Solution #3&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public boolean isIsomorphic(String s1, String s2) {
        int[] m = new int[512];
        for (int i = 0; i &amp;lt; s1.length(); i++) {
            if (m[s1.charAt(i)] != m[s2.charAt(i)+256]) 
                return false;
            m[s1.charAt(i)] = m[s2.charAt(i)+256] = i+1;
        }
        return true;	
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Maximum Subarray of Sum / Product</title>
      <link>http://xmruibi.github.io/2015/11/14/maximum-subarray-of-sum-/-product/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/maximum-subarray-of-sum-/-product/</guid>
      <description>

&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest sum.&lt;/p&gt;

&lt;p&gt;For example, given the array &lt;code&gt;[−2,1,−3,4,−1,2,1,−5,4]&lt;/code&gt;,
the contiguous subarray &lt;code&gt;[4,−1,2,1]&lt;/code&gt; has the largest sum = &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int maxSubArray(int[] arr) {
        int maxSum = Integer.MIN_VALUE;
		int curSum = 0;
		for (int i = 0; i &amp;lt; arr.length; i++) {
			curSum += arr[i];
			maxSum = Math.max(maxSum, curSum);
			if (curSum &amp;lt; 0)
				curSum = 0;
		}
		return maxSum;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-record-index:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution #Record Index&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int[] maxSubArray(int[] arr) {
        int maxSum = Integer.MIN_VALUE;
		int curSum = 0;
		int prev = 0, l = 0, r = 0;
		for (int i = 0; i &amp;lt; arr.length; i++) {
			curSum += arr[i];
			if(curSum &amp;gt; maxSum) {
				maxSum = curSum;
				l = prev;
				r = i;
			}
			if (curSum &amp;lt; 0) {
				curSum = 0;
				prev = i + 1;
			}
		}
		return new int[]{l, r};
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest product.&lt;/p&gt;

&lt;p&gt;For example, given the array &lt;code&gt;[2,3,-2,4]&lt;/code&gt;,
the contiguous subarray &lt;code&gt;[2,3]&lt;/code&gt; has the largest product = &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution-1:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int maxProduct(int[] nums) {
        int glMax = Integer.MIN_VALUE;
        
        int localMin = 1; // record the current max
        int localMax = 1; // record the current min, since the negative number multiply with current number may leads to next product as the positive max
        for(int i = 0; i &amp;lt; nums.length; i++) {
            int tmp = localMax;
            localMax = Math.max(localMax*nums[i], Math.max(localMin*nums[i], nums[i]));
            localMin = Math.min(tmp*nums[i], Math.min(localMin*nums[i], nums[i]));
            glMax = Math.max(glMax, localMax);
        }
        
        return glMax;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>