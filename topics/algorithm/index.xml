<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/topics/algorithm/</link>
    <description>Recent content in Algorithm on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Sun, 01 Nov 2015 20:33:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/topics/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Wiggle Sort</title>
      <link>http://xmruibi.github.io/2015/11/01/wiggle-sort/</link>
      <pubDate>Sun, 01 Nov 2015 20:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/01/wiggle-sort/</guid>
      <description>

&lt;p&gt;Given an array, and re-arrange it to wiggle style in one pass.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;[1] &lt;code&gt;A0 &amp;gt;= A1 &amp;lt;= A2 &amp;gt;= A3 .... .... An&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[2] &lt;code&gt;A0 &amp;lt;= A1 &amp;gt;= A2 &amp;lt;= A3 .... .... An&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;Base case. The first two elements $$A&lt;em&gt;0$$, $$A_1$$ satisfy the rules, and $$A&lt;/em&gt;{0}$$ is in its desired position.&lt;/p&gt;

&lt;p&gt;Suppose $$A&lt;em&gt;0$$, &amp;hellip;. $$A_k$$ satisfy the rules, and $$A_0$$, &amp;hellip;. $$A&lt;/em&gt;{k-1}$$ are in their desired positions. We want to show that when we consider the pair $$A&lt;em&gt;{k}$$ and $$A&lt;/em&gt;{k+1}$$, the rules are not violated, and the new k-th element will be in its desired position. Without loss of generality, assume that the k-th element should be higher than both of its neighbors. Two cases:&lt;/p&gt;

&lt;p&gt;1) $$A&lt;em&gt;{k}$$ &amp;gt; $$A&lt;/em&gt;{k+1}$$.
We are good in this case. $$A_{k}$$ is its desired position, and no rules are violated so far.&lt;/p&gt;

&lt;p&gt;2) $$A&lt;em&gt;{k}$$ &amp;lt; $$A&lt;/em&gt;{k+1}$$.
We swap $$A&lt;em&gt;{k}$$ and $$A&lt;/em&gt;{k+1}$$. Note that this does not violate $$A&lt;em&gt;{k-1}$$, since $$A&lt;/em&gt;{k-1}$$ &amp;lt;$$A&lt;em&gt;{k}$$&amp;lt; $$A&lt;/em&gt;{k+1}$$. And the new k-th element (previous $$A_{k+1}$$) satisfies the rules, and is in its desired position.&lt;/p&gt;

&lt;p&gt;So throughout the process, we do not violate any rules. The algorithm is correct.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void wiggleSort(int[] arr, boolean swither){
    int idx = 0;
    while(idx &amp;lt; arr.length - 1){
        if((switcher &amp;amp;&amp;amp; arr[idx] &amp;lt; arr[idx + 1])||(!switcher &amp;amp;&amp;amp; arr[idx] &amp;gt; arr[idx + 1])){
            int tmp = arr[idx];
            arr[idx] = arr[idx + 1];
            arr[idx+1] = tmp;
            switcher ^= true;
        }
      idx ++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sort Algorithms Conclusion</title>
      <link>http://xmruibi.github.io/2015/11/01/sort-algorithms-conclusion/</link>
      <pubDate>Sun, 01 Nov 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/01/sort-algorithms-conclusion/</guid>
      <description>

&lt;p&gt;Sorting is ordering a list of objects. We can distinguish two types of sorting. If the number of objects is small enough to fits into the main memory, sorting is called internal sorting. If the number of objects is so large that some of them reside on external storage during the sort, it is called external sorting. In this chapter we consider the following internal sorting algorithms&lt;/p&gt;

&lt;h2 id=&#34;by-complexity&#34;&gt;By Complexity&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Time Complexity: $$O(N^2)$$

&lt;ul&gt;
&lt;li&gt;Bubble Sort&lt;/li&gt;
&lt;li&gt;Selection Sort&lt;/li&gt;
&lt;li&gt;Insertion Sort (min: $$O(N))$$&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Time Complexity: $$O(Nlog_2N)$$

&lt;ul&gt;
&lt;li&gt;Quick Sort (Space Complexity: $$O(Nlog_2N)$$)&lt;/li&gt;
&lt;li&gt;Merge Sort (Space Complexity: $$O(N)$$)&lt;/li&gt;
&lt;li&gt;Heap Sort&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Time Complexity: $$O(N)$$ &amp;amp;&amp;amp; Space Complexity: $$O(N)$$

&lt;ul&gt;
&lt;li&gt;Bucket sort&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;by-stable&#34;&gt;By Stable&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Stable

&lt;ul&gt;
&lt;li&gt;Insertion sort&lt;/li&gt;
&lt;li&gt;Merge Sort&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Not Stable&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Bubble Sort&lt;/li&gt;
&lt;li&gt;Selection Sort&lt;/li&gt;
&lt;li&gt;Quick Sort&lt;/li&gt;
&lt;li&gt;Merge Sort&lt;/li&gt;
&lt;li&gt;Heap Sort&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;elementary-sort&#34;&gt;Elementary Sort&lt;/h1&gt;

&lt;p&gt;These are most basic sort methods with $$O(N^2)$$ time complexity.&lt;/p&gt;

&lt;h2 id=&#34;bubble-sort&#34;&gt;Bubble Sort&lt;/h2&gt;

&lt;h3 id=&#34;think&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Swap when the two adjacent elements is not in order&lt;/li&gt;
&lt;li&gt;Do a while loop until swap not happened in previous element order check&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void bubbleSort(int[] arr){
    boolean swap;
    do{
        swap = false;
        for(int i = 0; i &amp;lt; arr.length - 1; i++){
            if(arr[i] &amp;gt; arr[i + 1]){
                int tmp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = tmp;
                swap = true;
            }
        }
    }while(swap);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;insertion-sort&#34;&gt;Insertion Sort&lt;/h2&gt;

&lt;h3 id=&#34;think-1&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Get the target value from head of array&lt;/li&gt;
&lt;li&gt;Find its suitable position from 0 to its position&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-1&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void insertionSort(int[] arr){
    for(int i = 1; i &amp;lt; arr.length; i++){
        for(int j = 0; j &amp;lt; i; j++) {
            if(arr[j] &amp;gt; arr[i]) {
                int tmp = arr[j];
                arr[j] = arr[i];
                arr[i] = tmp;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;selection-sort&#34;&gt;Selection Sort&lt;/h2&gt;

&lt;h3 id=&#34;think-2&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Get the target value from head of array&lt;/li&gt;
&lt;li&gt;Find the minimum element on the right of target, swap them if minimum less then target&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-2&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void selectionSort(int[] arr){
    for(int i = 0; i &amp;lt; arr.length - 1; i++){
        int min = i;
        for(int j = i + 1; j &amp;lt; arr.length; j++) {
            if(arr[min] &amp;gt; arr[j])
                min = j;
        }
        if(i!=min) {
            int tmp = arr[min];
            arr[min] = arr[i];
            arr[i] = tmp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;advanced-sort&#34;&gt;Advanced Sort&lt;/h1&gt;

&lt;h2 id=&#34;merge-sort&#34;&gt;Merge Sort&lt;/h2&gt;

&lt;h3 id=&#34;think-3&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Divide and Conquer&lt;/li&gt;
&lt;li&gt;Recursion&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-3&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void mergeSort(int[] arr, int left, int right){
    if(left &amp;gt;= right)
        return;
    int mid = left + ((right - left) &amp;gt;&amp;gt; 1);
    mergeSort(arr, left, mid - 1);
    mergeSort(arr, mid, right);
    merge(arr, left, mid, right);
}

private void merge(int[] arr, int left, int mid, int right){
    int[] newarr = new int[right - left + 1];
  
    for(int i = left; i &amp;lt;= right; i++)
        newarr[i - left] = arr[i];
  
    int l = 0;
    int r = mid - left + 1;
    for(int i = left; i &amp;lt;= right; i++){
        if(l &amp;gt; mid - left)
            arr[i] = newarr[r++];
        else if(r &amp;gt; right - left)
            arr[i] = newarr[l++];
        else
            arr[i] = newarr[l] &amp;lt; newarr[r]? newarr[l++] : newarr[r++];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;quick-sort&#34;&gt;Quick Sort&lt;/h2&gt;

&lt;h3 id=&#34;think-4&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Set pivot (the rear of array or ) and consider it as a standard&lt;/li&gt;
&lt;li&gt;Pass the array and make the element less than pivot on the pivot&amp;rsquo;s left and the element larger than pivot on the pivot&amp;rsquo;s right;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-4&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void quickSort(int[] arr, int l, int r){
    if(l &amp;gt; r)
        return;
        
    int pivot = pivot(arr, l, r);
    quickSort(arr, l, pivot - 1);
    quickSort(arr, pivot + 1, r);
}


private int pivot(int[] arr, int l, int r){
    int pivot = arr[r];
    int idx = l;
    for(int i = l; i &amp;lt; r; i++){
        if(arr[i] &amp;lt; pivot){
            int tmp = arr[idx];
            arr[idx++] = arr[i];
            arr[i] = tmp;
        }
    }
    arr[r] = arr[idx];
    arr[idx] = pivot;
    return idx;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Rotate Iterator</title>
      <link>http://xmruibi.github.io/2015/11/01/rotate-iterator/</link>
      <pubDate>Sun, 01 Nov 2015 10:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/11/01/rotate-iterator/</guid>
      <description>

&lt;p&gt;The followup question for &lt;code&gt;Iterator of Iterators&lt;/code&gt;. But this time, the output is like &amp;lsquo;up-down&amp;rsquo; format.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RotateIterators&amp;lt;T&amp;gt; implements Iterator&amp;lt;T&amp;gt; {
    public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; l1 = new ArrayList&amp;lt;Integer&amp;gt;();
		l1.add(1);
		l1.add(4);
		l1.add(3);
		l1.add(8);
		l1.add(10);
		List&amp;lt;Integer&amp;gt; l2 = new ArrayList&amp;lt;Integer&amp;gt;();
		l2.add(17);
		l2.add(12);

		List&amp;lt;Integer&amp;gt; l3 = new ArrayList&amp;lt;Integer&amp;gt;();
		l3.add(3);
		l3.add(5);
		l3.add(14);
		List&amp;lt;Iterator&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
		list.add(l1.iterator());
		list.add(l2.iterator());
		list.add(l3.iterator());
		RotateIterators rt = new RotateIterators&amp;lt;&amp;gt;(list);
		while(rt.hasNext()){
			System.out.println(rt.next());
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;output&#34;&gt;Output&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1
17
3
4
12
5
3
14
8
10
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hasNext()&lt;/code&gt; is only for checking the pointer is null or valid&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next()&lt;/code&gt; should return the current value and also jump the pointer&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RotateIterators&amp;lt;T&amp;gt; implements Iterator&amp;lt;T&amp;gt; {
    private Iterator&amp;lt;T&amp;gt; current; // the current concrete iterator (small, detail)
    private List&amp;lt;Iterator&amp;lt;T&amp;gt;&amp;gt; iterators; // the cursor iterator which current iterator belong to (big, indexing)
    private int listIdx;

    public RotateIterators(List&amp;lt;Iterator&amp;lt;T&amp;gt;&amp;gt; iterators) {
        if (iterators == null)
            throw new IllegalArgumentException(&amp;quot;iterators is null&amp;quot;);
        this.iterators = (List&amp;lt;Iterator&amp;lt;T&amp;gt;&amp;gt;) iterators;
        this.current = iterators.get(listIdx = 0);
    }

    @Override
    public boolean hasNext() {
        int cntLmt = iterators.size(); // limit the loop, the max search limit is the size of iterators list
        while (current == null || !current.hasNext() &amp;amp;&amp;amp; cntLmt &amp;gt; 0){
            cntLmt--;
            if (listIdx &amp;lt; iterators.size() - 1)
                current = iterators.get(++listIdx);
            else
                current = iterators.get(listIdx = 0);   
        }
        return current.hasNext();
    }

    @Override
    public T next() {
        T res = current.next();
        // current pointer should jump to next 
        if (listIdx &amp;lt; iterators.size() - 1)
            current = iterators.get(++listIdx);
        else
            current = iterators.get(listIdx = 0);   
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Even Iterator</title>
      <link>http://xmruibi.github.io/2015/10/31/even-iterator/</link>
      <pubDate>Sat, 31 Oct 2015 10:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/31/even-iterator/</guid>
      <description>

&lt;p&gt;Implements an iterator only output the even number.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class EvenIterator implements Iterator&amp;lt;Integer&amp;gt; {
    public static void main(String[] args) {
		List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
		list.add(1); list.add(4); list.add(3); list.add(5);
		list.add(6); list.add(7); list.add(9); list.add(2);
		EvenIterator it = new EvenIterator(list.listIterator());
		while(it.hasNext()){
			System.out.println(it.next());
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;output&#34;&gt;Output&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;4
6
2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class EvenIterator implements Iterator&amp;lt;Integer&amp;gt; {

    Iterator&amp;lt;Integer&amp;gt; iterator;

    public EvenIterator(Iterator&amp;lt;Integer&amp;gt; iterator) {
        this.iterator = iterator;
    }

    @Override
    public boolean hasNext() {
        return iterator.hasNext();
    }

    @Override
    public Integer next() {
        int res = 0;
        while (iterator.hasNext() &amp;amp;&amp;amp; (res = iterator.next()) % 2 != 0)
            ;
        return res;
    }

    
    public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        list.add(1); list.add(4);
        list.add(3); list.add(5);
        list.add(6); list.add(7);
        list.add(9); list.add(2);
        EvenIterator it = new EvenIterator(list.listIterator());
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Iterator for Merging Sorted Stream</title>
      <link>http://xmruibi.github.io/2015/10/31/iterator-for-merging-sorted-stream/</link>
      <pubDate>Sat, 31 Oct 2015 10:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/31/iterator-for-merging-sorted-stream/</guid>
      <description>

&lt;p&gt;Given a &lt;code&gt;Merge Sorted Stream&lt;/code&gt; class contains some sorted stream which implements iterator interface. Each sorted stream class has some methods: &lt;code&gt;hasNext()&lt;/code&gt;, &lt;code&gt;next()&lt;/code&gt;. Sorted Stream defines the stream read data by ascending order, so that in &lt;code&gt;Merge Sorted Stream&lt;/code&gt; when call &lt;code&gt;next()&lt;/code&gt; method, it will return values by ascending order. Pleas complete the following codes.&lt;/p&gt;

&lt;h3 id=&#34;partital-code&#34;&gt;Partital Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class SortedStream implments Iterator&amp;lt;Integer&amp;gt;{
	List&amp;lt;Integer&amp;gt; content;
	int cursor;
	public SortedStream(List&amp;lt;Integer&amp;gt; content){
		if(content == null)
			throw new IllegalArgumentException(&amp;quot;Null Input&amp;quot;);
		this.content = content;
		this.cursor = 0;
	}

	public boolean hasNext(){return cursor &amp;lt; content.size();}

	public int next(){return content.get(cursor++);}
}

class MergeSortedStream implments Iterator&amp;lt;SortedStream&amp;gt;{
    List&amp;lt;SortedStream&amp;gt; content;
	SortedStream cursor;
	public MergeSortedStream(List&amp;lt;SortedStream&amp;gt; content){...}
	
	public boolean hasNext(){...};

	public int next(){...};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Merge Sorted data by Heap!&lt;/li&gt;
&lt;li&gt;Peek Iterator&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MergeSortedStream implments Iterator&amp;lt;SortedStream&amp;gt;{
    List&amp;lt;SortedStream&amp;gt; content;
    PriorityQueue&amp;lt;Integer&amp;gt; minheap;
    public MergeSortedStream(List&amp;lt;SortedStream&amp;gt; content){
        this.minheap = new PriorityQueue&amp;lt;&amp;gt;();
        this.content = content;
        for(SortedStream ss : content) {
            if(ss != null &amp;amp;&amp;amp; ss.hasNext())
                minheap.add(ss.next());
        }
    }
    
    public boolean hasNext() {
        for (SortedStream ss : content) {
            if (ss != null &amp;amp;&amp;amp; ss.hasNext())
                minheap.add(ss.next());
        }
        return !minheap.isEmpty();
    }

    public int next(){
        return minheap.poll();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Jump Iterator</title>
      <link>http://xmruibi.github.io/2015/10/31/jump-iterator/</link>
      <pubDate>Sat, 31 Oct 2015 10:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/31/jump-iterator/</guid>
      <description>

&lt;p&gt;Implements an iterator in each output it print the number and skip the next one.&lt;/p&gt;

&lt;h3 id=&#34;partial-code&#34;&gt;Partial Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JumpIterator implements Iterator&amp;lt;Integer&amp;gt; {
    public static void main(String[] args) {
		List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
		list.add(1); list.add(4);
		list.add(3); list.add(5);
		list.add(6); list.add(7);
		list.add(2);
		JumpIterator it = new JumpIterator(list.listIterator());
		while(it.hasNext()){
			System.out.println(it.next());
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;output&#34;&gt;Output&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1
3
6
2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JumpIterator implements Iterator&amp;lt;Integer&amp;gt; {

    Iterator&amp;lt;Integer&amp;gt; iterator;

    public JumpIterator(Iterator&amp;lt;Integer&amp;gt; iterator) {
        this.iterator = iterator;
    }

    @Override
    public boolean hasNext() {
        return iterator.hasNext();
    }

    @Override
    public Integer next() {
        int res = iterator.next();
        if (iterator.hasNext())
            iterator.next();
        return res;
    }

    public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        list.add(1); list.add(4);
        list.add(3); list.add(5);
        list.add(6); list.add(7);
        list.add(2);
        JumpIterator it = new JumpIterator(list.listIterator());
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Peeking Iterator</title>
      <link>http://xmruibi.github.io/2015/10/31/peeking-iterator/</link>
      <pubDate>Sat, 31 Oct 2015 10:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/31/peeking-iterator/</guid>
      <description>

&lt;p&gt;Given an Iterator class interface with methods: &lt;code&gt;next()&lt;/code&gt; and &lt;code&gt;hasNext()&lt;/code&gt;, design and implement a PeekingIterator that support the peek() operation &amp;ndash; it essentially &lt;code&gt;peek()&lt;/code&gt; at the element that will be returned by the next call to &lt;code&gt;next()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is an example. Assume that the iterator is initialized to the beginning of the list: &lt;code&gt;[1, 2, 3]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Call &lt;code&gt;next()&lt;/code&gt; gets you 1, the first element in the list.&lt;/p&gt;

&lt;p&gt;Now you call &lt;code&gt;peek()&lt;/code&gt; and it returns 2, the next element. Calling &lt;code&gt;next()&lt;/code&gt; after that still return 2.&lt;/p&gt;

&lt;p&gt;You call &lt;code&gt;next()&lt;/code&gt;the final time and it returns 3, the last element. Calling &lt;code&gt;hasNext()&lt;/code&gt; after that should return false.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class PeekingIterator implements Iterator&amp;lt;Integer&amp;gt; {
    
    int cur;
    Iterator&amp;lt;Integer&amp;gt; it;
    public PeekingIterator(Iterator&amp;lt;Integer&amp;gt; iterator) {
        this.it = iterator;
        cur = it.hasNext() ? it.next() : null;
    }

    // Returns the next element in the iteration without advancing the iterator.
    public Integer peek() {
        return cur;
    }

    // hasNext() and next() should behave the same as in the Iterator interface.
    // Override them if needed.
    @Override
    public Integer next() {
        int res = curl
        cur = it.next() ? it.next() : null;
        return res;
    }

    @Override
    public boolean hasNext() {
        return it.hasNext();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Scramble Number Pair Calculator</title>
      <link>http://xmruibi.github.io/2015/10/29/scramble-number-pair-calculator/</link>
      <pubDate>Thu, 29 Oct 2015 15:14:18 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/29/scramble-number-pair-calculator/</guid>
      <description>

&lt;p&gt;Let a pair of distinct positive integers, (i, j), be considered &amp;laquo;scrambled&amp;raquo; if you can obtain j by reordering the digits of i.  For example, (12345, 25341) is a scrambled pair, but (12345, 67890) is not.&lt;/p&gt;

&lt;p&gt;Given integers A and B with the same number of digits and no leading zeroes, how many distinct scrambled pairs (i, j) are there that satisfy: A &amp;lt;= i &amp;lt; j &amp;lt;= B?&lt;/p&gt;

&lt;p&gt;For instance, if we let A = 10 and B = 99, the answer is 36:
(12,21), (13,31), (14,41), (15,51), (16,61), (17,71), (18,81), (19,91), (23,32), (24,42), (25,52), (26,62), (27,72), (28,82), (29,92), (34,43), (35,53), (36,63), (37,73), (38,83), (39,93), (45,54), (46,64), (47,74), (48,84), (49,94), (56,65), (57,75), (58,85), (59,95), (67,76), (68,86), (69,96), (78,87), (79,97), (89,98)&lt;/p&gt;

&lt;h2 id=&#34;think-and-solution&#34;&gt;Think and Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println(&amp;quot;Input min range: &amp;quot;);
        int min = scanner.nextInt();
        System.out.println(&amp;quot;Input max range: &amp;quot;);
        int max = scanner.nextInt();
        System.out.print(scrambleNumberCalculator(min, max));
        Map&amp;lt;Object,Object&amp;gt;  map = new HashMap();
        
    }
    
    /**
     * Main function to do the scramble number pair calculation
     * @param minRange  : minimum of range 
     * @param maxRange : maximum of range
     * @return
     */
    public  static long scrambleNumberCalculator(int min, int max) {
        // the total scramble number set to avoid duplicate calculate
        Set&amp;lt;Integer&amp;gt; pairs = new HashSet&amp;lt;&amp;gt;();
                
        // the result of pairs count;
        long cnt = 0;   
        int[] range = new int[]{min, max};
        for (int i = range[0]; i &amp;lt;= range[1]; i++) {
            if (pairs.contains(i))
                continue;
            Set&amp;lt;Integer&amp;gt; res = new HashSet&amp;lt;&amp;gt;();
            List&amp;lt;Integer&amp;gt; list = convertDigitsList(i);
            permutation(res, list, range, 0, list.size());          
            cnt += combinationPair(res.size());
            // res size equal to one means there is no pair for this number
            // for saving pairs space I don&#39;t add the number with no scramble pair.
            if(res.size() &amp;gt; 1)
                pairs.addAll(res);
        }
        // System.out.println(pairs);
        return cnt;
    }
    
    /**
     * The function to check current number has how many scramble number and store it in a set,
     * recursion without return value but values are recorded in permutation set
     * 
     * @param res: the permutation result storage as a set
     * @param digits: the current number digits for permutation 
     * @param range: the range of output val
     * @param cur: current permutation value
     * @param idx: current permutation index for digits list
     */
    private static void permutation(Set&amp;lt;Integer&amp;gt; res, List&amp;lt;Integer&amp;gt; digits, int[] range,
            int cur, int idx) {
        if (idx == 0) {
            if (cur &amp;gt;= range[0] &amp;amp;&amp;amp; cur &amp;lt;= range[1])
                res.add(cur);
            return;
        }
        for (int i = 0; i &amp;lt; digits.size(); i++) {
            // avoid the zero leading number
            if (cur == 0 &amp;amp;&amp;amp; digits.get(i) == 0)
                continue;
            cur = cur * 10 + digits.get(i);
            digits.remove(i);
            permutation(res, digits, range, cur, idx - 1);
            digits.add(i, cur % 10);
            cur /= 10;
        }
    }

    /**
     * The function to count the pair amount in permutation set by just using the size of current scramble number set
     * @param num: consider the large input I use long type here
     * @return the amount of pair in current permutation set
     */
    private static long combinationPair(long num) {
        long pairCnt = 0;
        for (int i = 0; i &amp;lt; num - 1; i++)
            for (int j = i + 1; j &amp;lt; num; j++)
                pairCnt++;
        return pairCnt;
    }

    /**
     * The function to convert a number into a list with digits make the permutation more convenient
     * @param num
     * @return
     */
    private static List&amp;lt;Integer&amp;gt; convertDigitsList(int num) {
        List&amp;lt;Integer&amp;gt; res = new LinkedList&amp;lt;&amp;gt;();
        while (num &amp;gt; 0) {
            res.add(0, num % 10);
            num /= 10;
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Search Range in Binary Search Tree</title>
      <link>http://xmruibi.github.io/2015/10/27/search-range-in-binary-search-tree/</link>
      <pubDate>Tue, 27 Oct 2015 13:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/27/search-range-in-binary-search-tree/</guid>
      <description>

&lt;p&gt;Given two values k1 and k2 (where k1 &amp;lt; k2) and a root pointer to a Binary Search Tree. Find all the keys of tree in range k1 to k2. i.e. print all x such that k1&amp;lt;=x&amp;lt;=k2 and x is a key of given BST. Return all the keys in ascending order.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;If k1 = 10 and k2 = 22, then your function should return [12, 20, 22].&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    20
   /  \
  8   22
 / \
4   12
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Recursion on each valid node.&lt;/li&gt;
&lt;li&gt;For invalid node, if it is less than k1, check its right child, while if it is larger than k2, check its left child&lt;/li&gt;
&lt;li&gt;Add the result from left and itself and right&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param root: The root of the binary search tree.
     * @param k1 and k2: range k1 to k2.
     * @return: Return all keys that k1&amp;lt;=key&amp;lt;=k2 in ascending order.
     */
    public ArrayList&amp;lt;Integer&amp;gt; searchRange(TreeNode root, int k1, int k2) {
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(root == null)
            return res;
        ArrayList&amp;lt;Integer&amp;gt; left = searchRange(root.left, k1, k2);
        ArrayList&amp;lt;Integer&amp;gt; right = searchRange(root.right, k1, k2);
        // current value is less than k1, check its right child
        if(root.val &amp;lt; k1)
            return right;
        // current value is larger than k2, check its left child
        if(root.val &amp;gt; k2)
            return left;
        // add left branch first then itself and then right branch
        res.addAll(left);
        res.add(root.val);
        res.addAll(right);
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Print Numbers by Recursion</title>
      <link>http://xmruibi.github.io/2015/10/26/print-numbers-by-recursion/</link>
      <pubDate>Mon, 26 Oct 2015 16:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/26/print-numbers-by-recursion/</guid>
      <description>

&lt;p&gt;Print numbers from 1 to the largest number with &lt;code&gt;N&lt;/code&gt; digits by recursion.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;N = 1&lt;/code&gt;, return &lt;code&gt;[1,2,3,4,5,6,7,8,9]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Given &lt;code&gt;N = 2&lt;/code&gt;, return &lt;code&gt;[1,2,3,4,5,6,7,8,9,10,11,12,...,99]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s pretty easy to do recursion like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;recursion(i) {
    if i &amp;gt; largest number:
        return
    results.add(i)
    recursion(i + 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However this cost a lot of recursion memory as the recursion depth maybe very large ($$10^n - 1$$). Can you do it in another way to recursive with at most N depth?&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it in recursion, not for-loop.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Think from bottom to top.&lt;/li&gt;
&lt;li&gt;Build the result list from number with one digits to N digits.&lt;/li&gt;
&lt;li&gt;Since we considering with digits as its deep, we have to set a loop to add the number in list on the new-generated base number (1 - 9 with following digits):&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;when zero digit, none;
when one digit, new-generated base number is 1, add 1,2,...9;
when two digit, new-generated base number is 10, add 10,20,...90;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Each time when having the new-generated base number, we need to pass through the original result list to fill the rest of number with beginning as new-generated base number.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;when one digit, new-generated base number is 1, add 1,2,...9, but original result list has nothing. so just add itself;
when two digit, new-generated base number is 10, when add 10, go back the original result list with &amp;quot;1, 2, 3,..., 9&amp;quot;, add them as 11, 12, 13, ..., 19, when add 20, go back the original result list with &amp;quot;1, 2, 3,..., 9&amp;quot;, add them as 21, 22, 23, ..., 29;
so the same as for 30,..., 90, 100, ..., 900, ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param n: An integer.
     * return : An array storing 1 to the largest number with n digits.
     */
    public List&amp;lt;Integer&amp;gt; numbersByRecursion(int n) {
        List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(n &amp;gt;= 0)
            add(res, n);
        return res;
    }
    
    private int add(List&amp;lt;Integer&amp;gt; res, int n){
        if(n == 0)
            return 1;
        
        int cur = add(res, n - 1);
        int size = res.size();
        for(int i = 1; i &amp;lt;= 9; i ++) {
            int digit = i * cur;
            res.add(digit);
            for(int j = 0; j &amp;lt; size; j++) {
                res.add(digit + res.get(j));
            }
        }
        return cur * 10;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis&lt;/h2&gt;

&lt;p&gt;Time: $$O(10^n - 1)$$&lt;/p&gt;

&lt;p&gt;Space: $$O(n)$$&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Boggle Game</title>
      <link>http://xmruibi.github.io/2015/10/25/boggle-game/</link>
      <pubDate>Sun, 25 Oct 2015 20:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/boggle-game/</guid>
      <description>

&lt;p&gt;Given a dictionary, a method to do lookup in dictionary and a M x N board where every cell has one character. Find all possible words that can be formed by a sequence of adjacent characters. Note that we can move to any of 8 adjacent characters, but a word should not have multiple instances of same cell.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;DFS on character board to do backtracking.&lt;/li&gt;
&lt;li&gt;Searching the character for 8 directions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {

    public List&amp;lt;String&amp;gt; findWords(HashSet&amp;lt;String&amp;gt; dict, char[][] board) {
        List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        boolean[][] visited = new boolean[board.length][board[0].length];
        for(int i = 0; i &amp;lt; board.length; i++) {
            for(int j = 0; j &amp;lt; board[i].length; j++) {
                findUtil(res, dict, board, visited, &amp;quot;&amp;quot;, i, j);
            }
        }
        return res;
    }

    private void findUtil(List&amp;lt;String&amp;gt; res, HashSet&amp;lt;String&amp;gt; dict, char[][] board, boolean[][] visited, String cur, int x, int y) {
        visited[x][y] = true;
        cur += board[x][y];

        if(dict.contains(cur)) {
            res.add(cur);
            dict.remvoe(cur);
            return;
        }
        
        int[] xs = {1,1,1,0,0,-1,-1,-1};
        int[] ys = {1,-1,0,1,-1,0,1,-1};
        for(int i = 0; i &amp;lt; 8; i++) {
            int nx = xs[i] + x;
            int ny = ys[i] + y;
            if(nx &amp;gt;= 0 &amp;amp;&amp;amp; nx &amp;lt; board.length &amp;amp;&amp;amp; ny &amp;gt;= 0 &amp;amp;&amp;amp; ny &amp;lt; board[nx].length &amp;amp;&amp;amp; !visited[nx][ny])
                findUtil(res, dict, board, visited, cur, nx, ny);
        }
        visited[x][y] = false;
        cur = cur.substring(0, cur.length() - 1);
    }

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Convert Sorted List to Binary Search Tree</title>
      <link>http://xmruibi.github.io/2015/10/25/convert-sorted-list-to-binary-search-tree/</link>
      <pubDate>Sun, 25 Oct 2015 20:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/convert-sorted-list-to-binary-search-tree/</guid>
      <description>

&lt;p&gt;Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;               2
1-&amp;gt;2-&amp;gt;3  =&amp;gt;   / \
             1   3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Find the middle point in list&lt;/li&gt;
&lt;li&gt;Divide and Conquer to build left child and right child node&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head: The first node of linked list.
     * @return: a tree node
     */
    public TreeNode sortedListToBST(ListNode head) {  
        // write your code here
        if(head == null)
            return null;
        if(head.next == null)
            return new TreeNode(head.val);
            
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode runner = head;
        ListNode walker = dummy;
        while(runner!=null &amp;amp;&amp;amp; runner.next!=null) {
            runner = runner.next.next;
            walker = walker.next;
        }
        
        ListNode m = walker.next;
        TreeNode root = new TreeNode(m.val);
        ListNode left = dummy.next;
        ListNode right = walker.next.next;
        walker.next = null;
        root.left = sortedListToBST(left);
        root.right = sortedListToBST(right);
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Remove Duplicates from Sorted List II</title>
      <link>http://xmruibi.github.io/2015/10/25/remove-duplicates-from-sorted-list-ii/</link>
      <pubDate>Sun, 25 Oct 2015 20:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/remove-duplicates-from-sorted-list-ii/</guid>
      <description>

&lt;p&gt;Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5&lt;/code&gt;, return &lt;code&gt;1-&amp;gt;2-&amp;gt;5&lt;/code&gt;.
Given &lt;code&gt;1-&amp;gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3&lt;/code&gt;, return &lt;code&gt;2-&amp;gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param ListNode head is the head of the linked list
     * @return: ListNode head of the linked list
     */
    public static ListNode deleteDuplicates(ListNode head) {
        // write your code here
        if(head == null || head.next == null)
            return head;
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        while(head != null){
            ListNode cur = head;
            while(head.next != null &amp;amp;&amp;amp; cur.val == head.next.val)
                head = head.next;
            
            if(head != cur){
                pre.next = head.next;
            }else
                pre = pre.next;
            head = head.next;
        }
        
        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Copy List with Random Pointer</title>
      <link>http://xmruibi.github.io/2015/10/25/copy-list-with-random-pointer/</link>
      <pubDate>Sun, 25 Oct 2015 20:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/copy-list-with-random-pointer/</guid>
      <description>

&lt;p&gt;Merge k sorted linked lists and return it as one sorted list.&lt;/p&gt;

&lt;p&gt;Analyze and describe its complexity.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given lists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  2-&amp;gt;4-&amp;gt;null,
  null,
  -1-&amp;gt;null
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return &lt;code&gt;-1-&amp;gt;2-&amp;gt;4-&amp;gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use a heap to receive element from linked list&lt;/li&gt;
&lt;li&gt;Tricky part:

&lt;ul&gt;
&lt;li&gt;Just entered k node in heap instead of pass all nodes in lists.&lt;/li&gt;
&lt;li&gt;When poll out element, it also need to push back the next node of polled node.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param lists: a list of ListNode
     * @return: The head of one sorted list.
     */
    public ListNode mergeKLists(List&amp;lt;ListNode&amp;gt; lists) {  
        if(lists == null)
            return null;
        
        PriorityQueue&amp;lt;ListNode&amp;gt; queue = new PriorityQueue&amp;lt;ListNode&amp;gt;(10, new Comparator&amp;lt;ListNode&amp;gt;(){
            @Override
            public int compare(ListNode o1, ListNode o2){
                return Integer.compare(o1.val, o2.val);
            }
        });
        // O(n) : n total nodes 
        for(ListNode node : lists){
            if(node != null)
                queue.offer(node);
        }
        
        ListNode dummy = new ListNode(0);
        ListNode pre = dummy;
        while(!queue.isEmpty()){
            ListNode cur = queue.remove();
            if(cur.next != null)
                queue.offer(cur.next);
            pre.next = cur;
            pre = cur;
        }
        
        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Remove Nth Node From End of List</title>
      <link>http://xmruibi.github.io/2015/10/25/remove-nth-node-from-end-of-list/</link>
      <pubDate>Sun, 25 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/remove-nth-node-from-end-of-list/</guid>
      <description>

&lt;p&gt;Given a linked list, remove the nth node from the end of list and return its head.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given linked list: &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;null&lt;/code&gt;, and n = &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After removing the second node from the end, the linked list becomes &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;5-&amp;gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The minimum number of nodes in list is n.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n) time&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Typical idea on runner and walker linked list question&lt;/li&gt;
&lt;li&gt;Let runner node run for N step further than walker node.&lt;/li&gt;
&lt;li&gt;Get the N + 1 th position from end of list.&lt;/li&gt;
&lt;li&gt;Remove walker.next which is the target node.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head: The first node of linked list.
     * @param n: An integer.
     * @return: The head of linked list.
     */
    ListNode removeNthFromEnd(ListNode head, int n) {
        if(head==null)
            return head;
        ListNode runner = head;
        ListNode pre = new ListNode(0);
        pre.next = head;
        ListNode walker = pre;
        while(n&amp;gt;0&amp;amp;&amp;amp;runner!=null){
            runner = runner.next;
            n--;
        }
        while(runner!=null){
            runner = runner.next;
            walker = walker.next;
        }
        walker.next = walker.next.next;
        return pre.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>