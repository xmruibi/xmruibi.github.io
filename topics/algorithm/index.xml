<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Geek Think</title>
    <link>http://xmruibi.github.io/topics/algorithm/</link>
    <description>Recent content in Algorithm on Geek Think</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Sun, 15 Nov 2015 20:33:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/topics/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Compact Tree Builder</title>
      <link>http://xmruibi.github.io/2015/11/15/compact-tree-builder/</link>
      <pubDate>Sun, 15 Nov 2015 20:33:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/compact-tree-builder/</guid>
      <description>

&lt;p&gt;Given a root of a binary tree. Transform it in a way that each node(except probably one) would either have N or 0 children.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   * A               A                 A                         A
     *  |               |                 |_B                       |_B
     *  |_B             |_B                  |_C                    |
     *     |            |  |                    |_D                 |_C
     *     |            |  |_D                     |_E              |
     *     |            |  |                          |_F           |_D
     *     |_C          |  |_E                           |_G        |
     *     | |_D        |    |_H                            |_H     |_E
     *     |    |_F     |                                           |
     *     |            |_C                                         |_F
     *     |_E            |                                         |
     *       |_G          |_F                                       |_G
     *       |            |                                         |
     *       |_H          |_G                                       |_H
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:397f4eeb84727cbe660f274d6bea7a6c&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;BFS entire tree into a queue.&lt;/li&gt;
&lt;li&gt;Read that queue and build posssible children according to the limit and add it into the root.&lt;/li&gt;
&lt;li&gt;Record the next root in another queue.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:397f4eeb84727cbe660f274d6bea7a6c&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	private static CTree compact(TreeNode node, int limit) {

		// bfs the original tree into a queue
		List&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
		queue.add(node);
		int idx = 0;
		while (idx &amp;lt; queue.size()) {
			TreeNode cur = queue.get(idx++);
			if (cur.left != null)
				queue.add(cur.left);
			if (cur.right != null)
				queue.add(cur.right);
		}
		// get the root for final return
		CTree root = new CTree(queue.remove(0).val);
		// build a queue for store the new type tree
		Queue&amp;lt;CTree&amp;gt; helperQueue = new LinkedList&amp;lt;&amp;gt;();
		helperQueue.add(root);
		while (!queue.isEmpty()) {
			CTree cRoot = helperQueue.remove();
			// build the children for current CTree
			int curLv = 0; // make sure the amount of children
			List&amp;lt;CTree&amp;gt; nexlv = new ArrayList&amp;lt;&amp;gt;();
			while (curLv &amp;lt; limit &amp;amp;&amp;amp; !queue.isEmpty()) {
				nexlv.add(new CTree(queue.remove(0).val));
				helperQueue.offer(nexlv.get(curLv++));
			}			
			cRoot.nodes = nexlv;
		}	
		return root;
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Convert BST to Sorted Doubly-Linked List</title>
      <link>http://xmruibi.github.io/2015/11/15/convert-bst-to-sorted-doubly-linked-list/</link>
      <pubDate>Sun, 15 Nov 2015 17:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/convert-bst-to-sorted-doubly-linked-list/</guid>
      <description>

&lt;p&gt;Given a Binary Tree (BT), convert it to a Doubly Linked List(DLL) In-Place. The left and right pointers in nodes are to be used as previous and next pointers respectively in converted DLL. The order of nodes in DLL must be same as Inorder of the given Binary Tree. The first node of Inorder traversal (left most node in BT) must be head node of the DLL.&lt;/p&gt;

&lt;h2 id=&#34;think:9391617169eedec55b65d518b5c0a515&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Inorder traversal&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-stack:9391617169eedec55b65d518b5c0a515&#34;&gt;Solution #Stack&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	private static Node convertBST2DoublyLinkedList(Node root) {
		Node dummy = new Node(0);
		Node prev = dummy;
		java.util.Stack&amp;lt;Node&amp;gt; stack = new java.util.Stack&amp;lt;&amp;gt;();

		do {
			while (root != null) {
				stack.push(root);
				root = root.prev;
			}
			Node cur = stack.pop();
			prev.next = cur;
			cur.prev = prev;
			prev = prev.next;
			if (cur.next != null)
				root = cur.next;
			else
				root = null;
		} while (!stack.isEmpty() || root != null);

		return dummy.next;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-recursion:9391617169eedec55b65d518b5c0a515&#34;&gt;Solution #Recursion&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
    static Node dummy = new Node(0);
    static Node pre = dummy;

    private static Node convertII(Node root) {
        if (root == null)
            return root;
        Node prev = convertII(root.prev);
        pre.next = root;
        root.prev = pre;
        pre = root;
        Node next = convertII(root.next);
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Palindromic Subsequence</title>
      <link>http://xmruibi.github.io/2015/11/15/longest-palindromic-subsequence/</link>
      <pubDate>Sun, 15 Nov 2015 14:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/longest-palindromic-subsequence/</guid>
      <description>

&lt;p&gt;Given a sequence, find the length of the longest palindromic subsequence in it. For example, if the given sequence is &lt;code&gt;“BBABCBCAB”&lt;/code&gt;, then the output should be 7 as &lt;code&gt;“BABCBAB”&lt;/code&gt; is the longest palindromic subseuqnce in it. &lt;code&gt;“BBBBB”&lt;/code&gt; and &lt;code&gt;“BBCBB”&lt;/code&gt; are also palindromic subsequences of the given sequence, but not the longest ones.&lt;/p&gt;

&lt;h2 id=&#34;solution-dynamic-programming:0dddaebd549f2b96d7e1c402abcf8d05&#34;&gt;Solution #Dynamic Programming&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static int longestSubsequence(String str) {
		// memo[len][i] represent from index &#39;i&#39; with length &#39;len&#39; has how many
		// palindromic subsequence
		int[][] memo = new int[str.length() + 1][str.length() + 1];

		// initial len with 1 as 1, since for every index it has 1 len
		// palindromic subsequence
		for (int i = 0; i &amp;lt; str.length(); i++)
			memo[1][i] = 1;

		// iterate the str with different length setting
		for (int len = 2; len &amp;lt;= str.length(); len++) {
			for (int i = 0; i &amp;lt;= str.length() - len; i++) {
				int tar = i + len - 1;
				if (len == 2 &amp;amp;&amp;amp; str.charAt(i) == str.charAt(tar))
					memo[len][i] = 2;
				else if (str.charAt(i) == str.charAt(tar))
					memo[len][i] = 2 + memo[len - 2][i + 1];
				else
					memo[len][i] = Math.max(memo[len - 1][i],
							memo[len - 1][i + 1]);
			}
		}
		return memo[str.length()][0];
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-recursive:0dddaebd549f2b96d7e1c402abcf8d05&#34;&gt;Solution # Recursive&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int calculateRecursive(char str[],int start,int len){
        if(len == 1){
            return 1;
        }
        if(len ==0){
            return 0;
        }
        if(str[start] == str[start+len-1]){
            return 2 + calculateRecursive(str,start+1,len-2);
        }else{
            return Math.max(calculateRecursive(str, start+1, len-1), calculateRecursive(str, start, len-1));
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Pow() and Sqrt()</title>
      <link>http://xmruibi.github.io/2015/11/15/pow-and-sqrt/</link>
      <pubDate>Sun, 15 Nov 2015 13:11:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/pow-and-sqrt/</guid>
      <description>

&lt;p&gt;Write function to get the power &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt; and the square root of &lt;code&gt;x&lt;/code&gt;;&lt;/p&gt;

&lt;h2 id=&#34;solution-pow:8f114c26f536717def87e4afa082746d&#34;&gt;Solution # Pow&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	// basic  
	public float pow(float x, int n) {
	    if(n==0)
            return 1.0;
		if (n == 1)
			return x;
		if (n % 2 == 0)
			return pow(x, n / 2) * pow(x, n / 2);
		else
			return x * pow(x, n / 2) * pow(x, n / 2);
	}

	// improved
	public double pow(double x, int n) {
        if(n==0)
            return 1.0;
        boolean neg = false;
        if(n&amp;lt;0)
            neg = true;
        double res = 1.0;
        while(n != 0){
            if(n%2 != 0){
                res *= x;
            }
            x *= x;
            n /= 2;
        }
        return neg?1.0/res:res;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-sqrt:8f114c26f536717def87e4afa082746d&#34;&gt;Solution # Sqrt&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public float sqrt(float n) {
        float low = 0, high = n;
        float mid = low + (high - low) / 2;
        while (Math.abs(mid * mid - n) &amp;gt; 0.00001) {
            if (mid * mid &amp;lt; n)
                low = mid;
            else if (mid * mid &amp;gt; n)
                high = mid;
            mid = low + (high - low) / 2;
        }
        return mid;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Max Points on a Line</title>
      <link>http://xmruibi.github.io/2015/11/15/max-points-on-a-line/</link>
      <pubDate>Sun, 15 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/max-points-on-a-line/</guid>
      <description>

&lt;p&gt;Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.&lt;/p&gt;

&lt;h2 id=&#34;think:0468874f3f0719bf48609e7d9f0fd5fc&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Represent line by ratio. Compare point to point by a nested two loop.&lt;/li&gt;
&lt;li&gt;Think about four cases:

&lt;ul&gt;
&lt;li&gt;Same point, count the same point amount&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; axis are the same&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt; axis are the same&lt;/li&gt;
&lt;li&gt;normal case &lt;code&gt;(y1 - y2)/(x1 - x2)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:0468874f3f0719bf48609e7d9f0fd5fc&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MaxPointOnAline {

    public int getMaxLine(List&amp;lt;FloatPoint&amp;gt; points) {
        if (points == null || points.size() == 0)
            return 0;

        int max = 0;
        for (int i = 0; i &amp;lt; points.size(); i++) {
            FloatPoint cur = points.get(i);
            Map&amp;lt;Double, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
            int same = 0, localMax = 1;
            for (int j = i + 1; j &amp;lt; points.size(); j++) {
                FloatPoint tar = points.get(j);
                if (cur.x == tar.x &amp;amp;&amp;amp; cur.y == tar.y) {
                    same++;
                }else if (cur.x == tar.x) {
                    double maxr = Double.MAX_VALUE;
                    map.put(maxr, map.containsKey(maxr) ? map.get(maxr) + 1 : 2);
                } else if (cur.y == tar.y) {
                    map.put(0.0, map.containsKey(0.0) ? map.get(0.0) + 1 : 2);
                } else {
                    double ratio = (cur.y - tar.y) / (cur.x - tar.x);
                    map.put(ratio, map.containsKey(ratio) ? map.get(ratio) + 1
                            : 2);
                }
            }
            for (Map.Entry&amp;lt;Double, Integer&amp;gt; entry : map.entrySet())
                localMax = Math.max(localMax, entry.getValue());
            max = Math.max(localMax + same, max);
        }
        return max;
    }
}

class FloatPoint {
    float x, y; // float may not suitable for accurate computation

    public FloatPoint(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Max Stack</title>
      <link>http://xmruibi.github.io/2015/11/15/max-stack/</link>
      <pubDate>Sun, 15 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/max-stack/</guid>
      <description>

&lt;p&gt;Design a stack, which makes the following function, try to reduce the time compaxity less than &lt;code&gt;O(n)&lt;/code&gt;
- &lt;code&gt;pop()&lt;/code&gt; pop the top of stack
- &lt;code&gt;push()&lt;/code&gt; push a element into stack
- &lt;code&gt;peek()&lt;/code&gt; peek the top of stack
- &lt;code&gt;peekMax()&lt;/code&gt; peek the max element of stack
- &lt;code&gt;popMax()&lt;/code&gt; pop the max element of stack&lt;/p&gt;

&lt;h2 id=&#34;think:0c76a512774b6e4792fd578d8968c8bd&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Typically, we can think about using one stacks and one heap. One of value, one of tracking the max stack.&lt;/li&gt;
&lt;li&gt;The most tricky part is pop max function. Make the node removal in O(n) should use the doubly linked list.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:0c76a512774b6e4792fd578d8968c8bd&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MaxStack {
    Stack elem = new Stack();
    PriorityQueue&amp;lt;ListNode&amp;gt; heap = new PriorityQueue&amp;lt;ListNode&amp;gt;((o1,o2) -&amp;gt; Integer.compare(o2.val, o1.val));
    
    // take O(logn): the depth of heap tree 
    public void push(int val) {
        ListNode newnode = new ListNode(val);
        heap.add(newnode); 
        elem.push(newnode);
    }
    
    // take O(logn): the depth of heap tree 
    public void pop() {
        ListNode remove = elem.pop();
        heap.remove(remove); 
    }
    
    // O(1) time
    public int peek() {
        return elem.peek().val;
    }

    // O(1) time
    public int peekMax() {
        return heap.peek().val; 
    }

    // take O(logn): the depth of heap tree 
    public void popMax() {
        ListNode node = heap.poll(); 
        elem.remove(node);
    }

    public static void main(String[] args) {
        MaxStack ms = new MaxStack();
        ms.push(1);
        ms.push(3);
        ms.push(2);
        System.out.println(ms.peekMax()); // == 3
        ms.popMax();
        System.out.println(ms.peekMax()); // == 2
        ms.push(4);
        ms.push(8);
        ms.pop();
        System.out.println(ms.peekMax()); // == 4
    }
}

class Stack {
    ListNode head, rear;

    public Stack() {
        head = new ListNode(0);
        rear = new ListNode(0);
        head.next = rear;
        rear.prev = head;
    }

    public void push(ListNode newnode) {
        rear.prev.next = newnode;
        newnode.prev = rear.prev;
        newnode.next = rear;
        rear.prev = newnode;
    }

    public ListNode pop() {
        if (isEmpty())
            return null;
        ListNode remove = rear.prev;
        rear.prev = remove.prev;
        remove.prev.next = rear;
        return remove;
    }

    public ListNode peek() {
        if (isEmpty())
            return null;
        ListNode peek = rear.prev;
        return peek;
    }

    public void remove(ListNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    public boolean isEmpty() {
        return head.next == rear;
    }
}

class ListNode {
    int val;
    ListNode prev, next;

    public ListNode(int val) {
        this.val = val;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Iterator for Merging Sorted Stream</title>
      <link>http://xmruibi.github.io/2015/11/15/iterator-for-merging-sorted-stream/</link>
      <pubDate>Sun, 15 Nov 2015 10:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/iterator-for-merging-sorted-stream/</guid>
      <description>

&lt;p&gt;Design a iterator, with input a list and a hop parameter. Then output the element according to that hop number. List: &lt;code&gt;1, 2, 3, 4, 5, 6, 7, 8, 9; hop = 2&lt;/code&gt; -&amp;gt; &lt;code&gt;2, ,4, 6, 8&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution:c20097de2cc12809c8a9177ae4edd63e&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HopIterator&amp;lt;E&amp;gt; implements Iterator&amp;lt;E&amp;gt; {
	int hop;
	Iterator&amp;lt;E&amp;gt; itr;

	public HopIterator(Collection&amp;lt;E&amp;gt; list, int hop) {
		this.itr = list.iterator();
		this.hop = hop;
	}

	@Override
	public boolean hasNext() {
		int k = 1;
		while (k &amp;lt; hop &amp;amp;&amp;amp; itr.hasNext()) {
			k++;
			itr.next();
		}
		return k == hop &amp;amp;&amp;amp; itr.hasNext();
	}

	@Override
	public E next() {
		return itr.next();
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Iterator for Merging Sorted Stream</title>
      <link>http://xmruibi.github.io/2015/11/15/iterator-for-merging-sorted-stream/</link>
      <pubDate>Sun, 15 Nov 2015 10:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/iterator-for-merging-sorted-stream/</guid>
      <description>

&lt;p&gt;Given a &lt;code&gt;Merge Sorted Stream&lt;/code&gt; class contains some sorted stream which implements iterator interface. Each sorted stream class has some methods: &lt;code&gt;hasNext()&lt;/code&gt;, &lt;code&gt;next()&lt;/code&gt;. Sorted Stream defines the stream read data by ascending order, so that in &lt;code&gt;Merge Sorted Stream&lt;/code&gt; when call &lt;code&gt;next()&lt;/code&gt; method, it will return values by ascending order. Pleas complete the following codes.&lt;/p&gt;

&lt;h3 id=&#34;partital-code:29d87af7cc40b904c89fba965c56caf1&#34;&gt;Partital Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class SortedStream implments Iterator&amp;lt;Integer&amp;gt;{
	List&amp;lt;Integer&amp;gt; content;
	int cursor;
	public SortedStream(List&amp;lt;Integer&amp;gt; content){
		if(content == null)
			throw new IllegalArgumentException(&amp;quot;Null Input&amp;quot;);
		this.content = content;
		this.cursor = 0;
	}

	public boolean hasNext(){return cursor &amp;lt; content.size();}

	public int next(){return content.get(cursor++);}
}

class MergeSortedStream implments Iterator&amp;lt;SortedStream&amp;gt;{
    List&amp;lt;SortedStream&amp;gt; content;
	SortedStream cursor;
	public MergeSortedStream(List&amp;lt;SortedStream&amp;gt; content){...}
	
	public boolean hasNext(){...};

	public int next(){...};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:29d87af7cc40b904c89fba965c56caf1&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Implement a new wrapper class for original iterator class and make it comparable.&lt;/li&gt;
&lt;li&gt;The new wrapper class is just like peek iterator, and implement &lt;code&gt;compareTo()&lt;/code&gt; method with comparing the peek element.&lt;/li&gt;
&lt;li&gt;Put all new iterator class in a minheap.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:29d87af7cc40b904c89fba965c56caf1&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MergeKSortedIterator implements Iterable&amp;lt;Integer&amp;gt; {

    Collection&amp;lt;Iterator&amp;lt;Integer&amp;gt;&amp;gt; listOfItr;

    public MergeKSortedIterator(Collection&amp;lt;Iterator&amp;lt;Integer&amp;gt;&amp;gt; lists) {
        this.listOfItr = lists;
    }

    @Override
    public Iterator&amp;lt;Integer&amp;gt; iterator() {
        Queue&amp;lt;NewIterator&amp;gt; minHeap = new PriorityQueue&amp;lt;NewIterator&amp;gt;(
                listOfItr.size());
        for (Iterator&amp;lt;Integer&amp;gt; it : listOfItr)
            minHeap.add(new NewIterator(it));

        return new Iterator&amp;lt;Integer&amp;gt;() {
            @Override
            public boolean hasNext() {
                return !minHeap.isEmpty();
            }

            @Override
            public Integer next() {
                NewIterator pop = minHeap.poll();
                int res = pop.next();
                if (pop.hasNext()) {
                    minHeap.add(pop);
                }
                return res;
            }

        };
    }

    class NewIterator implements Comparable&amp;lt;NewIterator&amp;gt;, Iterator&amp;lt;Integer&amp;gt; {
        Integer cur;
        Iterator&amp;lt;Integer&amp;gt; itr;

        public NewIterator(Iterator&amp;lt;Integer&amp;gt; itr) {
            this.itr = itr;
            cur = itr.hasNext() ? itr.next() : null;
        }

        @Override
        public int compareTo(NewIterator o) {
            return Integer.compare(this.peek(), o.peek());
        }

        @Override
        public boolean hasNext() {
            return cur != null;
        }

        @Override
        public Integer next() {
            int res = cur;
            cur = itr.hasNext() ? itr.next() : null;
            return res;
        }

        public Integer peek() {
            return cur;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Balanced Point in Array</title>
      <link>http://xmruibi.github.io/2015/11/14/balanced-point-in-array/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/balanced-point-in-array/</guid>
      <description>

&lt;p&gt;Balanced index of an array is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes.&lt;/p&gt;

&lt;h3 id=&#34;example:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;In an arrya A:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A[0] = -7, A[1] = 1, A[2] = 5, A[3] = 2, A[4] = -4, A[5] = 3, A[6]=0
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;3&lt;/code&gt; is an Balanced index, because: &lt;code&gt;A[0] + A[1] + A[2] = A[4] + A[5] + A[6]&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;6&lt;/code&gt; is also an Balanced index, because sum of zero elements is zero, i.e., &lt;code&gt;A[0] + A[1] + A[2] + A[3] + A[4] + A[5]=0&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;7&lt;/code&gt; is not an Balanced index, because it is not a valid index of array A.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Write a function int &lt;code&gt;balancedPoint(int[] arr)&lt;/code&gt;; that given a sequence arr[] of size n, returns an Balanced index (if any) or -1 if no Balanced indexes exist.&lt;/p&gt;

&lt;h2 id=&#34;think:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;The idea is to get total sum of array first. Then Iterate through the array and keep updating the left sum which is initialized as zero. In the loop, we can get right sum by subtracting the elements one by one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1) Initialize leftsum  as 0
2) Get the total sum of the array as sum
3) Iterate through the array and for each index i, do following.
    a)  Update sum to get the right sum.  
           sum = sum - arr[i] 
       // sum is now right sum
    b) If leftsum is equal to sum, then return current index. 
    c) leftsum = leftsum + arr[i] // update leftsum for next iteration.
4) return -1 // If we come out of loop without returning then
             // there is no equilibrium index
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	// find all balance point in an array return balanced index
	public List&amp;lt;Integer&amp;gt; findBalancedPoint(int[] arr) {
		int leftsum = 0, rightsum = 0;
		List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

		for (int i = 0; i &amp;lt; arr.length; i++) 
			leftsum += arr[i];
		
		for (int i = arr.length - 1; i&amp;gt;=0; i--) {
			leftsum -= arr[i];
			if(leftsum == rightsum)
				res.add(i);
			rightsum+=arr[i];
		}
		return -1;
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find Valid IP Address in a File</title>
      <link>http://xmruibi.github.io/2015/11/14/find-valid-ip-address-in-a-file/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/find-valid-ip-address-in-a-file/</guid>
      <description>

&lt;p&gt;Given a file with many lines of Strings, find those valid IP address from them.&lt;/p&gt;

&lt;h2 id=&#34;solution:ed817a74e0c3a1097fc0cfb76d5d85e1&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ValidIPAddress {

    public List&amp;lt;String&amp;gt; findValidIPAddr(String filePath) throws IOException {
        List&amp;lt;String&amp;gt; addresses = new ArrayList&amp;lt;&amp;gt;();
        Scanner sc = new Scanner(new File(filePath));
        while (sc.hasNext()) {
            String line = sc.next();
            if(validIP(line))
                addresses.add(line);
        }
        return addresses;
    }

    private boolean validIP(String str) {
        try {
            String[] parts = str.split(&amp;quot;.&amp;quot;);
            // check segment length;
            if (parts.length != 4 || str.endsWith(&amp;quot;.&amp;quot;))
                return false;

            // check each segment valid or not
            for (int i = 0; i &amp;lt; parts.length; i++) {
                String s = parts[i];
                int val = Integer.parseInt(s);
                if ((s.charAt(0) == &#39;0&#39;) || (val &amp;lt; 0 || val &amp;gt; 255)
                        || (i == 0 &amp;amp;&amp;amp; val == 0))
                    return false;
            }
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Isomorphic Pair</title>
      <link>http://xmruibi.github.io/2015/11/14/isomorphic-pair/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/isomorphic-pair/</guid>
      <description>

&lt;p&gt;Given two words as Strings, determine if they are isomorphic. Two words are called isomorphic if the letters in one word can be remapped to get the second word. Remapping a letter means replacing all occurrences of it with another letter while the ordering of the letters remains unchanged. No two letters may map to the same letter, but a letter may map to itself.&lt;/p&gt;

&lt;h2 id=&#34;think-1:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Two Hashmap for mapping A-B and B-A.&lt;/li&gt;
&lt;li&gt;make sure both mapping are correct if any character appear in its corresponding mapping.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public boolean isomorphicString(String str1, String str2) {
		if (str1 == null || str2 == null || str1.length() != str2.length())
			return false;
		HashMap&amp;lt;Character, Character&amp;gt; mapAB = new HashMap&amp;lt;&amp;gt;();
		HashMap&amp;lt;Character, Character&amp;gt; mapBA = new HashMap&amp;lt;&amp;gt;();
		for (int i = 0; i &amp;lt; str1.length(); i++) {
			char a = str1.charAt(i);
			char b = str2.charAt(i);
			if (!mapAB.containsKey(a) &amp;amp;&amp;amp; !mapBA.containsKey(b)) {
				mapAB.put(a, b);
				mapBA.put(b, a);
			} else {
				if (mapAB.containsKey(a) &amp;amp;&amp;amp; mapAB.get(a) != b)
					return false;
				if (mapBA.containsKey(b) &amp;amp;&amp;amp; mapBA.get(b) != a)
					return false;
			}
		}
		return true;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;One Hashmap&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public boolean isomorphicStringII(String str1, String str2) {
		if ((str1 == null &amp;amp;&amp;amp; str2 == null)
				|| (str1.length() == 0 &amp;amp;&amp;amp; str2.length() == 0)
				|| str1.equals(str2))
			return true;
		if (str1 == null || str2 == null || str1.length() != str2.length())
			return false;
		HashMap&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
		int i = 0;
		while (i &amp;lt; str1.length()) {
			char a = str1.charAt(i);
			char b = str2.charAt(i);
			if (map.containsKey(a)) {
				if (map.get(a) != b)
					return false;
			} else {
				if (map.containsValue(b))
					return false;
				map.put(a, b);
			}
			i++;
		}
		return true;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-3:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Think #3&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Integer Array with 512 length&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-3:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Solution #3&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public boolean isIsomorphic(String s1, String s2) {
        int[] m = new int[512];
        for (int i = 0; i &amp;lt; s1.length(); i++) {
            if (m[s1.charAt(i)] != m[s2.charAt(i)+256]) 
                return false;
            m[s1.charAt(i)] = m[s2.charAt(i)+256] = i+1;
        }
        return true;	
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Maximum Subarray of Sum / Product</title>
      <link>http://xmruibi.github.io/2015/11/14/maximum-subarray-of-sum-/-product/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/maximum-subarray-of-sum-/-product/</guid>
      <description>

&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest sum.&lt;/p&gt;

&lt;p&gt;For example, given the array &lt;code&gt;[−2,1,−3,4,−1,2,1,−5,4]&lt;/code&gt;,
the contiguous subarray &lt;code&gt;[4,−1,2,1]&lt;/code&gt; has the largest sum = &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int maxSubArray(int[] arr) {
        int maxSum = Integer.MIN_VALUE;
		int curSum = 0;
		for (int i = 0; i &amp;lt; arr.length; i++) {
			curSum += arr[i];
			maxSum = Math.max(maxSum, curSum);
			if (curSum &amp;lt; 0)
				curSum = 0;
		}
		return maxSum;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-record-index:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution #Record Index&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int[] maxSubArray(int[] arr) {
        int maxSum = Integer.MIN_VALUE;
		int curSum = 0;
		int prev = 0, l = 0, r = 0;
		for (int i = 0; i &amp;lt; arr.length; i++) {
			curSum += arr[i];
			if(curSum &amp;gt; maxSum) {
				maxSum = curSum;
				l = prev;
				r = i;
			}
			if (curSum &amp;lt; 0) {
				curSum = 0;
				prev = i + 1;
			}
		}
		return new int[]{l, r};
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest product.&lt;/p&gt;

&lt;p&gt;For example, given the array &lt;code&gt;[2,3,-2,4]&lt;/code&gt;,
the contiguous subarray &lt;code&gt;[2,3]&lt;/code&gt; has the largest product = &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution-1:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int maxProduct(int[] nums) {
        int glMax = Integer.MIN_VALUE;
        
        int localMin = 1; // record the current max
        int localMax = 1; // record the current min, since the negative number multiply with current number may leads to next product as the positive max
        for(int i = 0; i &amp;lt; nums.length; i++) {
            int tmp = localMax;
            localMax = Math.max(localMax*nums[i], Math.max(localMin*nums[i], nums[i]));
            localMin = Math.min(tmp*nums[i], Math.min(localMin*nums[i], nums[i]));
            glMax = Math.max(glMax, localMax);
        }
        
        return glMax;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Minimum Window Substring</title>
      <link>http://xmruibi.github.io/2015/11/14/minimum-window-substring/</link>
      <pubDate>Sat, 14 Nov 2015 22:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/minimum-window-substring/</guid>
      <description>

&lt;p&gt;Given a string source and a string target, find the minimum window in source which will contain all the characters in target.&lt;/p&gt;

&lt;h3 id=&#34;example:550cea2e147a44ca0938087e5ad57f43&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;source = &amp;ldquo;ADOBECODEBANC&amp;rdquo; target = &amp;ldquo;ABC&amp;rdquo; Minimum window is &amp;ldquo;BANC&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;note:550cea2e147a44ca0938087e5ad57f43&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;If there is no such window in source that covers all characters in target, return the emtpy string &amp;ldquo;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in source.&lt;/p&gt;

&lt;h3 id=&#34;challenge:550cea2e147a44ca0938087e5ad57f43&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Can you do it in time complexity O(n) ?&lt;/p&gt;

&lt;h3 id=&#34;clarification:550cea2e147a44ca0938087e5ad57f43&#34;&gt;Clarification&lt;/h3&gt;

&lt;p&gt;The characters in minimum window doesn&amp;rsquo;t need to has the same order in target.&lt;/p&gt;

&lt;h2 id=&#34;solution:550cea2e147a44ca0938087e5ad57f43&#34;&gt;Solution:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public String minWindow(String s, String t) {
        // preload for target checking
        if(s == null || s.length() == 0 || t == null || t.length() == 0)
            return &amp;quot;&amp;quot;;
        
        
        // store t into a hashmap &amp;lt;char, freq&amp;gt;
        HashMap&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(char c : t.toCharArray())
            map.put(c, map.containsKey(c)?map.get(c) + 1 : 1);
        // set curidx-i, leftbound-prev, hitcharCnt-hitCnt, default max length-len
        int prev = 0, hitCnt = 0, len = s.length();
        String res = &amp;quot;&amp;quot;;
        
        for(int i = 0; i&amp;lt;s.length();i++){
            char cur = s.charAt(i);
            // skip nonhit char
            if(!map.containsKey(cur))
                continue;
            map.put(cur, map.get(cur) - 1);
            if(map.get(cur) &amp;gt;= 0)
                hitCnt++;
                
            while(hitCnt == t.length()) {
                if(i - prev + 1 &amp;lt;= len) {
                    res = s.substring(prev, i+1);
                    len = i - prev + 1;
                }
                if(map.containsKey(s.charAt(prev))) {
                   map.put(s.charAt(prev), map.get(s.charAt(prev))+1);
                   if(map.get(s.charAt(prev)) &amp;gt; 0)
                      hitCnt--;
                }
                prev++;
            }
        }
        return res;
    }

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Binary Tree Upside Down</title>
      <link>http://xmruibi.github.io/2015/11/14/binary-tree-upside-down/</link>
      <pubDate>Sat, 14 Nov 2015 15:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/binary-tree-upside-down/</guid>
      <description>

&lt;p&gt;Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.&lt;/p&gt;

&lt;h3 id=&#34;example:33643332a2ae687d0e663b807ba8b06f&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given a binary tree &lt;code&gt;{1,2,3,4,5}&lt;/code&gt;,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     1
    / \
   2   3
  / \
 4   5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return the root of the binary tree &lt;code&gt;[4,5,2,#,#,3,1]&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     4
    / \
   5   2
      / \
     3   1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:33643332a2ae687d0e663b807ba8b06f&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Mark the parent node &lt;code&gt;parent&lt;/code&gt; from next right node position.&lt;/li&gt;
&lt;li&gt;Mark the current right child &lt;code&gt;node.right&lt;/code&gt; from next left &lt;code&gt;left&lt;/code&gt; node position&lt;/li&gt;
&lt;li&gt;Mark the next iteration node &lt;code&gt;next&lt;/code&gt; by current left child &lt;code&gt;node.left&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Replace the current node&amp;rsquo;s left child as the recorded &lt;code&gt;right&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Replace the current node&amp;rsquo;s right child as the recorded &lt;code&gt;parent&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Replace current iteration node by &lt;code&gt;next&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-iterative:33643332a2ae687d0e663b807ba8b06f&#34;&gt;Solution #Iterative&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public TreeNode UpsideDownBinaryTree(TreeNode node) {  
        TreeNode parent = null, right = null;
		while(node != null) {
			TreeNode next = node.left;
			node.left = right;						
			right = node.right;
			node.right = parent;
			parent = node;
			node = next;
		}
		return parent;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-recursive:33643332a2ae687d0e663b807ba8b06f&#34;&gt;Solution #Recursive&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static TreeNode upsideDown(TreeNode node) {
        if(node == null)
            return node;
        TreeNode root = node, left = node.left, right = node.right;
        if(left != null) {
            TreeNode newroot = upsideDown(node.left);
            left.left = right;
            left.right = root;
            return newroot;
        }
        return node;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Course Schedule I/II</title>
      <link>http://xmruibi.github.io/2015/11/14/course-schedule-i/ii/</link>
      <pubDate>Sat, 14 Nov 2015 13:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/course-schedule-i/ii/</guid>
      <description>

&lt;h2 id=&#34;problem-i:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Problem I&lt;/h2&gt;

&lt;p&gt;There are a total of n courses you have to take, labeled from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n - 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: &lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2, [[1,0]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2, [[1,0],[0,1]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.&lt;/p&gt;

&lt;h3 id=&#34;solution-topological-sort:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Solution #Topological Sort&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        HashMap&amp;lt;Integer, Course&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(int[] pair : prerequisites) {
            int pre = pair[1];
            int cur = pair[0];
            if(!map.containsKey(pre))
                map.put(pre, new Course(pre));
            if(!map.containsKey(cur))
                map.put(cur, new Course(cur));
            map.get(pre).nexts.add(map.get(cur));
            map.get(cur).preq++;
        }
        Queue&amp;lt;Course&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
        for(Course c : map.values()) {
            if(c.preq == 0)
                queue.offer(c);
        }
        
        while(!queue.isEmpty()) {
            Course cur = queue.poll();
            map.remove(cur.idx);
            for(Course next : cur.nexts) {
                next.preq--;
                if(next.preq == 0)
                    queue.offer(next);
            }
        }
        return map.size() == 0;
    }
}
class Course{
    int idx;
    int preq;
    ArrayList&amp;lt;Course&amp;gt; nexts;
    public Course(int index) {
        this.idx = index;
        this.preq = 0;
        this.nexts = new ArrayList&amp;lt;&amp;gt;();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.&lt;/p&gt;

&lt;p&gt;There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.&lt;/p&gt;

&lt;h4 id=&#34;example:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;2, [[1,0]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a total of 2 courses to take. To take course &lt;code&gt;1&lt;/code&gt; you should have finished course &lt;code&gt;0&lt;/code&gt;. So the correct course order is &lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;4, [[1,0],[2,0],[3,1],[3,2]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a total of 4 courses to take. To take course &lt;code&gt;3&lt;/code&gt; you should have finished both courses &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;. Both courses &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; should be taken after you finished course 0. So one correct course order is &lt;code&gt;[0,1,2,3]&lt;/code&gt;. Another correct ordering is &lt;code&gt;[0,2,1,3]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;solution-topological-sort-1:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Solution #Topological Sort&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        if(prerequisites == null || prerequisites.length == 0)
            return new int[0];
            
        HashMap&amp;lt;Integer, Course&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(int[] pair : prerequisites) {
            int pre = pair[1];
            int cur = pair[0];
            if(!map.containsKey(pre))
                map.put(pre, new Course(pre));
            if(!map.containsKey(cur))
                map.put(cur, new Course(cur));
            map.get(pre).nexts.add(map.get(cur));
            map.get(cur).preq++;
        }
        Queue&amp;lt;Course&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
        for(Course c : map.values()) {
            if(c.preq == 0)
                queue.offer(c);
        }
        int[] res = new int[numCourses];
        int index = 0;
        while(!queue.isEmpty()) {
            Course cur = queue.poll();
            res[index++] = cur.idx;
            map.remove(cur.idx);
            for(Course next : cur.nexts) {
                next.preq--;
                if(next.preq == 0)
                    queue.offer(next);
            }
        }
        return map.size() == 0 ? res : new int[0];
    }
}
class Course{
    int idx;
    int preq;
    ArrayList&amp;lt;Course&amp;gt; nexts;
    public Course(int index) {
        this.idx = index;
        this.preq = 0;
        this.nexts = new ArrayList&amp;lt;&amp;gt;();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>