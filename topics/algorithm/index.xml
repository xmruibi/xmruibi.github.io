<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/topics/algorithm/</link>
    <description>Recent content in Algorithm on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Sat, 24 Oct 2015 16:13:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/topics/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Binary Representation</title>
      <link>http://xmruibi.github.io/2015/10/24/binary-representation/</link>
      <pubDate>Sat, 24 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/24/binary-representation/</guid>
      <description>

&lt;p&gt;Given a (decimal - e.g. 3.72) number that is passed in as a string, return the binary representation that is passed in as a string. If the fractional part of the number can not be represented accurately in binary with at most 32 characters, return &lt;code&gt;ERROR&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For n = &lt;code&gt;&amp;quot;3.72&amp;quot;&lt;/code&gt;, return &lt;code&gt;&amp;quot;ERROR&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For n = &lt;code&gt;&amp;quot;3.5&amp;quot;&lt;/code&gt;, return &lt;code&gt;&amp;quot;11.1&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;For Integer part, we use &lt;code&gt;% 2&lt;/code&gt; to get each digit from lowest bit to highest bit, or use a loop to make &lt;code&gt;&amp;amp;&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; and left shift until it get zero.&lt;/li&gt;
&lt;li&gt;For decimal part, we can use $$\times2$$ approach. For example: &lt;code&gt;int n = 0.75; n*2 = 1.5;&lt;/code&gt; Therefore, the first digit of binary number after &lt;code&gt;.&lt;/code&gt; is 1 (i.e. 0.1).  After constructed the first digit, n= n*2-1;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
    * Therefore, the first digit of binary number after &#39;.&#39; is 1 (i.e. 0.1).  After constructed the first digit, n= n*2-1 
     *@param n: Given a decimal number that is passed in as a string
     *@return: A string
     */
    public String binaryRepresentation(String n) {
        int intPart = Integer.parseInt(n.substring(0, n.indexOf(&#39;.&#39;)));
        StringBuilder res = new StringBuilder();
        while(intPart != 0) {
            res.insert(0, &amp;quot;&amp;quot; + (intPart &amp;amp; 1));
            intPart &amp;gt;&amp;gt;= 1;
        }
        if(res.length() == 0)
            res.append(0);
        double decPart = Double.parseDouble(n.substring(n.indexOf(&#39;.&#39;)));
        String decBit = &amp;quot;&amp;quot;;
        // if it has decimal part, creat &#39;.&#39; in result string
        if(decPart &amp;gt; 0.0)
            res.append(&amp;quot;.&amp;quot;);
        // to count how many digit in decimal binary result
        int cnt = 0;
        while(decPart &amp;gt; 0.0) {
            double cur = (decPart * 2);
            cnt++;
            if(cnt &amp;gt; 32)
                return &amp;quot;ERROR&amp;quot;;
            if(cur &amp;gt;= 1) {
                res.append(1);
                decPart = cur - 1.0;
            }else {
                res.append(0);
                decPart = cur;
            }
        }
        
        return res.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sqrt(x)</title>
      <link>http://xmruibi.github.io/2015/10/24/sqrtx/</link>
      <pubDate>Sat, 24 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/24/sqrtx/</guid>
      <description>

&lt;p&gt;Implement &lt;code&gt;int sqrt(int x)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Compute and return the square root of &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;Try to make the time complexity less.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The square root should be between 1 to half of input value;&lt;/li&gt;
&lt;li&gt;Use binary search idea to search the &lt;code&gt;sqrt&lt;/code&gt; inside that range;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public int mySqrt(int x) {
        if(x == 0)
            return 0;
        // binary search from 1 -&amp;gt; x/2
        int l = 1, r = (x&amp;gt;&amp;gt;1);
        while(l &amp;lt; r) {
            int m = l + ((r - l) &amp;gt;&amp;gt; 1);
            if( m &amp;lt;= x / m &amp;amp;&amp;amp; (m + 1) &amp;gt; x / (m + 1)) {
                return m;
            }else if(m + 1 &amp;lt;= x / m) {
                l = m + 1;
            }else{
                r = m;
            }
        }
        return l;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Count of Smaller Number before itself</title>
      <link>http://xmruibi.github.io/2015/10/22/count-of-smaller-number-before-itself/</link>
      <pubDate>Thu, 22 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/22/count-of-smaller-number-before-itself/</guid>
      <description>

&lt;p&gt;Give you an integer array (index from 0 to n-1, where n is the size of this array, value from 0 to 10000) . For each element Ai in the array, count the number of element before this element Ai is smaller than it and return count number array.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For array &lt;code&gt;[1,2,7,8,5]&lt;/code&gt;, return &lt;code&gt;[0,1,2,3,2]&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Segment Tree&lt;/li&gt;
&lt;li&gt;Initial with the range (0 to 10000)&lt;/li&gt;
&lt;li&gt;Count array elements included in a certain tree node&lt;/li&gt;
&lt;li&gt;Dynamic count and make a query.

&lt;ul&gt;
&lt;li&gt;Query a value, evaluate the value and node&amp;rsquo;s middle value,&lt;/li&gt;
&lt;li&gt;if larger, that means the left node&amp;rsquo;s count should be included and also enter into the right node;&lt;/li&gt;
&lt;li&gt;if less, just enter the left node;&lt;/li&gt;
&lt;li&gt;recursive until touch the null node;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class SegmentTree{
    Node root;
        
    public SegmentTree(){
        root = build(0, 20000);
    }
        
    public Node build(int left, int right) {
        if(right &amp;lt; left)
            return null;
        if(left == right)
            return new Node(left, right);
        
        int m = left + ((right - left)&amp;gt;&amp;gt;1);
        Node cur = new Node(left, right);
        cur.leftNode = build(left, m);
        cur.rightNode = build(m+1, right);
        return cur;
    }
    
    public void count(int val){
        count(root, val);
    }
    
    private void count(Node node, int val) {
        if(node == null)
            return;
        int m = node.left + ((node.right - node.left)&amp;gt;&amp;gt;1);
        node.cnt++;
        if(val &amp;gt; m)
            count(node.rightNode, val);
        else
            count(node.leftNode, val);
    }
    
    public int query(int val){
        return query(root, val);
    }
    
    private int query(Node node, int val) {
        int cnt = 0;
        if(node == null)
            return cnt;
        int m = node.left + ((node.right - node.left)&amp;gt;&amp;gt;1);
        cnt += (node.leftNode != null ? node.leftNode.cnt : 0);
        if(val &amp;gt; m) // if larger: 
            return cnt + query(node.rightNode, val);
        else // if less or equal: includes val == m
            return query(node.leftNode, val);
    }
    
}

class Node{
    int left, right;
    long cnt;
    Node leftNode, rightNode;
    public Node(int left, int right){
        this.cnt = 0;
        this.left = left;
        this.right = right;
    }
}


public class Solution {
   /**
     * @param A: An integer array
     * @return: Count the number of element before this element &#39;ai&#39; is 
     *          smaller than it and return count number array
     */ 
    SegmentTree tree;
    public ArrayList&amp;lt;Integer&amp;gt; countOfSmallerNumberII(int[] A) {
        tree = new SegmentTree();
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        for(int i = 0; i &amp;lt; A.length; i++) {
            tree.count(A[i]);
            res.add(tree.query(A[i]));
        }
        return res;
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>k Sum II</title>
      <link>http://xmruibi.github.io/2015/10/22/k-sum-ii/</link>
      <pubDate>Thu, 22 Oct 2015 15:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/22/k-sum-ii/</guid>
      <description>

&lt;p&gt;Given n unique integers, number k (1&amp;lt;=k&amp;lt;=n)  and target. Find all possible k integers where their sum is target.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given [1,2,3,4], k=2, target=5, [1,4] and [2,3] are possible solutions.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;Unlike the k Sum I, here we need to get the each solution which can achieve the &lt;code&gt;target&lt;/code&gt; within &lt;code&gt;k&lt;/code&gt; num. Since the solution should be shown in the result, the dynamic programming cannot be used. Thus, the backtracking should be the only way.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param A: an integer array.
     * @param k: a positive integer (k &amp;lt;= length(A))
     * @param target: a integer
     * @return a list of lists of integer 
     */ 
    public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; kSumII(int A[], int k, int target) {
        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        helper(res, new ArrayList&amp;lt;Integer&amp;gt;(), A , k, target, 0);
        return res;
    }
    
    private void helper(ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; res, ArrayList&amp;lt;Integer&amp;gt; cur, int[] A, int k, int target, int idx) {
        if(target &amp;lt; 0 || k &amp;lt; 0)
            return;
            
        if(target == 0 &amp;amp;&amp;amp; k == 0) {
            res.add(new ArrayList&amp;lt;&amp;gt;(cur));
            return;
        }
        
        for(int i = idx; i &amp;lt; A.length; i++) {
            cur.add(A[i]);
            helper(res, cur, A, k - 1, target - A[i], i + 1);
            cur.remove(cur.size() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Triangle Count</title>
      <link>http://xmruibi.github.io/2015/10/22/triangle-count/</link>
      <pubDate>Thu, 22 Oct 2015 14:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/22/triangle-count/</guid>
      <description>

&lt;p&gt;Given an array of integers, how many three numbers can be found in the array, so that we can build an triangle whose three edges length is the three numbers that we find?&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given array S = [3,4,6,7], return 3. They are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[3,4,6]
[3,6,7]
[4,6,7]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given array S = [4,4,4,4], return 4. They are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[4(1),4(2),4(3)]
[4(1),4(2),4(4)]
[4(1),4(3),4(4)]
[4(2),4(3),4(4)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Sort&lt;/li&gt;
&lt;li&gt;Binary Search&lt;/li&gt;
&lt;li&gt;But how to define driven condition? (Tricky Part)

&lt;ul&gt;
&lt;li&gt;As we know, triangle is made by &lt;code&gt;i + j &amp;gt; k&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;So we capture the largest one&lt;code&gt;[k]&lt;/code&gt; (passing from &lt;code&gt;length - 1&lt;/code&gt; to &lt;code&gt;2&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Get &lt;code&gt;left = 0&lt;/code&gt; and &lt;code&gt;right = k - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;[left] + [right] &amp;gt; [k]&lt;/code&gt;, that means in the segment, &lt;code&gt;[left]&lt;/code&gt; can be valued between &lt;code&gt;[left]&lt;/code&gt; and &lt;code&gt;[right-1]&lt;/code&gt;, all of that can make valid triangle. So &lt;code&gt;count += right - left&lt;/code&gt;!&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;[left] + [right] &amp;lt;= [k]&lt;/code&gt;, just make the &lt;code&gt;left&lt;/code&gt; increase to detect any valid possibility.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param S: A list of integers
     * @return: An integer
     */
    public int triangleCount(int S[]) {
        if(S == null || S.length == 0)
            return 0;
        int cnt = 0;
        Arrays.sort(S);
        for(int i = S.length - 1; i &amp;gt;= 2; i--) {
            int cur = S[i];
            int l = 0, r = i - 1;
            while(l &amp;lt; r) {
                if(S[l] + S[r] &amp;gt; S[i]) {
                    cnt += (r - l); // keypoint!
                    r--;
                }else 
                    l++;
            }
        }
        return cnt;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Update Bits</title>
      <link>http://xmruibi.github.io/2015/10/22/update-bits/</link>
      <pubDate>Thu, 22 Oct 2015 14:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/22/update-bits/</guid>
      <description>

&lt;p&gt;Given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method to set all bits between i and j in N equal to M (e g , M becomes a substring of N located at i and starting at j).&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given N=&lt;code&gt;(10000000000)2&lt;/code&gt;, M=&lt;code&gt;(10101)2&lt;/code&gt;, i=&lt;code&gt;2&lt;/code&gt;, j=&lt;code&gt;6&lt;/code&gt;
return N=&lt;code&gt;(10001010100)2&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;In the function, the numbers N and M will given in decimal, you should also return a decimal number.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Minimum number of operations?&lt;/p&gt;

&lt;h3 id=&#34;clarification&#34;&gt;Clarification&lt;/h3&gt;

&lt;p&gt;You can assume that the bits j through i have enough space to fit all of M. That is, if M = &lt;code&gt;10011&lt;/code&gt;, you can assume that there are at least 5 bits between j and i. You would not, for example, have j=3 and i=2, because M could not fully fit between bit 3 and bit 2.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Set a mask:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Position:   31 30 ..~.. j+1  j ..~.. i  i-1 ..~.. 0
Bit Val:     1  1  ...   1   0  ...  0   1   ...  1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use that mask to do &lt;code&gt;&amp;amp;&lt;/code&gt; with N, so that in the new N, the position i~j will be zero.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Left shift &lt;code&gt;i&lt;/code&gt; for M to make the position aligned.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Do &lt;code&gt;|&lt;/code&gt; for M and N, then get the final result.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    /**
     *@param n, m: Two integer
     *@param i, j: Two bit positions
     *return: An integer
     */
    public int updateBits(int n, int m, int i, int j) {
        
        int mask = 0;
        for(int lfShift = 31; lfShift &amp;gt; j; lfShift--) 
            mask += (1&amp;lt;&amp;lt;lfShift);
        
        for(int lfShift = i - 1; lfShift &amp;gt;= 0; lfShift--) 
            mask += (1&amp;lt;&amp;lt;lfShift);
        n &amp;amp;= mask;
        m &amp;lt;&amp;lt;= i;
        return n|m;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Interleaving String</title>
      <link>http://xmruibi.github.io/2015/10/20/interleaving-string/</link>
      <pubDate>Tue, 20 Oct 2015 19:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/interleaving-string/</guid>
      <description>

&lt;p&gt;Given three strings: s1, s2, s3, determine whether s3 is formed by the interleaving of s1 and s2.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For s1 = &lt;code&gt;&amp;quot;aabcc&amp;quot;&lt;/code&gt;, s2 = &lt;code&gt;&amp;quot;dbbca&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When s3 = &lt;code&gt;&amp;quot;aadbbcbcac&amp;quot;&lt;/code&gt;, return true.
When s3 = &lt;code&gt;&amp;quot;aadbbbaccc&amp;quot;&lt;/code&gt;, return false.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n2) time or better&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Typical dynamic programming with subsequence problem.&lt;/li&gt;
&lt;li&gt;Set up a 2-D dp boolean table to memorized:

&lt;ul&gt;
&lt;li&gt;Initial: memo[0][0] = true;&lt;/li&gt;
&lt;li&gt;two conditions: s1 find matched or s2 find matched;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memo[i][j] = ( i &amp;gt; 0 &amp;amp;&amp;amp; s1.charAt(i - 1) == s3.charAt(i + j - 1) &amp;amp;&amp;amp; memo[i - 1][j]) || (s2.charAt(j - 1) == s3.charAt(i + j - 1) &amp;amp;&amp;amp; memo[i][j - 1])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * Determine whether s3 is formed by interleaving of s1 and s2.
     * @param s1, s2, s3: As description.
     * @return: true or false.
     */
    public boolean isInterleave(String s1, String s2, String s3) {

        if(s1 == null || s2 == null)
            return false;
        if(s1.length() + s2.length() != s3.length())
            return false;
            
        boolean[][] memo = new boolean[s1.length() + 1][s2.length() + 1];
        for(int i = 0; i &amp;lt;= s1.length(); i++) {
            for(int j = 0; j &amp;lt;= s2.length(); j++) {
                if(i == 0 &amp;amp;&amp;amp; j == 0)
                    memo[i][j] = true;
                else{
                    if(i &amp;gt; 0 &amp;amp;&amp;amp; s1.charAt(i - 1) == s3.charAt(i + j - 1))
                        memo[i][j] = memo[i - 1][j];
                    if(j &amp;gt; 0 &amp;amp;&amp;amp;s2.charAt(j - 1) == s3.charAt(i + j - 1))
                        memo[i][j] |= memo[i][j - 1];
                }
            }
        }
        
        return memo[s1.length()][s2.length()];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Binary Search Tree Iterator</title>
      <link>http://xmruibi.github.io/2015/10/20/binary-search-tree-iterator/</link>
      <pubDate>Tue, 20 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/binary-search-tree-iterator/</guid>
      <description>

&lt;p&gt;Design an iterator over a binary search tree with the following rules:&lt;/p&gt;

&lt;p&gt;Elements are visited in ascending order (i.e. an in-order traversal)
next() and hasNext() queries run in O(1) time in average.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For the following binary search tree, in-order traversal by using iterator is [1, 6, 10, 11, 12]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   10
 /    \
1      11
 \       \
  6       12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###Challenge
Extra memory usage O(h), h is the height of the tree.&lt;/p&gt;

&lt;p&gt;Super Star: Extra memory usage O(1)&lt;/p&gt;

&lt;h2 id=&#34;think-1&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Stack: Preorder&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    // O(height of tree) space to store current left branch nodes
    Stack&amp;lt;TreeNode&amp;gt; stack;

    //@param root: The root of binary tree.
    public Solution(TreeNode root) {

        stack = new Stack&amp;lt;&amp;gt;();
        if(root == null)
            return;
        stack.push(root);
        TreeNode left = root.left;
        while(left != null) {
            stack.push(left);
            left = left.left;
        }
    }

    //@return: True if there has next node, or false
    public boolean hasNext() {
        return !stack.isEmpty();
    }
    
    //@return: return next node
    public TreeNode next() {
        TreeNode pop = stack.pop();

        // each time pop a node, push left branch nodes for current pop node&#39;s right child
        TreeNode left = pop.right;
        while(left != null) {
            stack.push(left);
            left = left.left;
        }
        return pop;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find the Weak Connected Component in the Directed Graph</title>
      <link>http://xmruibi.github.io/2015/10/20/find-the-weak-connected-component-in-the-directed-graph/</link>
      <pubDate>Tue, 20 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/find-the-weak-connected-component-in-the-directed-graph/</guid>
      <description>

&lt;p&gt;Find the number Weak Connected Component in the directed graph. Each node in the graph contains a label and a list of its neighbors. (a connected set of a directed graph is a subgraph in which any two vertices are connected by direct edge path.)&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given graph:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A-----&amp;gt;B  C
 \     |  | 
  \    |  |
   \   |  |
    \  v  v
     -&amp;gt;D  E &amp;lt;- F
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Return &lt;code&gt;{A,B,D}&lt;/code&gt;, &lt;code&gt;{C,E,F}&lt;/code&gt;. Since there are two connected component which are &lt;code&gt;{A,B,D}&lt;/code&gt; and &lt;code&gt;{C,E,F}&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;Sort the element in the set in increasing order&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Union Find&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class UnionFind{
	// child - parent pair table:
	HashMap&amp;lt;Integer, Integer&amp;gt; pairTab;

	public UnionFind(HashSet&amp;lt;Integer&amp;gt; set) {
		pairTab = new HashMap&amp;lt;&amp;gt;();
		for(Integer i : set) 
			pairTab.put(i, i);
	}

	public int find(int x) {
		int parent = pairTab.get(x);
		while(parent != pairTab.get(parent)){
			parent = pairTab.get(parent);
		}
		return parent;
	}

	public void union(int x, int y) {
		int parent_x = find(x);
		int parent_y = find(y);
		if(parent_x != parent_y)
			pairTab.put(parent_x, parent_y);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nodes a array of Directed graph node
     * @return a connected set of a directed graph
     */
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; connectedSet2(ArrayList&amp;lt;DirectedGraphNode&amp;gt; nodes) {
        
        HashSet&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        for(DirectedGraphNode node : nodes) 
            set.add(node.label);
        
        // to make union
        UnionFind uf = new UnionFind(set);
        for(DirectedGraphNode x : nodes) {
            for(DirectedGraphNode y : x.neighbors) {
                uf.union(x.label, y.label);
            }
        }
        
        HashMap&amp;lt;Integer, ArrayList&amp;lt;Integer&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(Integer label : set) {
            int parent = uf.find(label);
            if(!map.containsKey(parent)) 
                map.put(parent, new ArrayList&amp;lt;Integer&amp;gt;());
            ArrayList&amp;lt;Integer&amp;gt; cur = map.get(parent);
            cur.add(label);
            map.put(parent, cur);
        }
        
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        for(Map.Entry&amp;lt;Integer, ArrayList&amp;lt;Integer&amp;gt;&amp;gt; entry : map.entrySet()) {
            Collections.sort(entry.getValue());
            res.add(entry.getValue());
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Digit Counts</title>
      <link>http://xmruibi.github.io/2015/10/20/digit-counts/</link>
      <pubDate>Tue, 20 Oct 2015 10:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/digit-counts/</guid>
      <description>

&lt;p&gt;Count the number of k&amp;rsquo;s between 0 and n. k can be 0 - 9.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;if n=12, k=1 in &lt;code&gt;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]&lt;/code&gt;, we have &lt;code&gt;FIVE&lt;/code&gt; 1&amp;rsquo;s &lt;code&gt;(1, 10, 11, 12)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think-1&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Brute Force: Check each digit in number form (0 -&amp;gt; n) then get the count;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public int digitCounts(int k, int n) {
        int[] record = new int[10];
        Arrays.fill(record,0);
        for (int i=0;i&amp;lt;=n;i++){
            String temp = Integer.toString(i);
            for (int j=0;j &amp;lt; temp.length();j++){
                int ind = (int) (temp.charAt(j)-&#39;0&#39;);
                record[ind]++;
            }
        }
        return record[k];            
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Math:

&lt;ul&gt;
&lt;li&gt;When current digit less than &lt;code&gt;k&lt;/code&gt;, the current count should be &lt;code&gt;higher digits x digit position&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;When current digit equal to &lt;code&gt;k&lt;/code&gt;, the current count should be &lt;code&gt;higher digits x digit position + lower digits + 1&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;When current digit larger than &lt;code&gt;k&lt;/code&gt;, the current count should be &lt;code&gt;higher digits + 1(itself) x digit position&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;When &lt;code&gt;k&lt;/code&gt; == 0 and the current digit larger than &lt;code&gt;k&lt;/code&gt;, the higher digits x digit position and it need to add one in the last result;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /*
     * param k : As description.
     * param n : As description.
     * return: An integer denote the count of digit k in 1..n
     */
    public int digitCounts(int k, int n) {
        int digit = 1;
        int cnt = 0;
        while(digit &amp;lt;= n) {
            int low = n % digit; // lower digits;
            int high = n / (digit*10); // higher digits;
            int cur = n / digit % 10;
            if(cur == k) {
                // higher digits * digit + lower digits + 1;
                cnt += ((high * digit) + low + 1);
            }else if(cur &amp;lt; k) {
                // higher digits * digit
                cnt += (high * digit);
            }else{
                // (higher digits + 1: itself) * digit
                cnt += ((high + (k == 0?0:1)) * digit);   
            }
            digit *= 10;
        }
        
        return cnt + (k == 0 ? 1 : 0);
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Divide Two Integers</title>
      <link>http://xmruibi.github.io/2015/10/20/divide-two-integers/</link>
      <pubDate>Tue, 20 Oct 2015 10:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/divide-two-integers/</guid>
      <description>

&lt;p&gt;Divide two integers without using multiplication, division and mod operator.&lt;/p&gt;

&lt;p&gt;If it is overflow, return &lt;code&gt;2147483647&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given dividend = &lt;code&gt;100&lt;/code&gt; and divisor = &lt;code&gt;9&lt;/code&gt;, return &lt;code&gt;11&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Bitwise Idea:

&lt;ul&gt;
&lt;li&gt;Get the result sign (negative or positive) by &lt;code&gt;((dividend ^ divisor) &amp;gt;&amp;gt;&amp;gt; 31) == 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;This question contains many corner cases!&lt;/li&gt;
&lt;li&gt;Firstly, check the corner cases in following steps:

&lt;ul&gt;
&lt;li&gt;Divisor is zero? return &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Dividend is &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;?

&lt;ul&gt;
&lt;li&gt;if divisor is negative one? you cannot get the positive &lt;code&gt;MIN_VALUE&lt;/code&gt; so return &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dividend += Math.abs(divisor)&lt;/code&gt; so that the dividend become away from overflow but that leads the res increase one;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Divisor is &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;? return res; To avoid the inaccurate from above operation;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Make dividend and divisor both positive;&lt;/li&gt;
&lt;li&gt;Then, the main operation to do the binary substraction;

&lt;ul&gt;
&lt;li&gt;Get the most higher position(&lt;code&gt;digit&lt;/code&gt;) for bit one with increasing the divisor until it is just larger than (&lt;code&gt;dividend &amp;gt;&amp;gt; 1&lt;/code&gt;): divisor cannot larger than dividend so that we use the &lt;code&gt;dividend&amp;gt;&amp;gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Get result by add the &lt;code&gt;1&amp;lt;&amp;lt;digit&lt;/code&gt; (current bit position should be one) and &lt;code&gt;dividend -= divisor&lt;/code&gt; but if divisor larger than dividend which means current bit position should be zero so just reduce digit and divisor should shift right one position each time;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param dividend the dividend
     * @param divisor the divisor
     * @return the result
     */
    public int divide(int dividend, int divisor) {
        int res = 0;
        if(divisor == 0)
            return Integer.MAX_VALUE;
        boolean neg = ((dividend ^ divisor) &amp;gt;&amp;gt;&amp;gt; 31) == 1;  
        if(dividend == Integer.MIN_VALUE) {
            // since the dividend is negative number now so we plus the abs(divisor)
            dividend += Math.abs(divisor);
            if(divisor == -1)
                return Integer.MAX_VALUE;
            res++;
        }
        
        if(divisor == Integer.MIN_VALUE)
            return res;
        
        // the highest position for bit in result   
        int digit = 0;
        dividend = Math.abs(dividend);  
        divisor = Math.abs(divisor);
        while(divisor &amp;lt;= (dividend&amp;gt;&amp;gt;1)) {
            divisor &amp;lt;&amp;lt;= 1;
            digit ++;
        }
        
        while(digit&amp;gt;=0){
            if(dividend&amp;gt;=divisor){
                res += (1&amp;lt;&amp;lt;digit);
                dividend-=divisor;
            }
            divisor&amp;gt;&amp;gt;=1;
            digit--;
        }
        return neg?-res:res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Number of Airplanes in the Sky</title>
      <link>http://xmruibi.github.io/2015/10/19/number-of-airplanes-in-the-sky/</link>
      <pubDate>Mon, 19 Oct 2015 22:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/number-of-airplanes-in-the-sky/</guid>
      <description>

&lt;p&gt;Given an interval list which are flying and landing time of the flight. How many airplanes are on the sky at most?&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For interval list &lt;code&gt;[[1,10],[2,3],[5,8],[4,7]]&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;If landing and flying happens at the same time, we consider landing should happen at first.&lt;/p&gt;

&lt;h2 id=&#34;think-1&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Array Method (Naive):

&lt;ul&gt;
&lt;li&gt;Use an integer array to count segment occurence.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    /**
     * Array Method:
     * @param intervals: An interval array
     * @return: Count of airplanes are in the sky.
     */
    public int countOfAirplanes(List&amp;lt;Interval&amp;gt; airplanes) { 
        
        // find the min and max value in interval list;
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        for(Interval interval : airplanes) {
            min = Math.min(min, interval.start);
            max = Math.max(max, interval.end);
        }

        int maxCnt = 0;
        int[] segment = new int[max - min + 1];
        for(Interval interval : airplanes) {
            for(int i = interval.start; i &amp;lt; interval.end; i++) {
                segment[i - min]++;
                maxCnt = Math.max(maxCnt, segment[i - min]);
            }
        }
        return maxCnt;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Customized Structure:

&lt;ul&gt;
&lt;li&gt;Point Class: mark &lt;code&gt;int time&lt;/code&gt; and (&lt;code&gt;boolean start/end&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Mark those Points ordered by time.&lt;/li&gt;
&lt;li&gt;One pass all points and count increase when touch start but decrease when end;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    /**
     * Point Method:
     * @param intervals: An interval array
     * @return: Count of airplanes are in the sky.
     */
    public int countOfAirplanes(List&amp;lt;Interval&amp;gt; airplanes) { 

    	// create a list with point class
    	List&amp;lt;Point&amp;gt; points = new ArrayList&amp;lt;&amp;gt;();
    	for(Interval interval : airplanes) {
    		points.add(new Point(interval.start, 1));
    		points.add(new Point(interval.end, 0));
    	}

    	// sort
    	Collections.sort(points, new Comparator&amp;lt;Point&amp;gt;(){
    	    @Override
    	    public int compare(Point p1, Point p2) {
    	         if(p1.time == p2.time) return p1.flag - p2.flag;
                 else return p1.time - p2.time;
    	    }
    	});

    	// one pass for count
    	int count = 0;
    	int max = 0; // record the peak count;
    	for(Point p : points) {
    		if(p.flag == 1)
    			count++;
    		else
    			count--;
    		max = Math.max(max, count);
    	}

    	return max;
	}

	private class Point{
		int time;
		int flag;
		public Point(int time, int flag) {
			this.time = time;
			this.flag = flag;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Array Method (Naive):&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two pass and one of pass has one more inner loop (segment size: k): o(n + n*k) -&amp;gt; O(n^2);
An array to store occurence frequence: Space: O(n);&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Next Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/next-permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/next-permutation/</guid>
      <description>

&lt;p&gt;Given a list of integers, which denote a permutation.&lt;/p&gt;

&lt;p&gt;Find the next permutation in ascending order.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;[1,3,2,3]&lt;/code&gt;, the next permutation is &lt;code&gt;[1,3,3,2]&lt;/code&gt;
For &lt;code&gt;[4,3,2,1]&lt;/code&gt;, the next permutation is &lt;code&gt;[1,2,3,4]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The list may contains duplicate integers.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;字典序算法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从后往前寻找索引满足 a[k] &amp;lt; a[k + 1], 如果此条件不满足，则说明已遍历到最后一个。&lt;/li&gt;
&lt;li&gt;如 k == 0, 说明是字典序最后一位， 因此直接倒置整个数组即可.&lt;/li&gt;
&lt;li&gt;从后往前遍历，找到第一个比a[k]大的数a[l], 即a[k] &amp;lt; a[l].&lt;/li&gt;
&lt;li&gt;交换a[k]与a[l].&lt;/li&gt;
&lt;li&gt;反转k + 1 ~ n之间的元素.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nums: an array of integers
     * @return: return nothing (void), do not return anything, modify nums in-place instead
     */
    public int[] nextPermutation(int[] nums) {
        if(nums == null || nums.length == 1)
            return nums;
        
        // step1: find nums[i] &amp;lt; nums[i + 1]
        int i = 0;
        for (i = nums.length - 2; i &amp;gt;= 0; i--) {
            if (nums[i] &amp;lt; nums[i + 1]) {
                break;
            } else if (i == 0) {
                // reverse nums if reach maximum
                reverse(nums, 0, nums.length - 1);
                return nums;
            }
        }
        // step2: find nums[i] &amp;lt; nums[j]
        int j = 0;
        for (j = nums.length - 1; j &amp;gt; i; j--) {
            if (nums[i] &amp;lt; nums[j]) {
                break;
            }
        }
        // step3: swap betwenn nums[i] and nums[j]
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
        
        // step4: reverse between [i + 1, n - 1]
        reverse(nums, i + 1, nums.length - 1);

        return nums;
    }
    
    private void reverse(int[] nums, int l, int r) {
        while(l &amp;lt; r) {
            int tmp = nums[l];
            nums[l++] = nums[r];
            nums[r--] = tmp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis&lt;/h2&gt;

&lt;p&gt;At most, two pass o(2*n) -&amp;gt; O(n); Constant Space Complexity: O(1)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation/</guid>
      <description>

&lt;p&gt;Given a list of numbers, return all possible permutations.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For nums = [1,2,3], the permutations are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it without recursion.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;h4 id=&#34;method-one&#34;&gt;Method One:&lt;/h4&gt;

&lt;p&gt;Backtracking, with memorized the element usage, which takes space, or we can search on arraylist(more time);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /**
     * @param nums: A list of integers.
     * @return: A list of permutations.
     */
    public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; permute(ArrayList&amp;lt;Integer&amp;gt; nums) {

        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(nums == null || nums.size() == 0)
            return res;
        helper(res, new ArrayList&amp;lt;Integer&amp;gt;(), nums);
        return res;
    }
    
    private void helper(ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; res, ArrayList&amp;lt;Integer&amp;gt; list,  ArrayList&amp;lt;Integer&amp;gt; nums ) {
        
        if(list.size() == nums.size()) {
            res.add(new ArrayList&amp;lt;Integer&amp;gt;(list));
            return;
        }
        
        for(int i = 0; i&amp;lt;nums.size(); i++){
        	// to check if this number already taken
            if(list.contains(nums.get(i)))
                continue;
            
            list.add(nums.get(i));
            helper(res, list, nums);
            list.remove(list.size() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;method-two&#34;&gt;Method Two:&lt;/h4&gt;

&lt;p&gt;Swap: &lt;a href=&#34;https://www.cs.princeton.edu/~rs/talks/perms.pdf&#34;&gt;Reference&lt;/a&gt;;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://xmruibi.github.io/media/PermutationSwap.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
  private static Set&amp;lt;Integer&amp;gt; exchPermutation(int[] arr) {
    Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
    int i = 0, num = 0;
    outer: while(true) {
      
      while(i &amp;lt; arr.length - 1) {
        num = exchGenerate(arr, i, ++i);
        if(set.contains(num))
          break outer;
        set.add(num);
      }
      
      num = exchGenerate(arr, 0, 1);
      if(set.contains(num))
        break outer;
      set.add(num);
      
      while(i &amp;gt; 0) {
        num = exchGenerate(arr, --i, i+1);
        if(set.contains(num))
          break outer;
        set.add(num);
      }
      
      num = exchGenerate(arr, arr.length - 2, arr.length - 1);
      if(set.contains(num))
        break outer;
      set.add(num);
    }
    return set;
  }
  
  private static int exchGenerate(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
    
    int res = 0;
    for(int n : arr){
      res = res*10 + n;
    }
    return res;
  }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Previous Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/previous-permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/previous-permutation/</guid>
      <description>

&lt;p&gt;Given a list of integers, which denote a permutation.&lt;/p&gt;

&lt;p&gt;Find the previous permutation in ascending order.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;[1,3,2,3]&lt;/code&gt;, the previous permutation is &lt;code&gt;[1,2,3,3]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For &lt;code&gt;[1,2,3,4]&lt;/code&gt;, the previous permutation is [&lt;code&gt;4,3,2,1]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The list may contains duplicate integers.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;step 1: find last nums[k] &amp;gt; nums[k + 1];&lt;/li&gt;
&lt;li&gt;step 2: find last nums[i] &amp;gt; nums[k];&lt;/li&gt;
&lt;li&gt;step 3: swap i, j;&lt;/li&gt;
&lt;li&gt;step 4: reverse num after i;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nums: A list of integers
     * @return: A list of integers that&#39;s previous permuation
     */
    public ArrayList&amp;lt;Integer&amp;gt; previousPermuation(ArrayList&amp;lt;Integer&amp;gt; nums) {
        if(nums == null || nums.size() &amp;lt;= 1)
            return nums;
            
        // step 1: find last nums[k] &amp;gt; nums[k + 1]
        int i = nums.size() - 2;
        for (; i &amp;gt;= 0; i--) {
            if (nums.get(i) &amp;gt; nums.get(i + 1)) {
                break;
            }
            if(i &amp;lt;= 0) {
                reverse(nums, 0, nums.size() - 1);
                return nums;
            }
        }

        // step 2: find last nums[i] &amp;gt; nums[k]
        int j = nums.size() - 1;
        for (; j &amp;gt; i; j--) {
            if (nums.get(i) &amp;gt; nums.get(j)) {
                break;
            }
        }
        
        // step 3: swap i, j
        Collections.swap(nums, i, j);
        
        // step 4: reverse num after i
        reverse(nums, i + 1, nums.size() - 1);
        
        return nums;
    }
    
    private void reverse(ArrayList&amp;lt;Integer&amp;gt; nums,  int start, int end) {
        for (int i = start, j = end; i &amp;lt; j; i++, j--) {
            Collections.swap(nums, i, j);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>