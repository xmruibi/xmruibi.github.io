<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Career Cup on Geek Think</title>
    <link>http://xmruibi.github.io/topics/career-cup/</link>
    <description>Recent content in Career Cup on Geek Think</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Sun, 15 Nov 2015 20:33:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/topics/career-cup/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Compact Tree Builder</title>
      <link>http://xmruibi.github.io/2015/11/15/compact-tree-builder/</link>
      <pubDate>Sun, 15 Nov 2015 20:33:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/compact-tree-builder/</guid>
      <description>

&lt;p&gt;Given a root of a binary tree. Transform it in a way that each node(except probably one) would either have N or 0 children.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   * A               A                 A                         A
     *  |               |                 |_B                       |_B
     *  |_B             |_B                  |_C                    |
     *     |            |  |                    |_D                 |_C
     *     |            |  |_D                     |_E              |
     *     |            |  |                          |_F           |_D
     *     |_C          |  |_E                           |_G        |
     *     | |_D        |    |_H                            |_H     |_E
     *     |    |_F     |                                           |
     *     |            |_C                                         |_F
     *     |_E            |                                         |
     *       |_G          |_F                                       |_G
     *       |            |                                         |
     *       |_H          |_G                                       |_H
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:397f4eeb84727cbe660f274d6bea7a6c&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;BFS entire tree into a queue.&lt;/li&gt;
&lt;li&gt;Read that queue and build posssible children according to the limit and add it into the root.&lt;/li&gt;
&lt;li&gt;Record the next root in another queue.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:397f4eeb84727cbe660f274d6bea7a6c&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	private static CTree compact(TreeNode node, int limit) {

		// bfs the original tree into a queue
		List&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
		queue.add(node);
		int idx = 0;
		while (idx &amp;lt; queue.size()) {
			TreeNode cur = queue.get(idx++);
			if (cur.left != null)
				queue.add(cur.left);
			if (cur.right != null)
				queue.add(cur.right);
		}
		// get the root for final return
		CTree root = new CTree(queue.remove(0).val);
		// build a queue for store the new type tree
		Queue&amp;lt;CTree&amp;gt; helperQueue = new LinkedList&amp;lt;&amp;gt;();
		helperQueue.add(root);
		while (!queue.isEmpty()) {
			CTree cRoot = helperQueue.remove();
			// build the children for current CTree
			int curLv = 0; // make sure the amount of children
			List&amp;lt;CTree&amp;gt; nexlv = new ArrayList&amp;lt;&amp;gt;();
			while (curLv &amp;lt; limit &amp;amp;&amp;amp; !queue.isEmpty()) {
				nexlv.add(new CTree(queue.remove(0).val));
				helperQueue.offer(nexlv.get(curLv++));
			}			
			cRoot.nodes = nexlv;
		}	
		return root;
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Convert BST to Sorted Doubly-Linked List</title>
      <link>http://xmruibi.github.io/2015/11/15/convert-bst-to-sorted-doubly-linked-list/</link>
      <pubDate>Sun, 15 Nov 2015 17:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/convert-bst-to-sorted-doubly-linked-list/</guid>
      <description>

&lt;p&gt;Given a Binary Tree (BT), convert it to a Doubly Linked List(DLL) In-Place. The left and right pointers in nodes are to be used as previous and next pointers respectively in converted DLL. The order of nodes in DLL must be same as Inorder of the given Binary Tree. The first node of Inorder traversal (left most node in BT) must be head node of the DLL.&lt;/p&gt;

&lt;h2 id=&#34;think:9391617169eedec55b65d518b5c0a515&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Inorder traversal&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-stack:9391617169eedec55b65d518b5c0a515&#34;&gt;Solution #Stack&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	private static Node convertBST2DoublyLinkedList(Node root) {
		Node dummy = new Node(0);
		Node prev = dummy;
		java.util.Stack&amp;lt;Node&amp;gt; stack = new java.util.Stack&amp;lt;&amp;gt;();

		do {
			while (root != null) {
				stack.push(root);
				root = root.prev;
			}
			Node cur = stack.pop();
			prev.next = cur;
			cur.prev = prev;
			prev = prev.next;
			if (cur.next != null)
				root = cur.next;
			else
				root = null;
		} while (!stack.isEmpty() || root != null);

		return dummy.next;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-recursion:9391617169eedec55b65d518b5c0a515&#34;&gt;Solution #Recursion&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
    static Node dummy = new Node(0);
    static Node pre = dummy;

    private static Node convertII(Node root) {
        if (root == null)
            return root;
        Node prev = convertII(root.prev);
        pre.next = root;
        root.prev = pre;
        pre = root;
        Node next = convertII(root.next);
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Palindromic Subsequence</title>
      <link>http://xmruibi.github.io/2015/11/15/longest-palindromic-subsequence/</link>
      <pubDate>Sun, 15 Nov 2015 14:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/longest-palindromic-subsequence/</guid>
      <description>

&lt;p&gt;Given a sequence, find the length of the longest palindromic subsequence in it. For example, if the given sequence is &lt;code&gt;“BBABCBCAB”&lt;/code&gt;, then the output should be 7 as &lt;code&gt;“BABCBAB”&lt;/code&gt; is the longest palindromic subseuqnce in it. &lt;code&gt;“BBBBB”&lt;/code&gt; and &lt;code&gt;“BBCBB”&lt;/code&gt; are also palindromic subsequences of the given sequence, but not the longest ones.&lt;/p&gt;

&lt;h2 id=&#34;solution-dynamic-programming:0dddaebd549f2b96d7e1c402abcf8d05&#34;&gt;Solution #Dynamic Programming&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static int longestSubsequence(String str) {
		// memo[len][i] represent from index &#39;i&#39; with length &#39;len&#39; has how many
		// palindromic subsequence
		int[][] memo = new int[str.length() + 1][str.length() + 1];

		// initial len with 1 as 1, since for every index it has 1 len
		// palindromic subsequence
		for (int i = 0; i &amp;lt; str.length(); i++)
			memo[1][i] = 1;

		// iterate the str with different length setting
		for (int len = 2; len &amp;lt;= str.length(); len++) {
			for (int i = 0; i &amp;lt;= str.length() - len; i++) {
				int tar = i + len - 1;
				if (len == 2 &amp;amp;&amp;amp; str.charAt(i) == str.charAt(tar))
					memo[len][i] = 2;
				else if (str.charAt(i) == str.charAt(tar))
					memo[len][i] = 2 + memo[len - 2][i + 1];
				else
					memo[len][i] = Math.max(memo[len - 1][i],
							memo[len - 1][i + 1]);
			}
		}
		return memo[str.length()][0];
	}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-recursive:0dddaebd549f2b96d7e1c402abcf8d05&#34;&gt;Solution # Recursive&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int calculateRecursive(char str[],int start,int len){
        if(len == 1){
            return 1;
        }
        if(len ==0){
            return 0;
        }
        if(str[start] == str[start+len-1]){
            return 2 + calculateRecursive(str,start+1,len-2);
        }else{
            return Math.max(calculateRecursive(str, start+1, len-1), calculateRecursive(str, start, len-1));
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Max Points on a Line</title>
      <link>http://xmruibi.github.io/2015/11/15/max-points-on-a-line/</link>
      <pubDate>Sun, 15 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/max-points-on-a-line/</guid>
      <description>

&lt;p&gt;Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.&lt;/p&gt;

&lt;h2 id=&#34;think:0468874f3f0719bf48609e7d9f0fd5fc&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Represent line by ratio. Compare point to point by a nested two loop.&lt;/li&gt;
&lt;li&gt;Think about four cases:

&lt;ul&gt;
&lt;li&gt;Same point, count the same point amount&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; axis are the same&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt; axis are the same&lt;/li&gt;
&lt;li&gt;normal case &lt;code&gt;(y1 - y2)/(x1 - x2)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:0468874f3f0719bf48609e7d9f0fd5fc&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MaxPointOnAline {

    public int getMaxLine(List&amp;lt;FloatPoint&amp;gt; points) {
        if (points == null || points.size() == 0)
            return 0;

        int max = 0;
        for (int i = 0; i &amp;lt; points.size(); i++) {
            FloatPoint cur = points.get(i);
            Map&amp;lt;Double, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
            int same = 0, localMax = 1;
            for (int j = i + 1; j &amp;lt; points.size(); j++) {
                FloatPoint tar = points.get(j);
                if (cur.x == tar.x &amp;amp;&amp;amp; cur.y == tar.y) {
                    same++;
                }else if (cur.x == tar.x) {
                    double maxr = Double.MAX_VALUE;
                    map.put(maxr, map.containsKey(maxr) ? map.get(maxr) + 1 : 2);
                } else if (cur.y == tar.y) {
                    map.put(0.0, map.containsKey(0.0) ? map.get(0.0) + 1 : 2);
                } else {
                    double ratio = (cur.y - tar.y) / (cur.x - tar.x);
                    map.put(ratio, map.containsKey(ratio) ? map.get(ratio) + 1
                            : 2);
                }
            }
            for (Map.Entry&amp;lt;Double, Integer&amp;gt; entry : map.entrySet())
                localMax = Math.max(localMax, entry.getValue());
            max = Math.max(localMax + same, max);
        }
        return max;
    }
}

class FloatPoint {
    float x, y; // float may not suitable for accurate computation

    public FloatPoint(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Max Stack</title>
      <link>http://xmruibi.github.io/2015/11/15/max-stack/</link>
      <pubDate>Sun, 15 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/max-stack/</guid>
      <description>

&lt;p&gt;Design a stack, which makes the following function, try to reduce the time compaxity less than &lt;code&gt;O(n)&lt;/code&gt;
- &lt;code&gt;pop()&lt;/code&gt; pop the top of stack
- &lt;code&gt;push()&lt;/code&gt; push a element into stack
- &lt;code&gt;peek()&lt;/code&gt; peek the top of stack
- &lt;code&gt;peekMax()&lt;/code&gt; peek the max element of stack
- &lt;code&gt;popMax()&lt;/code&gt; pop the max element of stack&lt;/p&gt;

&lt;h2 id=&#34;think:0c76a512774b6e4792fd578d8968c8bd&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Typically, we can think about using one stacks and one heap. One of value, one of tracking the max stack.&lt;/li&gt;
&lt;li&gt;The most tricky part is pop max function. Make the node removal in O(n) should use the doubly linked list.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:0c76a512774b6e4792fd578d8968c8bd&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MaxStack {
    Stack elem = new Stack();
    PriorityQueue&amp;lt;ListNode&amp;gt; heap = new PriorityQueue&amp;lt;ListNode&amp;gt;((o1,o2) -&amp;gt; Integer.compare(o2.val, o1.val));
    
    // take O(logn): the depth of heap tree 
    public void push(int val) {
        ListNode newnode = new ListNode(val);
        heap.add(newnode); 
        elem.push(newnode);
    }
    
    // take O(logn): the depth of heap tree 
    public void pop() {
        ListNode remove = elem.pop();
        heap.remove(remove); 
    }
    
    // O(1) time
    public int peek() {
        return elem.peek().val;
    }

    // O(1) time
    public int peekMax() {
        return heap.peek().val; 
    }

    // take O(logn): the depth of heap tree 
    public void popMax() {
        ListNode node = heap.poll(); 
        elem.remove(node);
    }

    public static void main(String[] args) {
        MaxStack ms = new MaxStack();
        ms.push(1);
        ms.push(3);
        ms.push(2);
        System.out.println(ms.peekMax()); // == 3
        ms.popMax();
        System.out.println(ms.peekMax()); // == 2
        ms.push(4);
        ms.push(8);
        ms.pop();
        System.out.println(ms.peekMax()); // == 4
    }
}

class Stack {
    ListNode head, rear;

    public Stack() {
        head = new ListNode(0);
        rear = new ListNode(0);
        head.next = rear;
        rear.prev = head;
    }

    public void push(ListNode newnode) {
        rear.prev.next = newnode;
        newnode.prev = rear.prev;
        newnode.next = rear;
        rear.prev = newnode;
    }

    public ListNode pop() {
        if (isEmpty())
            return null;
        ListNode remove = rear.prev;
        rear.prev = remove.prev;
        remove.prev.next = rear;
        return remove;
    }

    public ListNode peek() {
        if (isEmpty())
            return null;
        ListNode peek = rear.prev;
        return peek;
    }

    public void remove(ListNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    public boolean isEmpty() {
        return head.next == rear;
    }
}

class ListNode {
    int val;
    ListNode prev, next;

    public ListNode(int val) {
        this.val = val;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Iterator for Merging Sorted Stream</title>
      <link>http://xmruibi.github.io/2015/11/15/iterator-for-merging-sorted-stream/</link>
      <pubDate>Sun, 15 Nov 2015 10:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/iterator-for-merging-sorted-stream/</guid>
      <description>

&lt;p&gt;Design a iterator, with input a list and a hop parameter. Then output the element according to that hop number. List: &lt;code&gt;1, 2, 3, 4, 5, 6, 7, 8, 9; hop = 2&lt;/code&gt; -&amp;gt; &lt;code&gt;2, ,4, 6, 8&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution:c20097de2cc12809c8a9177ae4edd63e&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HopIterator&amp;lt;E&amp;gt; implements Iterator&amp;lt;E&amp;gt; {
	int hop;
	Iterator&amp;lt;E&amp;gt; itr;

	public HopIterator(Collection&amp;lt;E&amp;gt; list, int hop) {
		this.itr = list.iterator();
		this.hop = hop;
	}

	@Override
	public boolean hasNext() {
		int k = 1;
		while (k &amp;lt; hop &amp;amp;&amp;amp; itr.hasNext()) {
			k++;
			itr.next();
		}
		return k == hop &amp;amp;&amp;amp; itr.hasNext();
	}

	@Override
	public E next() {
		return itr.next();
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Balanced Point in Array</title>
      <link>http://xmruibi.github.io/2015/11/14/balanced-point-in-array/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/balanced-point-in-array/</guid>
      <description>

&lt;p&gt;Balanced index of an array is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes.&lt;/p&gt;

&lt;h3 id=&#34;example:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;In an arrya A:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A[0] = -7, A[1] = 1, A[2] = 5, A[3] = 2, A[4] = -4, A[5] = 3, A[6]=0
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;3&lt;/code&gt; is an Balanced index, because: &lt;code&gt;A[0] + A[1] + A[2] = A[4] + A[5] + A[6]&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;6&lt;/code&gt; is also an Balanced index, because sum of zero elements is zero, i.e., &lt;code&gt;A[0] + A[1] + A[2] + A[3] + A[4] + A[5]=0&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;7&lt;/code&gt; is not an Balanced index, because it is not a valid index of array A.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Write a function int &lt;code&gt;balancedPoint(int[] arr)&lt;/code&gt;; that given a sequence arr[] of size n, returns an Balanced index (if any) or -1 if no Balanced indexes exist.&lt;/p&gt;

&lt;h2 id=&#34;think:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;The idea is to get total sum of array first. Then Iterate through the array and keep updating the left sum which is initialized as zero. In the loop, we can get right sum by subtracting the elements one by one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1) Initialize leftsum  as 0
2) Get the total sum of the array as sum
3) Iterate through the array and for each index i, do following.
    a)  Update sum to get the right sum.  
           sum = sum - arr[i] 
       // sum is now right sum
    b) If leftsum is equal to sum, then return current index. 
    c) leftsum = leftsum + arr[i] // update leftsum for next iteration.
4) return -1 // If we come out of loop without returning then
             // there is no equilibrium index
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	// find all balance point in an array return balanced index
	public List&amp;lt;Integer&amp;gt; findBalancedPoint(int[] arr) {
		int leftsum = 0, rightsum = 0;
		List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

		for (int i = 0; i &amp;lt; arr.length; i++) 
			leftsum += arr[i];
		
		for (int i = arr.length - 1; i&amp;gt;=0; i--) {
			leftsum -= arr[i];
			if(leftsum == rightsum)
				res.add(i);
			rightsum+=arr[i];
		}
		return -1;
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find Valid IP Address in a File</title>
      <link>http://xmruibi.github.io/2015/11/14/find-valid-ip-address-in-a-file/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/find-valid-ip-address-in-a-file/</guid>
      <description>

&lt;p&gt;Given a file with many lines of Strings, find those valid IP address from them.&lt;/p&gt;

&lt;h2 id=&#34;solution:ed817a74e0c3a1097fc0cfb76d5d85e1&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ValidIPAddress {

    public List&amp;lt;String&amp;gt; findValidIPAddr(String filePath) throws IOException {
        List&amp;lt;String&amp;gt; addresses = new ArrayList&amp;lt;&amp;gt;();
        Scanner sc = new Scanner(new File(filePath));
        while (sc.hasNext()) {
            String line = sc.next();
            if(validIP(line))
                addresses.add(line);
        }
        return addresses;
    }

    private boolean validIP(String str) {
        try {
            String[] parts = str.split(&amp;quot;.&amp;quot;);
            // check segment length;
            if (parts.length != 4 || str.endsWith(&amp;quot;.&amp;quot;))
                return false;

            // check each segment valid or not
            for (int i = 0; i &amp;lt; parts.length; i++) {
                String s = parts[i];
                int val = Integer.parseInt(s);
                if ((s.charAt(0) == &#39;0&#39;) || (val &amp;lt; 0 || val &amp;gt; 255)
                        || (i == 0 &amp;amp;&amp;amp; val == 0))
                    return false;
            }
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Can I Win</title>
      <link>http://xmruibi.github.io/2015/11/14/can-i-win/</link>
      <pubDate>Sat, 14 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/can-i-win/</guid>
      <description>

&lt;p&gt;Given an array of positive integers and two players. In each turn, one player picks up one number and if the sum of all the picked up numbers is greater than a target number, the player wins. Write a program &lt;code&gt;canIWin()&lt;/code&gt; to print the result.&lt;/p&gt;

&lt;h2 id=&#34;think:20042e86952d9768f73636e75bf69c3b&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This question is pretty tricky.&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s not just choose the largest number in number pool. Instead of, for each turn, player has two choice:

&lt;ul&gt;
&lt;li&gt;If current pool has number can just make the sum larger than target, pick that number&lt;/li&gt;
&lt;li&gt;If not number can added to make the sum exceed target, try to make current pick with the minimum number from the pool.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:20042e86952d9768f73636e75bf69c3b&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        public static Result canIWin(int[] nums, int target) {
                if (target &amp;lt;= 0)
                        return Result.Lose;
                // first iterate - find any number larger than remain target, or check
                // all number in pool has taken
                boolean hasNum = false;
                for (int num : nums) {
                        if (num &amp;gt;= target)
                                return Result.Win;
                        else if (num &amp;gt; 0)
                                hasNum = true;
                }
                if (!hasNum)
                        return Result.Draw;
                for (int i = 0; i &amp;lt; nums.length; i++) {
                        if (nums[i] &amp;gt; 0) {
                                int data = nums[i];
                                nums[i] = -1;
                                Result rivalResult = canIWin(nums, target - data);
                                if (rivalResult == Result.Win)
                                        return Result.Lose;
                                if (rivalResult == Result.Lose)
                                        return Result.Win;
                                nums[i] = data;
                        }
                }
                return Result.Draw;
        }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Constant Time Random Picker</title>
      <link>http://xmruibi.github.io/2015/11/14/constant-time-random-picker/</link>
      <pubDate>Sat, 14 Nov 2015 00:30:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/constant-time-random-picker/</guid>
      <description>

&lt;p&gt;Design a data structure that supports insert, delete, search and getRandom in constant time.&lt;/p&gt;

&lt;p&gt;Design a data structure that supports following operations in Θ(1) time.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;insert(x)&lt;/code&gt;: Inserts an item x to the data structure if not already present.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove(x)&lt;/code&gt;: Removes an item x from the data structure if present.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;search(x)&lt;/code&gt;: Searches an item x in the data structure.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getRandom()&lt;/code&gt;: Returns a random element from current set of elements&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;think:fbe9fdf4f7686b0780359874c12ae63a&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;We can use hashing to support first 3 operations in Θ(1) time. How to do the 4th operation? The idea is to use a resizable array (ArrayList in Java, vector in C) together with hashing. Resizable arrays support insert in Θ(1) amortized time complexity. To implement getRandom(), we can simply pick a random number from 0 to size-1 (size is number of current elements) and return the element at that index. The hash map stores array values as keys and array indexes as values.&lt;/p&gt;

&lt;p&gt;Following are detailed operations.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;insert(x)&lt;/li&gt;
&lt;li&gt;Check if x is already present by doing a hash map lookup.&lt;/li&gt;
&lt;li&gt;If not present, then insert it at the end of the array.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add in hash table also, x is added as key and last array index as index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;remove(x)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check if x is present by doing a hash map lookup.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If present, then find its index and remove it from hash map.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swap the last element with this element in array and remove the last element.
Swapping is done because the last element can be removed in O(1) time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Update index of last element in hash map.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getRandom()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generate a random number from 0 to last index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Return the array element at the randomly generated index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;search(x)
Do a lookup for x in hash map.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:fbe9fdf4f7686b0780359874c12ae63a&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ConstantTimeRandomPicker {
	
	private final ArrayList&amp;lt;Integer&amp;gt; arr;
	private final HashMap&amp;lt;Integer, Integer&amp;gt; map; // value - index
    Random r;
	
	public ConstantTimeRandomPicker() {
		this.arr = new ArrayList&amp;lt;Integer&amp;gt;();
		this.map = new HashMap&amp;lt;Integer, Integer&amp;gt;();
	}
	
	public void add(int val) {
		arr.add(val);
		map.put(arr.size() - 1, val);
	}
	
	public void remove(int val) {
		remove(map.get(val), val);
	}
	
	public void removeRandom() {
		int val = arr.get(r.nextInt(arr.size()));
		remove(map.get(val), val);
	}
	
	public int getRandom() {
		return arr.get(r.nextInt(arr.size()));
	}
	
	public int search(int val) {
		return arr.get(map.get(val));
	}

	private void remove(int idx, int val) {
		
		// swap with the last element
		int last = arr.get(arr.size() - 1);
		// put the last element to the current index
		arr.set(idx, last);
		// remove the last element
		arr.remove(arr.size() - 1);
				
		// update the last element&#39;s index in hashmap
		map.put(last, idx);		
		// remove the removal value
		map.remove(val);
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Intervals and Covered Length</title>
      <link>http://xmruibi.github.io/2015/11/14/intervals-and-covered-length/</link>
      <pubDate>Sat, 14 Nov 2015 00:30:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/intervals-and-covered-length/</guid>
      <description>

&lt;p&gt;Design a structrue can get interval pair and a function which can return the total cover length.&lt;/p&gt;

&lt;h2 id=&#34;partial-code:a398446ee2bc7e4d0eef3e4051fe083f&#34;&gt;Partial Code&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Intervals {

	/**
	 * Adds an interval [from, to] into internal structure.
	 */
	void addInterval(int from, int to);

	/**
	 * Returns a total length covered by intervals. If several intervals
	 * intersect, intersection should be counted only once. Example:
	 *
	 * addInterval(3, 6) addInterval(8, 9) addInterval(1, 5)
	 *
	 * getTotalCoveredLength() -&amp;gt; 6 i.e. [1,5] and [3,6] intersect and give a
	 * total covered interval [1,6] [1,6] and [8,9] don&#39;t intersect so total
	 * covered length is a sum for both intervals, that is 6.
	 *
	 * _________ ___ ____________
	 *
	 * 0 1 2 3 4 5 6 7 8 9 10
	 *
	 */
	int getTotalCoveredLength();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:a398446ee2bc7e4d0eef3e4051fe083f&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IntervalProblem implements Intervals {

    private class Interval {
        int from, to;

        public Interval(int from, int to) {
            this.from = from;
            this.to = to;
        }
    }

    List&amp;lt;Interval&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    @Override
    public void addInterval(int start, int end) {
        if (list.size() == 0) {
            list.add(new Interval(start, end));
            return;
        }       

        ListIterator&amp;lt;Interval&amp;gt; li = list.listIterator();

        while(li.hasNext()){
            Interval itv = li.next();
            if(start &amp;lt;= itv.to){
                if(end &amp;lt; itv.from){ //newInterval does not overlap with current itv, time to insert
                    li.remove();
                    li.add(new Interval(start, end));
                    li.add(itv);
                    return;
                }
                // still some overlap so compare start &amp;amp; end
                start = Math.min(start, itv.from);
                end = Math.max(end, itv.to);
                li.remove();
            }
        }
        list.add(new Interval(start, end));
    }

    @Override
    public int getTotalCoveredLength() {
        if (list.size() == 0) 
            return 0;
        int sum = 0;
        for (int i = 0; i &amp;lt; list.size(); i++) {
            sum += (list.get(i).to - list.get(i).from);
        }
        return sum;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>K Nearest Points</title>
      <link>http://xmruibi.github.io/2015/11/13/k-nearest-points/</link>
      <pubDate>Fri, 13 Nov 2015 23:50:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/k-nearest-points/</guid>
      <description>

&lt;p&gt;Find K nearest Points by given the central point. Complete the class design for Point as implementing Comparable interface.&lt;/p&gt;

&lt;h2 id=&#34;think:8857fa3e9119e0ac4dde82275e35c3e7&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Comparable interface and Max heap&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:8857fa3e9119e0ac4dde82275e35c3e7&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class KNearestPoints {

    // finding k nearest neighbor from the original point using a MAX heap, each
    // time if the dist is less than the MAX we put it into the q.
    public Collection&amp;lt;Point&amp;gt; getClosestPoints(Collection&amp;lt;Point&amp;gt; points, int k) {
        PriorityQueue&amp;lt;Point&amp;gt; queue = new PriorityQueue&amp;lt;Point&amp;gt;(k);
        int i = 0;
        for(Point p:points) {
            if(i &amp;lt; k) {
                queue.add(p);
            }else{
                if(p.compareTo(queue.peek()) &amp;lt; 0) {
                    queue.poll();
                    queue.offer(p);
                }
            }
            i++;
        }
        return queue;
    }
}

class Point implements Comparable&amp;lt;Point&amp;gt; {
    final int x, y;
    final double dist;

    public Point(int x, int y, Point origin) {
        this.x = x;
        this.y = y;
        this.dist = Math.hypot(x - origin.x, y - origin.y);
    }

    @Override
    public int compareTo(Point o) {
        return Double.compare(this.dist, o.dist);
    }

    @Override
    public String toString() {
        return &amp;quot;x: &amp;quot; + x + &amp;quot; y: &amp;quot; + y;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Text File Iterator</title>
      <link>http://xmruibi.github.io/2015/11/13/text-file-iterator/</link>
      <pubDate>Fri, 13 Nov 2015 20:40:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/text-file-iterator/</guid>
      <description>

&lt;p&gt;Implement a (Java) Iterable object that iterates lines one by one from a text file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** A reference to a file. */
public class TextFile implements Iterable&amp;lt;String&amp;gt; {
  public TextFile(String fileName) { 
  	// please implement this
  }
  /** Begin reading the file, line by line. The returned Iterator.next() will return a line. */ 
  @Override
  public Iterator&amp;lt;String&amp;gt; iterator() { 
  	// please implement this
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-1:c8747d864080a32ac128d8a7bbaf43e1&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Keep maintain a BufferedReader&lt;/li&gt;
&lt;li&gt;The tricky part is the hasNext function, we should not use checking &lt;code&gt;br.readline() != null&lt;/code&gt; in this function, since it will cause the line skipping.&lt;/li&gt;
&lt;li&gt;So notice the &lt;code&gt;mark()&lt;/code&gt; and &lt;code&gt;reset()&lt;/code&gt; method in bufferedreader.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:c8747d864080a32ac128d8a7bbaf43e1&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TextFileIterator implements Iterable&amp;lt;String&amp;gt; {

	private final BufferedReader br;

	public TextFileIterator(String path) throws FileNotFoundException {
		br = new BufferedReader(new InputStreamReader(new FileInputStream(
				new File(path))));

	}

	public Iterator&amp;lt;String&amp;gt; iterator() {
		return new Iterator&amp;lt;String&amp;gt;() {
			@Override
			public boolean hasNext() {
				try {
					br.mark(1);
					if (br.read() &amp;lt; 0) 
						return false;					
					br.reset();
					return true;
				} catch (IOException e) {
					return false;
				}
			}

			@Override
			public String next() {
				try {
					return br.readLine();
				} catch (IOException e) {
					return null;
				}
			}
		};
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2:c8747d864080a32ac128d8a7bbaf43e1&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Scanner&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2:c8747d864080a32ac128d8a7bbaf43e1&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TextFileIterator implements Iterable&amp;lt;String&amp;gt; {

	private final Scanner sc;
	
	public TextFileIterator(String path) throws FileNotFoundException {
			sc = new Scanner(new File(path));
	}

	public Iterator&amp;lt;String&amp;gt; iterator() {
		return new Iterator&amp;lt;String&amp;gt;() {
			@Override
			public boolean hasNext() {
				return sc.hasNext();
			}

			@Override
			public String next() {
				return sc.nextLine();
			}
		};
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Reverse a Stack using Recursion</title>
      <link>http://xmruibi.github.io/2015/11/13/reverse-a-stack-using-recursion/</link>
      <pubDate>Fri, 13 Nov 2015 20:39:16 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/reverse-a-stack-using-recursion/</guid>
      <description>

&lt;p&gt;Reverse a stack using recursion.&lt;/p&gt;

&lt;p&gt;You are not allowed to use loop constructs like while, for..etc, and you can only use the following ADT functions on Stack S:
- &lt;code&gt;isEmpty(S)&lt;/code&gt;
- &lt;code&gt;push(S)&lt;/code&gt;
- &lt;code&gt;pop(S)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think:67652d66ff3aed8bc58d000794c76ecc&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Very very trick problem&lt;/li&gt;
&lt;li&gt;The idea of the solution is to hold all values in Function Call Stack until the stack becomes empty. When the stack becomes empty, insert all held items one by one at the bottom of the stack.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:67652d66ff3aed8bc58d000794c76ecc&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void recrusion(Stack&amp;lt;Integer&amp;gt; stack) {
        if (stack.isEmpty())
            return;
        int tmp = stack.pop();
        recrusion(stack);
        helper(stack, tmp);
    }

    private static void helper(Stack&amp;lt;Integer&amp;gt; stack, int val) {
        if (stack.isEmpty())
            stack.push(val);
        else {
            int tmp = stack.pop();
            helper(stack, val);
            stack.push(tmp);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Two Sum Implementation</title>
      <link>http://xmruibi.github.io/2015/11/13/two-sum-implementation/</link>
      <pubDate>Fri, 13 Nov 2015 19:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/two-sum-implementation/</guid>
      <description>

&lt;p&gt;Finish a implementation for a interface where it store some data and returns true if there is any pair of numbers in the internal data structure which have sum @param val, and false otherwise.&lt;/p&gt;

&lt;h3 id=&#34;given-code:7520a8219794c9e393cc99906f6d5dad&#34;&gt;Given Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface TwoSum {
    /**
     * Stores @param input in an internal data structure.
     */
    void store(int input);
    /**
     * Returns true if there is any pair of numbers in the internal data structure which
     * have sum @param val, and false otherwise.
     * For example, if the numbers 1, -2, 3, and 6 had been stored,
     * the method should return true for 4, -1, and 9, but false for 10, 5, and 0
     */
    boolean test(int val);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:7520a8219794c9e393cc99906f6d5dad&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Two Sum problem has two way to solve

&lt;ul&gt;
&lt;li&gt;Sort strategy (O(nlogn) time, O(1) space);&lt;/li&gt;
&lt;li&gt;Set strategy (O(n) time, O(n) space);&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:7520a8219794c9e393cc99906f6d5dad&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TwoSumProblem implements TwoSum{
    
    // thread not safe, use CopyOnWriteArrayList&amp;lt;E&amp;gt; for thread safe
    List&amp;lt;Integer&amp;gt; list; 
    // save the previous data for unnecessary duplicate computation
    HashSet&amp;lt;Integer&amp;gt; set;
    
    public TwoSumProblem() {
        list = new ArrayList&amp;lt;&amp;gt;();
        set = new HashSet&amp;lt;&amp;gt;();
    }
    
    @Override
    public void store(int input) {
        list.add(input);    
    }

    @Override
    public boolean test(int val) {
        if(set.contains(val))
            return true;
        return checkTwoSum(val);
    }

    // sort strategy (O(nlogn) time, O(1) space)
    private boolean checkTwoSum(int target){
        Collections.sort(list);
        int l = 0, r = list.size() - 1;
        while(l &amp;lt; r) {
            int sum = list.get(l) + list.get(r);
            if(sum == target){
                set.add(target);
                return true;
            }else if(sum &amp;lt; target)
                l++;
            else
                r--;
        }
        return false;
    }

    // set strategy (O(n) time, O(n) space)
    private boolean checkTwoSumII(int target){
         int len = list.size();
           Set&amp;lt;Integer&amp;gt; mem = new HashSet();
            for(int i = 0; i &amp;lt; len; i++){
                if ( mem.contains(target - list.get(i)) 
                        return true;
               else 
                    mem.add(list.get(i));
            }
            return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>