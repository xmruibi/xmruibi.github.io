<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ymx on Geek Think</title>
    <link>http://xmruibi.github.io/topics/ymx/</link>
    <description>Recent content in Ymx on Geek Think</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Thu, 19 Nov 2015 12:33:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/topics/ymx/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Find a Path in Maze</title>
      <link>http://xmruibi.github.io/2015/11/19/find-a-path-in-maze/</link>
      <pubDate>Thu, 19 Nov 2015 12:33:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/19/find-a-path-in-maze/</guid>
      <description>

&lt;p&gt;Find path in given 2D matrix. 3 states, &lt;code&gt;0&lt;/code&gt; means allow to go, &lt;code&gt;1&lt;/code&gt; means the obstacle, &lt;code&gt;9&lt;/code&gt; is the final, return true or false if the path exist from &lt;code&gt;(0,0)&lt;/code&gt; to any position contains &lt;code&gt;9&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution:6bea082703d3b73c0480d7f0afc663d2&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	/**
	 * DFS Implementation
	 * @param matrix as maze
	 * @param x start position
	 * @param y start position
	 * @return
	 */
	public static boolean findPath(int[][] matrix, int x, int y) {
		// output for edge cases
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0
				|| matrix[x][y] == 1) {
			return false;
		}
		// the steps for x and y
		int[] sx = { 0, 0, -1, 1 };
		int[] sy = { 1, -1, 0, 0 };

		// if current position is &#39;9&#39;
		if (matrix[x][y] == 9)
			return true;
		// set current value to 1 avoid the duplicate visiting
		matrix[x][y] = 1;
		
		// dfs to try the path in matrix
		for (int i = 0; i &amp;lt; 4; i++) {
			int nx = x + sx[i];
			int ny = y + sy[i];
			if (nx &amp;gt;= 0 &amp;amp;&amp;amp; nx &amp;lt; matrix.length &amp;amp;&amp;amp; ny &amp;gt;= 0
					&amp;amp;&amp;amp; ny &amp;lt; matrix[nx].length &amp;amp;&amp;amp; matrix[nx][ny] != 1) {
				if (findPath(matrix, nx, ny))
					return true;
			}
		}
		return false;
	}

	/**
	 * BFS Implementation
	 * @param matrix as maze
	 * @param x start position
	 * @param y start position
	 * @return
	 */
	public static boolean findPathII(int[][] matrix, int x, int y) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0
				|| matrix[x][y] == 1) {
			return false;
		}
		// the steps for x and y
		int[] sx = { 0, 0, -1, 1 };
		int[] sy = { 1, -1, 0, 0 };

		// setup a queue to do the bfs
		Queue&amp;lt;int[]&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
		queue.offer(new int[] { x, y });
		matrix[x][y] = 1;
		while (!queue.isEmpty()) {
			int[] cur = queue.poll();
			if (matrix[cur[0]][cur[1]] == 9) 
				return true;
			
			matrix[cur[0]][cur[1]] = 1;
			for (int i = 0; i &amp;lt; 4; i++) {
				int nx = cur[0] + sx[i];
				int ny = cur[1] + sy[i];
				if (nx &amp;gt;= 0 &amp;amp;&amp;amp; nx &amp;lt; matrix.length &amp;amp;&amp;amp; ny &amp;gt;= 0
						&amp;amp;&amp;amp; ny &amp;lt; matrix[nx].length &amp;amp;&amp;amp; matrix[nx][ny] != 1) {
					queue.offer(new int[] { nx, ny });
					matrix[nx][ny] = 1;
				}
			}
		}
		return false;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;time-complexity:6bea082703d3b73c0480d7f0afc663d2&#34;&gt;Time Complexity&lt;/h2&gt;

&lt;p&gt;For DFS, it takes much space $O(m * n)$ since the recursion stack,  while the time complexity is $O(m * n)$. More specifically, the space complexity depends on the maze type and the step direction order.&lt;/p&gt;

&lt;p&gt;For BFS, it take less space, since every time the queue only store the valid neighbors according to current layer for a certain node. In matrix, the maximum layer size is the valid node number in diagonal. So the complexity is $O(\sqrt{n^2 + m^2})$. But the time complexity is the same as DFS with $O(m * n)$.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Find Minimum Value Sum of Path</title>
      <link>http://xmruibi.github.io/2015/11/19/find-minimum-value-sum-of-path/</link>
      <pubDate>Thu, 19 Nov 2015 10:23:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/19/find-minimum-value-sum-of-path/</guid>
      <description>

&lt;p&gt;Given a binary tree, find a path has the minimum sum of node value.&lt;/p&gt;

&lt;h2 id=&#34;solution:daf05f69a964957806f1dbf44b1f6175&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public static int minPath(TreeNode root) {
		if (root == null)
			return 0;
		if (root.left == null &amp;amp;&amp;amp; root.right == null)
			return root.val;
		if (root.left == null)
			return root.val + minPath(root.right);
		if (root.right == null)
			return root.val + minPath(root.left);
		return root.val + Math.min(minPath(root.left), minPath(root.right));
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Arithmetic Sequence</title>
      <link>http://xmruibi.github.io/2015/11/18/arithmetic-sequence/</link>
      <pubDate>Wed, 18 Nov 2015 13:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/18/arithmetic-sequence/</guid>
      <description>

&lt;p&gt;A sequence of numbers is called &lt;em&gt;Arithmetic&lt;/em&gt; if it consists of at least three elements and if the difference between any two consecutive elements is the same. For example, &lt;code&gt;[1,3,5,7,9]&lt;/code&gt;, &lt;code&gt;[7,7,7,7,7]&lt;/code&gt; and &lt;code&gt;[3,-1,-5,-9]&lt;/code&gt; are arithmetic.&lt;/p&gt;

&lt;p&gt;A slice (P, Q) of Array A is called arithmetic if the sequence:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	A[P], A[P+1], ..., A[Q-1],A[Q]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is arthmetic. In particular, this means that &lt;code&gt;P+1 &amp;lt; Q&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a function: &lt;code&gt;class Solution { public int solution(int[] A);}&lt;/code&gt; that, given array &lt;code&gt;A&lt;/code&gt; consisting of &lt;code&gt;N&lt;/code&gt; numbers, returns the number of arithmetic slices in &lt;code&gt;A&lt;/code&gt;. The function should return &lt;code&gt;-1&lt;/code&gt; if the result exceeds 1,000,000,000.&lt;/p&gt;

&lt;h3 id=&#34;example:fe4862e12cf7144de624f77907b24b10&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;A[0] = -1, A[1] = 1, A[2] = 3, A[3] = 3, A[4] = 3, A[5] = 2, A[6] = 1, A[7] = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should return &lt;code&gt;5&lt;/code&gt; since there are five arithmetic slices of that array, namely:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{0, 2}, {2, 4}, {4, 6}, {4, 7}, {5, 7}
``


## Solution
```java
public class Solution{
	public int countArithmetic(int[] array) {
		if(array.length &amp;lt; 3) 
			return 0;
		int total = 0;
		int idx = 1;
		while(idx &amp;lt; array.length) {
			int curSlice = 2;
			int diff = array[idx] - array[idx-1];
			// if the difference between two consecutive numbers is the same
			while(++idx &amp;lt; array.length &amp;amp;&amp;amp; array[idx] - array[idx-1] == diff) {
				curSlice++;
			}

			if(curSlice &amp;gt;= 3) {
				// when slice length = 3 -&amp;gt; count 1, = 4 -&amp;gt; 1*2, = 5 -&amp;gt; 1*2*3...
				total += ((curSlice - 2) * (curSlice - 1) / 2);
			}
		}
		return (total &amp;gt; 1000000000) ? -1 :total;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find Loops in Linked List</title>
      <link>http://xmruibi.github.io/2015/11/18/find-loops-in-linked-list/</link>
      <pubDate>Wed, 18 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/18/find-loops-in-linked-list/</guid>
      <description>

&lt;p&gt;Given a linked list, find if it has a loop inside and return the loop beginning if it has the loop&lt;/p&gt;

&lt;h2 id=&#34;solution:a840d91244dfb46c7b1bf7358d4fa1d5&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
    public boolean findLoop(ListNode root) {
        if(root == null || root.next == null)
            return false;
        ListNode runner = root;
        ListNode walker = root;
        while(runner != null &amp;amp;&amp;amp; runner.next != null) {
            runner = runner.next.next;
            walker = walker.next;
            if(runner == walker)
                return true;
        }
        return false;
    }

    public ListNode findLoopEntry(ListNode root){
        if(root == null || root.next == null)
            return root;
        ListNode runner = root;
        ListNode walker = root;
        while(runner != null &amp;amp;&amp;amp; runner.next != null) {
            runner = runner.next.next;
            walker = walker.next;
            if(runner == walker)
                break;
        }
        if(runner == null || runner.next == null)
            return null;
        walker = root;
        while(walker != runner) {
            walker = walker.next;
            runner = runner.next;
        }
        return walker;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Two Sum Count</title>
      <link>http://xmruibi.github.io/2015/11/18/two-sum-count/</link>
      <pubDate>Wed, 18 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/18/two-sum-count/</guid>
      <description>

&lt;p&gt;Given an array and a target number, count how many pair in this array can sum to that target number.&lt;/p&gt;

&lt;h2 id=&#34;solution:4e4f31a8a2c131093d3fe5e1265a3ff0&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution{
	public int countTwoSum(int[] arr, int tar) {
		if(arr == null || arr.length == 0)
			return 0;
		int cnt = 0;
		// store all number in this array
		HashSet&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
		for(int i = 0; i &amp;lt; arr.length; i++) {
			// if any number hit in hashset, that means a pair can sum to the target number
			if(set.contains(tar - arr[i]))
				cnt ++;
			set.add(arr[i]);
		}
		return cnt;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-if-input-integers-has-duplicate:4e4f31a8a2c131093d3fe5e1265a3ff0&#34;&gt;Solution #If input integers has duplicate&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public static int TwoSumCount(int[] nums, int target) {
        if (nums == null || nums.length &amp;lt; 2)    return 0;
        Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;Integer, Integer&amp;gt;();
        int count = 0;
        for (int i = 0; i &amp;lt; nums.length; i++) {
            if (map.containsKey(target - nums[i]))
                count += map.get(target - nums[i]);
            map.put(nums[i], map.containsKey(nums[i]) ? map.get(nums[i]) + 1 : 1);
        }
        return count;
    }
    
    public static void main(String[] args) {
        int rvalue = TwoSumCount(new int[] {1, 1, 2, 3, 4}, 5);
        System.out.println(rvalue);
        return;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>