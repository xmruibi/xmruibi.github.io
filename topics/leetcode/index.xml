<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on Geek Think</title>
    <link>http://xmruibi.github.io/topics/leetcode/</link>
    <description>Recent content in Leetcode on Geek Think</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Fri, 13 Nov 2015 20:40:29 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/topics/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Zigzag Iterator</title>
      <link>http://xmruibi.github.io/2015/11/13/zigzag-iterator/</link>
      <pubDate>Fri, 13 Nov 2015 20:40:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/zigzag-iterator/</guid>
      <description>

&lt;p&gt;Given two 1d vectors, implement an iterator to return their elements alternately.&lt;/p&gt;

&lt;h3 id=&#34;example:c39b4a8138ca1f78be5fe1b3f188b037&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given two 1d vectors:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;v1&lt;/code&gt; = &lt;code&gt;[1, 2]&lt;/code&gt;
&lt;code&gt;v2&lt;/code&gt; = &lt;code&gt;[3, 4, 5, 6]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: &lt;code&gt;[1, 3, 2, 4, 5, 6]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;follow-up:c39b4a8138ca1f78be5fe1b3f188b037&#34;&gt;Follow up&lt;/h3&gt;

&lt;p&gt;What if you are given k 1d vectors? How well can your code be extended to such cases?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Valid Number</title>
      <link>http://xmruibi.github.io/2015/11/13/valid-number/</link>
      <pubDate>Fri, 13 Nov 2015 16:13:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/valid-number/</guid>
      <description>

&lt;p&gt;Validate if a given string is numeric.&lt;/p&gt;

&lt;h3 id=&#34;example:d0ba9336933b8515213de1bc6935949b&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot; 0.1 &amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;1 a&amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;2e10&amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think:d0ba9336933b8515213de1bc6935949b&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This question focus on thinking about all of corner case

&lt;ol&gt;
&lt;li&gt;sign before the number (one sign; two sign)&lt;/li&gt;
&lt;li&gt;space before the number&lt;/li&gt;
&lt;li&gt;invalid character before / after the number&lt;/li&gt;
&lt;li&gt;&amp;lsquo;e&amp;rsquo; or &amp;lsquo;E&amp;rsquo; in the middle of number&lt;/li&gt;
&lt;li&gt;space after the number&lt;/li&gt;
&lt;li&gt;decimal checker&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:d0ba9336933b8515213de1bc6935949b&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public boolean isNumber(String s) {
		if(s == null)
			return false;
        boolean eFlagAllow = true; // switcher for &#39;e&#39; or &#39;E&#39;
        boolean decimal = true; // switcher for &#39;.&#39;
        boolean hasNum = false; // make sure it contains number
        int cursor = 0;
        // skip previous space.
        while(cursor &amp;lt; s.length() &amp;amp;&amp;amp; s.charAt(cursor) == &#39; &#39;)
            cursor++;
            
        // check the sign, only one position allow for &#39;-&#39;
        if(cursor &amp;lt; s.length() &amp;amp;&amp;amp; s.charAt(cursor) == &#39;-&#39;)
            cursor++;
            
        while(cursor &amp;lt; s.length()) {
            char cur = s.charAt(cursor);
            // if has number 
            if(cur &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; cur &amp;lt;= &#39;9&#39;){
                if(!hasNum)
                    hasNum = true;
            }else if((cur == &#39;e&#39; || cur == &#39;E&#39;) &amp;amp;&amp;amp; eFlagAllow &amp;amp;&amp;amp; hasNum) { 
                // previous position should contain the number first 
                eFlagAllow = false; // turn off the e/E switcher
            }else if(cur == &#39;.&#39; &amp;amp;&amp;amp; decimal) {
                // turn off the decimal switcher
                decimal = false;
            }else if(cur != &#39; &#39;) // not allow the char except the space
                return false;
            cursor ++;
        }
        
        return cursor == s.length() &amp;amp;&amp;amp; hasNum;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Expression Add Operators</title>
      <link>http://xmruibi.github.io/2015/11/12/expression-add-operators/</link>
      <pubDate>Thu, 12 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/12/expression-add-operators/</guid>
      <description>

&lt;p&gt;Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.&lt;/p&gt;

&lt;h3 id=&#34;examples:b80d8eb4c261a28dea46a3fd4834483e&#34;&gt;Examples&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;123&amp;quot;, 6 -&amp;gt; [&amp;quot;1+2+3&amp;quot;, &amp;quot;1*2*3&amp;quot;] 
&amp;quot;232&amp;quot;, 8 -&amp;gt; [&amp;quot;2*3+2&amp;quot;, &amp;quot;2+3*2&amp;quot;]
&amp;quot;105&amp;quot;, 5 -&amp;gt; [&amp;quot;1*0+5&amp;quot;,&amp;quot;10-5&amp;quot;]
&amp;quot;00&amp;quot;, 0 -&amp;gt; [&amp;quot;0+0&amp;quot;, &amp;quot;0-0&amp;quot;, &amp;quot;0*0&amp;quot;]
&amp;quot;3456237490&amp;quot;, 9191 -&amp;gt; []
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:b80d8eb4c261a28dea46a3fd4834483e&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;This problem has a lot of edge cases to be considered:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;overflow: we use a long type once it is larger than Integer.MAX_VALUE or minimum, we get over it.&lt;/li&gt;
&lt;li&gt;0 sequence: because we can&amp;rsquo;t have numbers with multiple digits started with zero, we have to deal with it too.&lt;/li&gt;
&lt;li&gt;a little trick is that we should save the value that is to be multiplied in the next recursion.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;solution:b80d8eb4c261a28dea46a3fd4834483e&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {

    public List&amp;lt;String&amp;gt; addOperators(String num, int target) {
        List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        helper(res, &amp;quot;&amp;quot;, num, 0, target, 0L, 0L);
        return res;
    }
    
    private void helper(List&amp;lt;String&amp;gt; res, String cur, String num, int idx, int target, long preVal, long nextVal) {
       if(idx == num.length()) {
            if(preVal == target)
                res.add(new String(cur));
            return;
       }
       
       for(int i = idx; i &amp;lt; num.length(); i++) {
           if(i != idx &amp;amp;&amp;amp; num.charAt(idx) == &#39;0&#39;) break;
           String sbstr = num.substring(idx, i+1);
           long curVal = Long.parseLong(sbstr);
           if(idx == 0)
                helper(res, sbstr, num, i+1, target, curVal, curVal);
           else {
               helper(res, cur + &amp;quot;+&amp;quot; + curVal, num, i+1, target, preVal + curVal,  curVal);
               helper(res, cur + &amp;quot;-&amp;quot; + curVal, num, i+1, target, preVal - curVal, 0 - curVal);
               helper(res, cur + &amp;quot;*&amp;quot; + curVal, num, i+1, target, preVal - nextVal + nextVal * curVal, nextVal * curVal);
           }
       }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find the Celebrity</title>
      <link>http://xmruibi.github.io/2015/11/12/find-the-celebrity/</link>
      <pubDate>Thu, 12 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/12/find-the-celebrity/</guid>
      <description>

&lt;p&gt;Suppose you are at a party with &lt;code&gt;n&lt;/code&gt; people (labeled from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n - 1&lt;/code&gt;) and among them, there may exist one celebrity. The definition of a celebrity is that all the other &lt;code&gt;n - 1&lt;/code&gt; people know him/her but &lt;strong&gt;he/she does not know any of them&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: &amp;ldquo;Hi, A. Do you know B?&amp;rdquo; to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).&lt;/p&gt;

&lt;p&gt;You are given a helper function &lt;code&gt;bool knows(a, b)&lt;/code&gt; which tells you whether A knows B. Implement a function &lt;code&gt;int findCelebrity(n)&lt;/code&gt;, your function should minimize the number of calls to &lt;code&gt;knows&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note:987915e63763fb778a6682d4a9f26f85&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;There will be exactly one celebrity if he/she is in the party. Return the celebrity&amp;rsquo;s label if there is a celebrity in the party. If there is no celebrity, return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think-1:987915e63763fb778a6682d4a9f26f85&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Based graph, check the node with &lt;code&gt;n-1&lt;/code&gt; in-degree and &lt;code&gt;0&lt;/code&gt; out-degree.&lt;/li&gt;
&lt;li&gt;Becuase other &lt;code&gt;n - 1&lt;/code&gt; people know him/her but &lt;strong&gt;he/she does not know any of them&lt;/strong&gt; (&lt;code&gt;0&lt;/code&gt; out-degree)&lt;/li&gt;
&lt;li&gt;Call times: $$O(n^2)$$&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:987915e63763fb778a6682d4a9f26f85&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public int findCelebrity(int n) {
		if (n &amp;lt;= 1)
			return -1;

		int[] inDegree = new int[n];
		int[] outDegree = new int[n];

		// call n^2 times
		for (int i = 0; i &amp;lt; n; i++) {
			for (int j = 0; j &amp;lt; n; j++) {
				if (i != j &amp;amp;&amp;amp; knows(i, j)) {
					outDegree[i]++;
					inDegree[j]++;
				}
			}
		}

		for (int i = 0; i &amp;lt; n; i++) {
			if (inDegree[i] == n - 1 &amp;amp;&amp;amp; outDegree[i] == 0) {
				return i;
			}
		}

		return -1;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2:987915e63763fb778a6682d4a9f26f85&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Iterations from head and rear to the middle(l -&amp;gt; m &amp;lt;- r).&lt;/li&gt;
&lt;li&gt;Two cases when check if [l] knows [r].

&lt;ul&gt;
&lt;li&gt;Left shouldn&amp;rsquo;t be celebrity since he knows someone.&lt;/li&gt;
&lt;li&gt;Right shouldn&amp;rsquo;t be celebrity because one of people doesn&amp;rsquo;t know him.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2:987915e63763fb778a6682d4a9f26f85&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public int findCelebrityII(int n) {
		if (n &amp;lt;= 1)
			return -1;
		
		int left = 0, right = n - 1;
		while (left &amp;lt; right) {
			if (knows(left, right))
				left++; // left shouldn&#39;t be celebrity since he knows someone
			else
				right--; // right shouldn&#39;t be celebrity because one of people doesn&#39;t know him
		}

		// check the potential candidate is celebrity
		for (int i = 0; i &amp;lt; n; i++) {
			if (i == right)
				continue;
			if (knows(right, i))
				return -1;
		}
		return right;
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find the Duplicate Number</title>
      <link>http://xmruibi.github.io/2015/11/12/find-the-duplicate-number/</link>
      <pubDate>Thu, 12 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/12/find-the-duplicate-number/</guid>
      <description>

&lt;p&gt;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.&lt;/p&gt;

&lt;h3 id=&#34;note:51072b7754d767e44ab1a140653d075f&#34;&gt;Note&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;You must not modify the array (assume the array is read only).&lt;/li&gt;
&lt;li&gt;You must use only constant, O(1) extra space.&lt;/li&gt;
&lt;li&gt;Your runtime complexity should be less than $$O(n^2)$$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is only one duplicate number in the array, but it could be repeated more than once.&lt;/p&gt;

&lt;h2 id=&#34;think-1:51072b7754d767e44ab1a140653d075f&#34;&gt;Think #1&lt;/h2&gt;

&lt;h5 id=&#34;pigeonhole-principle:51072b7754d767e44ab1a140653d075f&#34;&gt;Pigeonhole Principle&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Split the array into two pieces by the middle point.&lt;/li&gt;
&lt;li&gt;NOTE: an array nums containing &lt;code&gt;n + 1&lt;/code&gt; integers where each integer is between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; (inclusive).&lt;/li&gt;
&lt;li&gt;Let&amp;rsquo;s say if there is &lt;code&gt;10&lt;/code&gt; elements in array. The index of middle point is &lt;code&gt;4&lt;/code&gt;. Check the all elements and count how many element has the value less or equal to that index. If the counter larger than index value and according to Pigeonhole Priciple,  that means there must have number duplicated in the first half of searching range. So next time we search the first half. Otherwise, we check the last half part.&lt;/li&gt;
&lt;li&gt;NOTICE: each time we decrease the search range but still check the number in entire array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:51072b7754d767e44ab1a140653d075f&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int findDuplicate(int[] nums) {
        int l = 0, r = nums.length - 1;
        while(l &amp;lt; r) {
            int m = l + ((r - l) &amp;gt;&amp;gt; 1);
            int cnt = 0;
            for(int i : nums)
                if(i &amp;lt;= m)
                    cnt++;
            if(cnt &amp;lt;= m)
                l = m + 1;
            else
                r = m;
        }
        return l;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Integer to English Words</title>
      <link>http://xmruibi.github.io/2015/11/12/integer-to-english-words/</link>
      <pubDate>Thu, 12 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/12/integer-to-english-words/</guid>
      <description>

&lt;p&gt;Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.&lt;/p&gt;

&lt;h3 id=&#34;example:59e47c662cbbe0ed988b094d690a4b1b&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;123&lt;/code&gt; -&amp;gt; &lt;code&gt;&amp;quot;One Hundred Twenty Three&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;12345&lt;/code&gt; -&amp;gt; &lt;code&gt;&amp;quot;Twelve Thousand Three Hundred Forty Five&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1234567&lt;/code&gt; -&amp;gt; &lt;code&gt;&amp;quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;hint:59e47c662cbbe0ed988b094d690a4b1b&#34;&gt;Hint&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Did you see a pattern in dividing the number into chunk of words? For example, 123 and 123000.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Group the number by thousands (3 digits). You can write a helper function that takes a number less than 1000 and convert just that chunk to words.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There are many edge cases. What are some good test cases? Does your code work with input such as &lt;code&gt;0&lt;/code&gt; ? Or &lt;code&gt;1000010&lt;/code&gt;? (middle chunk is zero and should not be printed out)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;think:59e47c662cbbe0ed988b094d690a4b1b&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The regular pattern in English word to count number is splitting by &lt;code&gt;1000&lt;/code&gt;, so set each &lt;code&gt;000.&lt;/code&gt; by &lt;code&gt;&amp;quot;Thousand &amp;quot;, &amp;quot;Million &amp;quot;, &amp;quot;Billion &amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Be aware to number less than &lt;code&gt;20&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:59e47c662cbbe0ed988b094d690a4b1b&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    private final String[] lessThan20 = {&amp;quot;&amp;quot;, &amp;quot;One &amp;quot;, &amp;quot;Two &amp;quot;, &amp;quot;Three &amp;quot;, &amp;quot;Four &amp;quot;, &amp;quot;Five &amp;quot;, &amp;quot;Six &amp;quot;, &amp;quot;Seven &amp;quot;, &amp;quot;Eight &amp;quot;, &amp;quot;Nine &amp;quot;, &amp;quot;Ten &amp;quot;, &amp;quot;Eleven &amp;quot;, &amp;quot;Twelve &amp;quot;, &amp;quot;Thirteen &amp;quot;, &amp;quot;Fourteen &amp;quot;, &amp;quot;Fifteen &amp;quot;, &amp;quot;Sixteen &amp;quot;, &amp;quot;Seventeen &amp;quot;, &amp;quot;Eighteen &amp;quot;, &amp;quot;Nineteen &amp;quot;};
    private final String[] tens = {&amp;quot;&amp;quot;, &amp;quot;Ten &amp;quot;, &amp;quot;Twenty &amp;quot;, &amp;quot;Thirty &amp;quot;, &amp;quot;Forty &amp;quot;, &amp;quot;Fifty &amp;quot;, &amp;quot;Sixty &amp;quot;, &amp;quot;Seventy &amp;quot;, &amp;quot;Eighty &amp;quot;, &amp;quot;Ninety &amp;quot;};
    private final String[] thousands = {&amp;quot;&amp;quot;, &amp;quot;Thousand &amp;quot;, &amp;quot;Million &amp;quot;, &amp;quot;Billion &amp;quot;};

    public String numberToWords(int num) {
        if (num == 0)
            return &amp;quot;Zero&amp;quot;;
        int i = 0;
        String words = &amp;quot;&amp;quot;;
        
        while(num &amp;gt; 0) {
            if (num % 1000 != 0)
                words = eachThousand(num % 1000)+ thousands[i] + words;
            num /= 1000;
            i++;
        }
        return words.trim();
    }
    
    private String eachThousand(int each) {
        StringBuilder sb = new StringBuilder();
        if(each / 100 &amp;gt; 0) {
            sb.append(lessThan20[each / 100] + &amp;quot;Hundred &amp;quot;);
        }
        int ten = each % 100;
        if(ten &amp;gt;= 20) {
            sb.append(tens[ten/10]);
            sb.append(lessThan20[ten%10]);
        }else {
            sb.append(lessThan20[ten]);
        }
        return sb.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Unique Word Abbreviation</title>
      <link>http://xmruibi.github.io/2015/11/12/unique-word-abbreviation/</link>
      <pubDate>Thu, 12 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/12/unique-word-abbreviation/</guid>
      <description>

&lt;p&gt;An abbreviation of a word follows the form &lt;code&gt;&amp;lt;first letter&amp;gt;&amp;lt;number&amp;gt;&amp;lt;last letter&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Below are some examples of word abbreviations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    a) it                      --&amp;gt; it    (no abbreviation)
    
         1
    b) d|o|g                   --&amp;gt; d1g
    
                  1    1  1
         1---5----0----5--8
    c) i|nternationalizatio|n  --&amp;gt; i18n
    
                  1
         1---5----0
    d) l|ocalizatio|n          --&amp;gt; l10n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word&amp;rsquo;s abbreviation is unique if no other word from the dictionary has the same abbreviation.&lt;/p&gt;

&lt;h3 id=&#34;example:a71989791a51f811869cd70e5706cbbe&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given dictionary = [ &amp;ldquo;deer&amp;rdquo;, &amp;ldquo;door&amp;rdquo;, &amp;ldquo;cake&amp;rdquo;, &amp;ldquo;card&amp;rdquo; ]&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isUnique(&amp;quot;dear&amp;quot;)&lt;/code&gt; -&amp;gt; &lt;code&gt;false&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isUnique(&amp;quot;cart&amp;quot;)&lt;/code&gt; -&amp;gt; &lt;code&gt;true&lt;/code&gt; ;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isUnique(&amp;quot;cane&amp;quot;)&lt;/code&gt; -&amp;gt; &lt;code&gt;false&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isUnique(&amp;quot;make&amp;quot;)&lt;/code&gt; -&amp;gt; &lt;code&gt;true&lt;/code&gt;;&lt;/p&gt;

&lt;h2 id=&#34;think:a71989791a51f811869cd70e5706cbbe&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Save dictionary words in a set&lt;/li&gt;
&lt;li&gt;Save the abbreviation from dictionary word to a HashMap.&lt;/li&gt;
&lt;li&gt;HashMap has the key with abbreviation and value with the original word&lt;/li&gt;
&lt;li&gt;check &lt;code&gt;isUnique(word)&lt;/code&gt; by make abbreviation from that word and compare with the hashmap&lt;/li&gt;
&lt;li&gt;If hashmap doesn&amp;rsquo;t contain that word, return true.&lt;/li&gt;
&lt;li&gt;If hashmap contains that word, we should compare if the word is equal to the word saved in hashmap.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:a71989791a51f811869cd70e5706cbbe&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UniqueWordAbbreviation {

	Set&amp;lt;String&amp;gt; dict = new HashSet&amp;lt;&amp;gt;(); // keep the dictionary has unique words
	Map&amp;lt;String, String&amp;gt; abbrDict = new HashMap&amp;lt;&amp;gt;();

	public UniqueWordAbbreviation(String[] dictionary) {
		for (String str : dictionary) {
			if (dict.contains(str))
				continue;
			String abbr = makeAbbr(str);
			if (!abbrDict.containsKey(abbr))
				abbrDict.put(abbr, str);
			else
				abbrDict.put(abbr, &amp;quot;&amp;quot;);
			dict.add(str);
		}
	}

	public boolean isUnique(String word) {
		String abbr = makeAbbr(word);
		if (abbrDict.containsKey(abbr))
			return word.equals(abbrDict.get(abbr));
		return true;
	}

    private String makeAbbr(String str) {
		if (str == null || str.length() &amp;lt;= 2)
			return str;
		int mid = str.length() - 2;
		StringBuilder sb = new StringBuilder();
		sb.append(str.charAt(0));
		sb.append(mid);
		sb.append(str.charAt(str.length() - 1));
		return sb.toString();
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Flip Game I/II</title>
      <link>http://xmruibi.github.io/2015/11/11/flip-game-i/ii/</link>
      <pubDate>Wed, 11 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/11/flip-game-i/ii/</guid>
      <description>

&lt;p&gt;You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two &lt;strong&gt;consecutive&lt;/strong&gt; &lt;code&gt;&amp;quot;++&amp;quot;&lt;/code&gt; into &lt;code&gt;&amp;quot;--&amp;quot;&lt;/code&gt;. The game ends when a person can no longer make a move and therefore the other person will be the winner.
Write a function to compute all possible states of the string after one valid move.&lt;/p&gt;

&lt;p&gt;For example, given &lt;code&gt;s = &amp;quot;++++&amp;quot;&lt;/code&gt;, after one move, it may become one of the following states:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  &amp;quot;--++&amp;quot;,
  &amp;quot;+--+&amp;quot;,
  &amp;quot;++--&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there is no valid move, return an empty list &lt;code&gt;[]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;think:d6c15e48f4096e230090b0674ad8ed6d&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Only consecutive &lt;code&gt;&amp;quot;++&amp;quot;&lt;/code&gt; can be flipped.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution:d6c15e48f4096e230090b0674ad8ed6d&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public List&amp;lt;String&amp;gt; generatePossibleNextMoves(String s) {
		List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
		if (s == null || s.length() &amp;lt; 2) {
            return res;
        }
		for (int i = 1; i &amp;lt; s.length(); i++) {
			StringBuilder sb = new StringBuilder(s);
			if (s.charAt(i) == &#39;+&#39; &amp;amp;&amp;amp; s.charAt(i - 1) == s.charAt(i)) {
				sb.insert(i - 1, &#39;-&#39;);
				sb.insert(i, &#39;-&#39;);
			}
			res.add(sb.toString());
		}
		return res;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii:d6c15e48f4096e230090b0674ad8ed6d&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two &lt;strong&gt;consecutive&lt;/strong&gt; &lt;code&gt;&amp;quot;++&amp;quot;&lt;/code&gt; into &lt;code&gt;&amp;quot;--&amp;quot;&lt;/code&gt;. The game ends when a person can no longer make a move and therefore the other person will be the winner.&lt;/p&gt;

&lt;p&gt;Write a function to determine if the starting player can guarantee a win.&lt;/p&gt;

&lt;p&gt;For example, given &lt;code&gt;s = &amp;quot;++++&amp;quot;&lt;/code&gt;, return true. The starting player can guarantee a win by flipping the middle &lt;code&gt;&amp;quot;++&amp;quot;&lt;/code&gt; to become &lt;code&gt;&amp;quot;+--+&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;follow:d6c15e48f4096e230090b0674ad8ed6d&#34;&gt;Follow&lt;/h4&gt;

&lt;p&gt;Derive your algorithm&amp;rsquo;s run-time complexity.&lt;/p&gt;

&lt;h3 id=&#34;think-1:d6c15e48f4096e230090b0674ad8ed6d&#34;&gt;Think&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Backtracking seems to be the only feasible solution to this problem.&lt;/li&gt;
&lt;li&gt;We can basically try every possible move for the first player (P1), and recursively check if the second player has any chance to win.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-1:d6c15e48f4096e230090b0674ad8ed6d&#34;&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public static boolean canWin(String s) {
		return winHelper(s.toCharArray());
	}

	private static boolean winHelper(char[] chars) {
		for (int i = 1; i &amp;lt; chars.length; i++) {
			if (chars[i] == &#39;+&#39; &amp;amp;&amp;amp; chars[i] == chars[i - 1]) {
				chars[i - 1] = &#39;-&#39;;
				chars[i] = &#39;-&#39;;
			// if sencond player have chance to win
				boolean win = !winHelper(chars);
				chars[i - 1] = &#39;+&#39;;
				chars[i] = &#39;+&#39;;
				if (win) 
                    return true;
			}
		}
		return false;
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>H-Index</title>
      <link>http://xmruibi.github.io/2015/11/11/h-index/</link>
      <pubDate>Wed, 11 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/11/h-index/</guid>
      <description>

&lt;p&gt;Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher&amp;rsquo;s h-index.&lt;/p&gt;

&lt;p&gt;According to the definition of h-index on Wikipedia: &amp;ldquo;A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;For example, given citations = &lt;code&gt;[3, 0, 6, 1, 5]&lt;/code&gt;, which means the researcher has &lt;code&gt;5&lt;/code&gt; papers in total and each of them had received &lt;code&gt;3, 0, 6, 1, 5&lt;/code&gt; citations respectively. Since the researcher has &lt;code&gt;3&lt;/code&gt; papers with at least &lt;code&gt;3&lt;/code&gt; citations each and the remaining two with no more than &lt;code&gt;3&lt;/code&gt; citations each, his h-index is &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;If there are several possible values for h, the maximum one is taken as the h-index.&lt;/p&gt;

&lt;h3 id=&#34;hint:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Hint&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;An easy approach is to sort the array first.&lt;/li&gt;
&lt;li&gt;What are the possible values of h-index?&lt;/li&gt;
&lt;li&gt;A faster approach is to use extra space.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;think-1:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Sort first (takes $$O(n \times log{n})$$)&lt;/li&gt;
&lt;li&gt;Set a &lt;code&gt;h&lt;/code&gt; variable, increase &lt;code&gt;h&lt;/code&gt; to &lt;code&gt;length - currentIdx&lt;/code&gt; when current element&amp;rsquo;s value is equals or larger than &lt;code&gt;length - currentIdx&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int hIndex(int[] citations) {
        if(citations == null || citations.length == 0)
            return 0;
        Arrays.sort(citations);
        int h = 0;
        for(int i = 0; i &amp;lt; citations.length; i++) {
            if(citations[i] &amp;gt;= citations.length - i)
                h = Math.max(h, citations.length - i);
        }
        return h;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Extra Space&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int hIndex(int[] citations) {
        if(citations == null || citations.length == 0)
            return 0;
        int[] memo = new int[citations.length + 1];
        for(int i = 0; i &amp;lt; citations.length; i++) {
            if(citations[i] &amp;gt;= memo.length)
                memo[memo.length - 1] ++;
            else
                memo[citations[i]]++;
        }

        for(int i = memo.length - 1; i &amp;gt;= 0; i--) {
            if(i &amp;lt; memo.length - 1)
                memo[i] += memo[i+1];
            if(memo[i] &amp;gt;= i)
                return i;
        }
        return 0;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-3:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Think #3&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Sort and Binary Search&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-3:368830646b62ee3e3ed386f64083e3ce&#34;&gt;Solution #3&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int hIndex(int[] citations) {
        if(citations == null || citations.length == 0)
            return 0;
        int l = 0, r = citations.length - 1;
        while(l + 1 &amp;lt; r) {
            int m = l + ((r - l) &amp;gt;&amp;gt; 1);
            if(citations[m] == citations.length - m)
                return citations.length - m;
            else if(citations[m] &amp;lt; citations.length - m)
                l = m;
            else
                r = m;
        }
        if(citations[l] &amp;gt;= citations.length - l)
            return citations.length - l;   // this is larger
        if(citations[r] &amp;gt;= citations.length - r)
            return citations.length - r;
    
        return 0;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Move Zeroes</title>
      <link>http://xmruibi.github.io/2015/11/11/move-zeroes/</link>
      <pubDate>Wed, 11 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/11/move-zeroes/</guid>
      <description>

&lt;p&gt;Given an array nums, write a function to move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;

&lt;p&gt;For example, given nums = &lt;code&gt;[0, 1, 0, 3, 12]&lt;/code&gt;, after calling your function, nums should be &lt;code&gt;[1, 3, 12, 0, 0]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note:48a830997c7d9feb48b62c53bd2152a6&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;You must do this in-place without making a copy of the array.
Minimize the total number of operations.&lt;/p&gt;

&lt;h2 id=&#34;think:48a830997c7d9feb48b62c53bd2152a6&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Mark an index for nonzero element&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:48a830997c7d9feb48b62c53bd2152a6&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public void moveZeroes(int[] nums) {
        int nonzeroIdx = 0;
        int idx = 0;
        while(idx &amp;lt; nums.length) {
            if(idx &amp;gt;= nonzeroIdx &amp;amp;&amp;amp; nums[idx] != 0) {
                int tmp = nums[idx];
                nums[idx--] = nums[nonzeroIdx];
                nums[nonzeroIdx++] = tmp;
            }
            idx++;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Nim Game</title>
      <link>http://xmruibi.github.io/2015/11/11/nim-game/</link>
      <pubDate>Wed, 11 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/11/nim-game/</guid>
      <description>

&lt;p&gt;You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.&lt;/p&gt;

&lt;p&gt;Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.&lt;/p&gt;

&lt;p&gt;For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.&lt;/p&gt;

&lt;h3 id=&#34;hint:0aace8da72e32a0839e02ab0612ed2e5&#34;&gt;Hint&lt;/h3&gt;

&lt;p&gt;If there are 5 stones in the heap, could you figure out a way to remove the stones such that you will always be the winner?&lt;/p&gt;

&lt;h2 id=&#34;think:0aace8da72e32a0839e02ab0612ed2e5&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Similar with the Coin in A Line I&lt;/li&gt;
&lt;li&gt;The death number will be the multiply of &lt;code&gt;the max amount your can taken +1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;So just check if the total amount is the multiply of &lt;code&gt;4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;proof:0aace8da72e32a0839e02ab0612ed2e5&#34;&gt;Proof:&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;the base case: when &lt;code&gt;n&lt;/code&gt; = &lt;code&gt;4&lt;/code&gt;, as suggested by the hint from the problem, no matter which number that that first player, the second player would always be able to pick the remaining number.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;For &lt;code&gt;1 x 4&lt;/code&gt; &amp;lt; &lt;code&gt;n&lt;/code&gt; &amp;lt; &lt;code&gt;2 x 4&lt;/code&gt;, (&lt;code&gt;n&lt;/code&gt; = &lt;code&gt;5, 6, 7&lt;/code&gt;), the first player can reduce the initial number into 4 accordingly, which will leave the death number 4 to the second player. i.e. The numbers &lt;code&gt;5, 6, 7&lt;/code&gt; are winning numbers for any player who got it first.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now to the beginning of the next cycle, n = 8, no matter which number that the first player picks, it would always leave the winning numbers (5, 6, 7) to the second player. Therefore, &lt;code&gt;8 % 4 == 0&lt;/code&gt;, again is a death number.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Following the second case, for numbers between &lt;code&gt;(2 x 4 = 8)&lt;/code&gt; and &lt;code&gt;(3 x 4=12)&lt;/code&gt;, which are &lt;code&gt;9&lt;/code&gt;,&lt;code&gt;10&lt;/code&gt;, &lt;code&gt;11&lt;/code&gt;, are winning numbers for the first player again, because the first player can always reduce the number into the death number 8.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;solution:0aace8da72e32a0839e02ab0612ed2e5&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public boolean canWinNim(int n) {
        return n%4 != 0;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Query Range Sum on Array</title>
      <link>http://xmruibi.github.io/2015/11/11/query-range-sum-on-array/</link>
      <pubDate>Wed, 11 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/11/query-range-sum-on-array/</guid>
      <description>

&lt;p&gt;Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.&lt;/p&gt;

&lt;h3 id=&#34;example:26e685b3d16b25a213adc00d0a48995a&#34;&gt;Example:&lt;/h3&gt;

&lt;p&gt;Given nums = [-2, 0, 3, -5, 2, -1]&lt;/p&gt;

&lt;p&gt;sumRange(0, 2) -&amp;gt; 1
sumRange(2, 5) -&amp;gt; -1
sumRange(0, 5) -&amp;gt; -3
Note:
You may assume that the array does not change.
There are many calls to sumRange function.&lt;/p&gt;

&lt;h2 id=&#34;think:26e685b3d16b25a213adc00d0a48995a&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Save the prefix sum in extra array.&lt;/li&gt;
&lt;li&gt;Be aware to the &lt;code&gt;sum[0]&lt;/code&gt; means nothing before the first element of input array &lt;code&gt;nums&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;return the the difference on prefix index &lt;code&gt;[high] - [low - 1]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:26e685b3d16b25a213adc00d0a48995a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NumArray {
    int[] sum;
    
    public NumArray(int[] nums) {
        sum = new int[nums.length + 1];
        for(int i = 1; i &amp;lt;= nums.length; i++) {
            sum[i] = nums[i-1] + sum[i-1];
        }
    }

    public int sumRange(int i, int j) {
        return sum[j+1]-sum[i];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Walls and Gates</title>
      <link>http://xmruibi.github.io/2015/11/11/walls-and-gates/</link>
      <pubDate>Wed, 11 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/11/walls-and-gates/</guid>
      <description>

&lt;p&gt;You are given a m x n 2D grid initialized with these three possible values.&lt;/p&gt;

&lt;p&gt;-1 - A wall or an obstacle.
0 - A gate.
INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.&lt;/p&gt;

&lt;p&gt;Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.
For example, given the 2D grid:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    INF  -1  0  INF
    INF INF INF  -1
    INF  -1 INF  -1
      0  -1 INF INF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After running your function, the 2D grid should be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    3  -1   0   1
    2   2   1  -1
    1  -1   2  -1
    0  -1   3   4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:462b13a16adabd0b713df96bb174b231&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;It is very classic backtracking problem.&lt;/li&gt;
&lt;li&gt;We can start from each gate (0 point), and searching for its neighbors.&lt;/li&gt;
&lt;li&gt;We can either use DFS or BFS solution.&lt;/li&gt;
&lt;li&gt;Here I gave the BFS solution&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:462b13a16adabd0b713df96bb174b231&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static void wallsAndGates(int[][] rooms) {
        for (int i = 0; i &amp;lt; rooms.length; i++) {
            for (int j = 0; j &amp;lt; rooms[i].length; j++) {
                if (rooms[i][j] == 0)
                    bfs(rooms, i, j, i, j, 0);
            }
        }
    }

    private static void bfs(int[][] rooms, int x, int y, int px, int py,
            int level) {

        if (rooms[x][y] &amp;gt;= 0) {
            if (rooms[x][y] &amp;lt; level)
                return;
            rooms[x][y] = level;
        } else
            return;

        int[] xs = { -1, 0, 0, 1 };
        int[] ys = { 0, 1, -1, 0 };
        for (int i = 0; i &amp;lt; 4; i++) {
            int nx = xs[i] + x;
            int ny = ys[i] + y;
            if (nx &amp;lt; 0 || nx &amp;gt;= rooms.length || ny &amp;lt; 0
                    || ny &amp;gt;= rooms[nx].length || (nx == px &amp;amp;&amp;amp; ny == py))
                continue;
            bfs(rooms, nx, ny, x, y, level + 1);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Bull and Cows</title>
      <link>http://xmruibi.github.io/2015/11/10/bull-and-cows/</link>
      <pubDate>Tue, 10 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/10/bull-and-cows/</guid>
      <description>

&lt;p&gt;You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called &lt;code&gt;&amp;quot;bulls&amp;quot;&lt;/code&gt;) and how many digits match the secret number but locate in the wrong position (called &lt;code&gt;&amp;quot;cows&amp;quot;&lt;/code&gt;). Your friend will use successive guesses and hints to eventually derive the secret number.&lt;/p&gt;

&lt;h3 id=&#34;example:3db9a7391ad6c01d56b4bb1ec63fc398&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Secret number:  &amp;quot;1807&amp;quot;
Friend&#39;s guess: &amp;quot;7810&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;1&lt;/code&gt; bull and &lt;code&gt;3&lt;/code&gt; cows. (The bull is &lt;code&gt;8&lt;/code&gt;, the cows are &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;7&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Write a function to return a hint according to the secret number and friend&amp;rsquo;s guess, use &lt;code&gt;A&lt;/code&gt; to indicate the bulls and &lt;code&gt;B&lt;/code&gt; to indicate the cows. In the above example, your function should return &lt;code&gt;&amp;quot;1A3B&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Please note that both secret number and friend&amp;rsquo;s guess may contain duplicate digits, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Secret number:  &amp;quot;1123&amp;quot;
Friend&#39;s guess: &amp;quot;0111&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the 1st 1 in friend&amp;rsquo;s &lt;code&gt;guess&lt;/code&gt; is a bull, the 2nd or 3rd 1 is a cow, and your function should return &lt;code&gt;&amp;quot;1A1B&amp;quot;&lt;/code&gt;.
You may assume that the secret number and your friend&amp;rsquo;s guess only contain digits, and their lengths are always equal.&lt;/p&gt;

&lt;h2 id=&#34;think:3db9a7391ad6c01d56b4bb1ec63fc398&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s pretty tricky to think about one pass solution without HashMap.&lt;br /&gt;
Here are some pattern we should notice.
    1. Every character in string is number &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt;
    2. Number in &lt;code&gt;guess&lt;/code&gt; and &lt;code&gt;secret&lt;/code&gt; should also be recorded during the pass
    3. Avoid duplicate is tough&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Solve it by set a int array with length of 10 for counting&lt;/li&gt;
&lt;li&gt;meet a number in &lt;code&gt;guess&lt;/code&gt; do a minus on &lt;code&gt;arr[guess_digit]&lt;/code&gt; while meet a number in &lt;code&gt;secrett&lt;/code&gt; do a addition on &lt;code&gt;arr[secret_digit]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;check &lt;code&gt;arr[secret_digit]&lt;/code&gt; if it is negative, which means that number should existed in &lt;code&gt;guess&lt;/code&gt; number&lt;/li&gt;
&lt;li&gt;check &lt;code&gt;arr[guess_digit]&lt;/code&gt; if it is negative, which means that number should existed in &lt;code&gt;secret&lt;/code&gt; number&lt;/li&gt;
&lt;li&gt;when iteration on number is the same from &lt;code&gt;guess&lt;/code&gt; and &lt;code&gt;secret&lt;/code&gt; numbers, that should be the &lt;code&gt;bull&lt;/code&gt; but without any modification on counting array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:3db9a7391ad6c01d56b4bb1ec63fc398&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public String getHint(String secret, String guess) {
        int cntA = 0;
        int cntB = 0;
        int[] valIdx = new int[10];
        for(int i = 0; i &amp;lt; secret.length(); i++) {
            int sIdx = secret.charAt(i) - &#39;0&#39;;
            int gIdx = guess.charAt(i) - &#39;0&#39;;
            if(gIdx == sIdx)
                cntA++;
            else{ 
                if(valIdx[sIdx] &amp;lt; 0) 
                    cntB++;
                if(valIdx[gIdx] &amp;gt; 0) 
                    cntB++;
            }
            valIdx[sIdx]++;
            valIdx[gIdx]--;
        }
        return &amp;quot;&amp;quot; + cntA + &amp;quot;A&amp;quot; + cntB + &amp;quot;B&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Encode and Decode String</title>
      <link>http://xmruibi.github.io/2015/11/10/encode-and-decode-string/</link>
      <pubDate>Tue, 10 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/10/encode-and-decode-string/</guid>
      <description>

&lt;p&gt;Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.&lt;/p&gt;

&lt;p&gt;Machine 1 (sender) has the function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String encode(String[] strs) {
  // ... your code
  return encoded_string;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Machine 2 (receiver) has the function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String[] decode(String s) {
  //... your code
  return strs;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So Machine 1 does:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String encoded_string = encode(strs);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and Machine 2 does:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String[] strs2 = decode(encoded_string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;strs2&lt;/code&gt; in Machine 2 should be the same as &lt;code&gt;strs&lt;/code&gt; in Machine 1.&lt;/p&gt;

&lt;p&gt;Implement the encode and decode methods.&lt;/p&gt;

&lt;h3 id=&#34;note:784b24ea42273a6937579e186ff79201&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters.&lt;/p&gt;

&lt;p&gt;Do not use class &lt;strong&gt;member / global / static variables&lt;/strong&gt; to store states. Your encode and decode algorithms should be &lt;strong&gt;stateless&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Do not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm.&lt;/p&gt;

&lt;h2 id=&#34;think:784b24ea42273a6937579e186ff79201&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;In theoretic way, there should be nothing can do separation for Strings&lt;/li&gt;
&lt;li&gt;So just make the encode as adding the length of word and &amp;ldquo;#&amp;rdquo; before the word&lt;/li&gt;
&lt;li&gt;Decode function should be carefully designed&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:784b24ea42273a6937579e186ff79201&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class EncodeDecodeString {
	public String encode(List&amp;lt;String&amp;gt; strs) {
		StringBuilder sb = new StringBuilder();
		for (String str : strs) {
			sb.append(str.length());
			sb.append(&amp;quot;#&amp;quot;);
			sb.append(str);
		}

		return sb.toString();
	}

	public List&amp;lt;String&amp;gt; decode(String str) {
		List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
		int strlen = 0;
		for (int i = 0; i &amp;lt; str.length(); i++) {
			char cur = str.charAt(i);
			if (cur == &#39;#&#39; &amp;amp;&amp;amp; strlen &amp;gt; 0) {
				StringBuilder sb = new StringBuilder();
				while (strlen &amp;gt; 0 &amp;amp;&amp;amp; i &amp;lt; str.length()) {
					sb.append(str.charAt(++i));
					strlen--;
				}
				list.add(sb.toString());
			} else
				strlen = strlen * 10 + (cur - &#39;0&#39;);
		}
		return list;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>