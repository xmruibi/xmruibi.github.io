<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on Geek Think</title>
    <link>http://xmruibi.github.io/topics/leetcode/</link>
    <description>Recent content in Leetcode on Geek Think</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Sun, 15 Nov 2015 13:11:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/topics/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Pow() and Sqrt()</title>
      <link>http://xmruibi.github.io/2015/11/15/pow-and-sqrt/</link>
      <pubDate>Sun, 15 Nov 2015 13:11:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/15/pow-and-sqrt/</guid>
      <description>

&lt;p&gt;Write function to get the power &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt; and the square root of &lt;code&gt;x&lt;/code&gt;;&lt;/p&gt;

&lt;h2 id=&#34;solution-pow:8f114c26f536717def87e4afa082746d&#34;&gt;Solution # Pow&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	// basic  
	public float pow(float x, int n) {
	    if(n==0)
            return 1.0;
		if (n == 1)
			return x;
		if (n % 2 == 0)
			return pow(x, n / 2) * pow(x, n / 2);
		else
			return x * pow(x, n / 2) * pow(x, n / 2);
	}

	// improved
	public double pow(double x, int n) {
        if(n==0)
            return 1.0;
        boolean neg = false;
        if(n&amp;lt;0)
            neg = true;
        double res = 1.0;
        while(n != 0){
            if(n%2 != 0){
                res *= x;
            }
            x *= x;
            n /= 2;
        }
        return neg?1.0/res:res;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-sqrt:8f114c26f536717def87e4afa082746d&#34;&gt;Solution # Sqrt&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public float sqrt(float n) {
        float low = 0, high = n;
        float mid = low + (high - low) / 2;
        while (Math.abs(mid * mid - n) &amp;gt; 0.00001) {
            if (mid * mid &amp;lt; n)
                low = mid;
            else if (mid * mid &amp;gt; n)
                high = mid;
            mid = low + (high - low) / 2;
        }
        return mid;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Isomorphic Pair</title>
      <link>http://xmruibi.github.io/2015/11/14/isomorphic-pair/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/isomorphic-pair/</guid>
      <description>

&lt;p&gt;Given two words as Strings, determine if they are isomorphic. Two words are called isomorphic if the letters in one word can be remapped to get the second word. Remapping a letter means replacing all occurrences of it with another letter while the ordering of the letters remains unchanged. No two letters may map to the same letter, but a letter may map to itself.&lt;/p&gt;

&lt;h2 id=&#34;think-1:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Two Hashmap for mapping A-B and B-A.&lt;/li&gt;
&lt;li&gt;make sure both mapping are correct if any character appear in its corresponding mapping.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public boolean isomorphicString(String str1, String str2) {
		if (str1 == null || str2 == null || str1.length() != str2.length())
			return false;
		HashMap&amp;lt;Character, Character&amp;gt; mapAB = new HashMap&amp;lt;&amp;gt;();
		HashMap&amp;lt;Character, Character&amp;gt; mapBA = new HashMap&amp;lt;&amp;gt;();
		for (int i = 0; i &amp;lt; str1.length(); i++) {
			char a = str1.charAt(i);
			char b = str2.charAt(i);
			if (!mapAB.containsKey(a) &amp;amp;&amp;amp; !mapBA.containsKey(b)) {
				mapAB.put(a, b);
				mapBA.put(b, a);
			} else {
				if (mapAB.containsKey(a) &amp;amp;&amp;amp; mapAB.get(a) != b)
					return false;
				if (mapBA.containsKey(b) &amp;amp;&amp;amp; mapBA.get(b) != a)
					return false;
			}
		}
		return true;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;One Hashmap&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public boolean isomorphicStringII(String str1, String str2) {
		if ((str1 == null &amp;amp;&amp;amp; str2 == null)
				|| (str1.length() == 0 &amp;amp;&amp;amp; str2.length() == 0)
				|| str1.equals(str2))
			return true;
		if (str1 == null || str2 == null || str1.length() != str2.length())
			return false;
		HashMap&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
		int i = 0;
		while (i &amp;lt; str1.length()) {
			char a = str1.charAt(i);
			char b = str2.charAt(i);
			if (map.containsKey(a)) {
				if (map.get(a) != b)
					return false;
			} else {
				if (map.containsValue(b))
					return false;
				map.put(a, b);
			}
			i++;
		}
		return true;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-3:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Think #3&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Integer Array with 512 length&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-3:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Solution #3&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public boolean isIsomorphic(String s1, String s2) {
        int[] m = new int[512];
        for (int i = 0; i &amp;lt; s1.length(); i++) {
            if (m[s1.charAt(i)] != m[s2.charAt(i)+256]) 
                return false;
            m[s1.charAt(i)] = m[s2.charAt(i)+256] = i+1;
        }
        return true;	
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Maximum Subarray of Sum / Product</title>
      <link>http://xmruibi.github.io/2015/11/14/maximum-subarray-of-sum-/-product/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/maximum-subarray-of-sum-/-product/</guid>
      <description>

&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest sum.&lt;/p&gt;

&lt;p&gt;For example, given the array &lt;code&gt;[−2,1,−3,4,−1,2,1,−5,4]&lt;/code&gt;,
the contiguous subarray &lt;code&gt;[4,−1,2,1]&lt;/code&gt; has the largest sum = &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int maxSubArray(int[] arr) {
        int maxSum = Integer.MIN_VALUE;
		int curSum = 0;
		for (int i = 0; i &amp;lt; arr.length; i++) {
			curSum += arr[i];
			maxSum = Math.max(maxSum, curSum);
			if (curSum &amp;lt; 0)
				curSum = 0;
		}
		return maxSum;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-record-index:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution #Record Index&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int[] maxSubArray(int[] arr) {
        int maxSum = Integer.MIN_VALUE;
		int curSum = 0;
		int prev = 0, l = 0, r = 0;
		for (int i = 0; i &amp;lt; arr.length; i++) {
			curSum += arr[i];
			if(curSum &amp;gt; maxSum) {
				maxSum = curSum;
				l = prev;
				r = i;
			}
			if (curSum &amp;lt; 0) {
				curSum = 0;
				prev = i + 1;
			}
		}
		return new int[]{l, r};
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest product.&lt;/p&gt;

&lt;p&gt;For example, given the array &lt;code&gt;[2,3,-2,4]&lt;/code&gt;,
the contiguous subarray &lt;code&gt;[2,3]&lt;/code&gt; has the largest product = &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution-1:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int maxProduct(int[] nums) {
        int glMax = Integer.MIN_VALUE;
        
        int localMin = 1; // record the current max
        int localMax = 1; // record the current min, since the negative number multiply with current number may leads to next product as the positive max
        for(int i = 0; i &amp;lt; nums.length; i++) {
            int tmp = localMax;
            localMax = Math.max(localMax*nums[i], Math.max(localMin*nums[i], nums[i]));
            localMin = Math.min(tmp*nums[i], Math.min(localMin*nums[i], nums[i]));
            glMax = Math.max(glMax, localMax);
        }
        
        return glMax;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Minimum Window Substring</title>
      <link>http://xmruibi.github.io/2015/11/14/minimum-window-substring/</link>
      <pubDate>Sat, 14 Nov 2015 22:10:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/minimum-window-substring/</guid>
      <description>

&lt;p&gt;Given a string source and a string target, find the minimum window in source which will contain all the characters in target.&lt;/p&gt;

&lt;h3 id=&#34;example:550cea2e147a44ca0938087e5ad57f43&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;source = &amp;ldquo;ADOBECODEBANC&amp;rdquo; target = &amp;ldquo;ABC&amp;rdquo; Minimum window is &amp;ldquo;BANC&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;note:550cea2e147a44ca0938087e5ad57f43&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;If there is no such window in source that covers all characters in target, return the emtpy string &amp;ldquo;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in source.&lt;/p&gt;

&lt;h3 id=&#34;challenge:550cea2e147a44ca0938087e5ad57f43&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Can you do it in time complexity O(n) ?&lt;/p&gt;

&lt;h3 id=&#34;clarification:550cea2e147a44ca0938087e5ad57f43&#34;&gt;Clarification&lt;/h3&gt;

&lt;p&gt;The characters in minimum window doesn&amp;rsquo;t need to has the same order in target.&lt;/p&gt;

&lt;h2 id=&#34;solution:550cea2e147a44ca0938087e5ad57f43&#34;&gt;Solution:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public String minWindow(String s, String t) {
        // preload for target checking
        if(s == null || s.length() == 0 || t == null || t.length() == 0)
            return &amp;quot;&amp;quot;;
        
        
        // store t into a hashmap &amp;lt;char, freq&amp;gt;
        HashMap&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(char c : t.toCharArray())
            map.put(c, map.containsKey(c)?map.get(c) + 1 : 1);
        // set curidx-i, leftbound-prev, hitcharCnt-hitCnt, default max length-len
        int prev = 0, hitCnt = 0, len = s.length();
        String res = &amp;quot;&amp;quot;;
        
        for(int i = 0; i&amp;lt;s.length();i++){
            char cur = s.charAt(i);
            // skip nonhit char
            if(!map.containsKey(cur))
                continue;
            map.put(cur, map.get(cur) - 1);
            if(map.get(cur) &amp;gt;= 0)
                hitCnt++;
                
            while(hitCnt == t.length()) {
                if(i - prev + 1 &amp;lt;= len) {
                    res = s.substring(prev, i+1);
                    len = i - prev + 1;
                }
                if(map.containsKey(s.charAt(prev))) {
                   map.put(s.charAt(prev), map.get(s.charAt(prev))+1);
                   if(map.get(s.charAt(prev)) &amp;gt; 0)
                      hitCnt--;
                }
                prev++;
            }
        }
        return res;
    }

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Binary Tree Upside Down</title>
      <link>http://xmruibi.github.io/2015/11/14/binary-tree-upside-down/</link>
      <pubDate>Sat, 14 Nov 2015 15:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/binary-tree-upside-down/</guid>
      <description>

&lt;p&gt;Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.&lt;/p&gt;

&lt;h3 id=&#34;example:33643332a2ae687d0e663b807ba8b06f&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given a binary tree &lt;code&gt;{1,2,3,4,5}&lt;/code&gt;,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     1
    / \
   2   3
  / \
 4   5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return the root of the binary tree &lt;code&gt;[4,5,2,#,#,3,1]&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     4
    / \
   5   2
      / \
     3   1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:33643332a2ae687d0e663b807ba8b06f&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Mark the parent node &lt;code&gt;parent&lt;/code&gt; from next right node position.&lt;/li&gt;
&lt;li&gt;Mark the current right child &lt;code&gt;node.right&lt;/code&gt; from next left &lt;code&gt;left&lt;/code&gt; node position&lt;/li&gt;
&lt;li&gt;Mark the next iteration node &lt;code&gt;next&lt;/code&gt; by current left child &lt;code&gt;node.left&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Replace the current node&amp;rsquo;s left child as the recorded &lt;code&gt;right&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Replace the current node&amp;rsquo;s right child as the recorded &lt;code&gt;parent&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Replace current iteration node by &lt;code&gt;next&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-iterative:33643332a2ae687d0e663b807ba8b06f&#34;&gt;Solution #Iterative&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public TreeNode UpsideDownBinaryTree(TreeNode node) {  
        TreeNode parent = null, right = null;
		while(node != null) {
			TreeNode next = node.left;
			node.left = right;						
			right = node.right;
			node.right = parent;
			parent = node;
			node = next;
		}
		return parent;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-recursive:33643332a2ae687d0e663b807ba8b06f&#34;&gt;Solution #Recursive&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static TreeNode upsideDown(TreeNode node) {
        if(node == null)
            return node;
        TreeNode root = node, left = node.left, right = node.right;
        if(left != null) {
            TreeNode newroot = upsideDown(node.left);
            left.left = right;
            left.right = root;
            return newroot;
        }
        return node;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Course Schedule I/II</title>
      <link>http://xmruibi.github.io/2015/11/14/course-schedule-i/ii/</link>
      <pubDate>Sat, 14 Nov 2015 13:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/course-schedule-i/ii/</guid>
      <description>

&lt;h2 id=&#34;problem-i:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Problem I&lt;/h2&gt;

&lt;p&gt;There are a total of n courses you have to take, labeled from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n - 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: &lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2, [[1,0]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2, [[1,0],[0,1]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.&lt;/p&gt;

&lt;h3 id=&#34;solution-topological-sort:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Solution #Topological Sort&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        HashMap&amp;lt;Integer, Course&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(int[] pair : prerequisites) {
            int pre = pair[1];
            int cur = pair[0];
            if(!map.containsKey(pre))
                map.put(pre, new Course(pre));
            if(!map.containsKey(cur))
                map.put(cur, new Course(cur));
            map.get(pre).nexts.add(map.get(cur));
            map.get(cur).preq++;
        }
        Queue&amp;lt;Course&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
        for(Course c : map.values()) {
            if(c.preq == 0)
                queue.offer(c);
        }
        
        while(!queue.isEmpty()) {
            Course cur = queue.poll();
            map.remove(cur.idx);
            for(Course next : cur.nexts) {
                next.preq--;
                if(next.preq == 0)
                    queue.offer(next);
            }
        }
        return map.size() == 0;
    }
}
class Course{
    int idx;
    int preq;
    ArrayList&amp;lt;Course&amp;gt; nexts;
    public Course(int index) {
        this.idx = index;
        this.preq = 0;
        this.nexts = new ArrayList&amp;lt;&amp;gt;();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.&lt;/p&gt;

&lt;p&gt;There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.&lt;/p&gt;

&lt;h4 id=&#34;example:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;2, [[1,0]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a total of 2 courses to take. To take course &lt;code&gt;1&lt;/code&gt; you should have finished course &lt;code&gt;0&lt;/code&gt;. So the correct course order is &lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;4, [[1,0],[2,0],[3,1],[3,2]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a total of 4 courses to take. To take course &lt;code&gt;3&lt;/code&gt; you should have finished both courses &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;. Both courses &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; should be taken after you finished course 0. So one correct course order is &lt;code&gt;[0,1,2,3]&lt;/code&gt;. Another correct ordering is &lt;code&gt;[0,2,1,3]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;solution-topological-sort-1:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Solution #Topological Sort&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        if(prerequisites == null || prerequisites.length == 0)
            return new int[0];
            
        HashMap&amp;lt;Integer, Course&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(int[] pair : prerequisites) {
            int pre = pair[1];
            int cur = pair[0];
            if(!map.containsKey(pre))
                map.put(pre, new Course(pre));
            if(!map.containsKey(cur))
                map.put(cur, new Course(cur));
            map.get(pre).nexts.add(map.get(cur));
            map.get(cur).preq++;
        }
        Queue&amp;lt;Course&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
        for(Course c : map.values()) {
            if(c.preq == 0)
                queue.offer(c);
        }
        int[] res = new int[numCourses];
        int index = 0;
        while(!queue.isEmpty()) {
            Course cur = queue.poll();
            res[index++] = cur.idx;
            map.remove(cur.idx);
            for(Course next : cur.nexts) {
                next.preq--;
                if(next.preq == 0)
                    queue.offer(next);
            }
        }
        return map.size() == 0 ? res : new int[0];
    }
}
class Course{
    int idx;
    int preq;
    ArrayList&amp;lt;Course&amp;gt; nexts;
    public Course(int index) {
        this.idx = index;
        this.preq = 0;
        this.nexts = new ArrayList&amp;lt;&amp;gt;();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Repeated DNA Sequences</title>
      <link>http://xmruibi.github.io/2015/11/14/repeated-dna-sequences/</link>
      <pubDate>Sat, 14 Nov 2015 13:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/repeated-dna-sequences/</guid>
      <description>

&lt;p&gt;All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: &amp;ldquo;ACGAATTCCG&amp;rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.&lt;/p&gt;

&lt;p&gt;Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.&lt;/p&gt;

&lt;h3 id=&#34;example:86c36611807a867e11fbbb9582b6e9b6&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;s&lt;/code&gt; = &lt;code&gt;&amp;quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&amp;quot;&lt;/code&gt;, Return:  &lt;code&gt;[&amp;quot;AAAAACCCCC&amp;quot;, &amp;quot;CCCCCAAAAA&amp;quot;]&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think-rolling-hash:86c36611807a867e11fbbb9582b6e9b6&#34;&gt;Think #Rolling Hash&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The idea based on the rolling hash, we store each segment as a hash code.&lt;/li&gt;
&lt;li&gt;If the segment repeated, its hashcode should be the same.&lt;/li&gt;
&lt;li&gt;Iterate through the input String, find each segment and its hashcode.&lt;/li&gt;
&lt;li&gt;Check the index map where has a index list more than one size.&lt;/li&gt;
&lt;li&gt;Just record a substring by the index bound from &lt;code&gt;list.get(0)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;O(n) time complexity&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-rolling-hash:86c36611807a867e11fbbb9582b6e9b6&#34;&gt;Solution #Rolling Hash&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public List&amp;lt;String&amp;gt; findRepeatedDnaSequences(String s) {
        Set&amp;lt;String&amp;gt; res = new HashSet&amp;lt;&amp;gt;();
        if(s==null||s.length()==0)
            return new ArrayList(res);
        Map&amp;lt;Character, Integer&amp;gt; dict = new HashMap&amp;lt;&amp;gt;();
        dict.put(&#39;A&#39;,0); dict.put(&#39;C&#39;,1); dict.put(&#39;G&#39;,2); dict.put(&#39;T&#39;,3);
       //int A_SIZE_POW_9 = (int) Math.pow(dict.size(), 9);
        Set&amp;lt;Integer&amp;gt; hashCodes = new HashSet&amp;lt;&amp;gt;();
        int hashCode = 0;
        for(int i=0;i&amp;lt;s.length();i++){
            if(i&amp;gt;9) // remove first 
                hashCode -= Math.pow(4,9)*dict.get(s.charAt(i-10));
            hashCode = 4*hashCode + dict.get(s.charAt(i));
            if(i&amp;gt;8&amp;amp;&amp;amp;!hashCodes.add(hashCode)) // set add operation return true
                res.add(s.substring(i-9,i+1));
        }
        return new ArrayList(res);
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Product of Array Except Self</title>
      <link>http://xmruibi.github.io/2015/11/14/product-of-array-except-self/</link>
      <pubDate>Sat, 14 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/product-of-array-except-self/</guid>
      <description>

&lt;p&gt;Given an array of &lt;code&gt;n&lt;/code&gt; integers where &lt;code&gt;n&lt;/code&gt; &amp;gt; 1, nums, return an array output such that &lt;code&gt;output[i]&lt;/code&gt; is equal to the product of all the elements of nums except &lt;code&gt;nums[i]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Solve it &lt;strong&gt;without division&lt;/strong&gt; and in &lt;code&gt;O(n)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, given &lt;code&gt;[1,2,3,4]&lt;/code&gt;, return &lt;code&gt;[24,12,8,6]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Follow up:
Could you solve it with constant space complexity? (Note: The &lt;strong&gt;output array does not count&lt;/strong&gt; as extra space for the purpose of space complexity analysis.)&lt;/p&gt;

&lt;h2 id=&#34;think-1:475ac2d302270bdb12a33bec7e726fb7&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;$$O(n)$$ Space and Two pass, recording the left part or right part product.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:475ac2d302270bdb12a33bec7e726fb7&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int[] productExceptSelf(int[] input) {
        int[] res = new int[input.length];
        int tmp = 1;
        for (int i = 0; i &amp;lt; input.length; i++) {
            res[i] = tmp;
            tmp *= input[i];
        }
        tmp = 1;
        for (int i = input.length - 1; i &amp;gt;= 0; i--) {
            res[i] *= tmp;
            tmp *= input[i];
        }
        return res;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Zigzag Iterator</title>
      <link>http://xmruibi.github.io/2015/11/13/zigzag-iterator/</link>
      <pubDate>Fri, 13 Nov 2015 20:40:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/zigzag-iterator/</guid>
      <description>

&lt;p&gt;Given two 1d vectors, implement an iterator to return their elements alternately.&lt;/p&gt;

&lt;h3 id=&#34;example:c39b4a8138ca1f78be5fe1b3f188b037&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given two 1d vectors:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;v1&lt;/code&gt; = &lt;code&gt;[1, 2]&lt;/code&gt;
&lt;code&gt;v2&lt;/code&gt; = &lt;code&gt;[3, 4, 5, 6]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: &lt;code&gt;[1, 3, 2, 4, 5, 6]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;follow-up:c39b4a8138ca1f78be5fe1b3f188b037&#34;&gt;Follow up&lt;/h3&gt;

&lt;p&gt;What if you are given k 1d vectors? How well can your code be extended to such cases?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Valid Number</title>
      <link>http://xmruibi.github.io/2015/11/13/valid-number/</link>
      <pubDate>Fri, 13 Nov 2015 16:13:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/valid-number/</guid>
      <description>

&lt;p&gt;Validate if a given string is numeric.&lt;/p&gt;

&lt;h3 id=&#34;example:d0ba9336933b8515213de1bc6935949b&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot; 0.1 &amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;1 a&amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;2e10&amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think:d0ba9336933b8515213de1bc6935949b&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This question focus on thinking about all of corner case

&lt;ol&gt;
&lt;li&gt;sign before the number (one sign; two sign)&lt;/li&gt;
&lt;li&gt;space before the number&lt;/li&gt;
&lt;li&gt;invalid character before / after the number&lt;/li&gt;
&lt;li&gt;&amp;lsquo;e&amp;rsquo; or &amp;lsquo;E&amp;rsquo; in the middle of number&lt;/li&gt;
&lt;li&gt;space after the number&lt;/li&gt;
&lt;li&gt;decimal checker&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:d0ba9336933b8515213de1bc6935949b&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public boolean isNumber(String s) {
		if(s == null)
			return false;
        boolean eFlagAllow = true; // switcher for &#39;e&#39; or &#39;E&#39;
        boolean decimal = true; // switcher for &#39;.&#39;
        boolean hasNum = false; // make sure it contains number
        int cursor = 0;
        // skip previous space.
        while(cursor &amp;lt; s.length() &amp;amp;&amp;amp; s.charAt(cursor) == &#39; &#39;)
            cursor++;
            
        // check the sign, only one position allow for &#39;-&#39;
        if(cursor &amp;lt; s.length() &amp;amp;&amp;amp; s.charAt(cursor) == &#39;-&#39;)
            cursor++;
            
        while(cursor &amp;lt; s.length()) {
            char cur = s.charAt(cursor);
            // if has number 
            if(cur &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; cur &amp;lt;= &#39;9&#39;){
                if(!hasNum)
                    hasNum = true;
            }else if((cur == &#39;e&#39; || cur == &#39;E&#39;) &amp;amp;&amp;amp; eFlagAllow &amp;amp;&amp;amp; hasNum) { 
                // previous position should contain the number first 
                eFlagAllow = false; // turn off the e/E switcher
            }else if(cur == &#39;.&#39; &amp;amp;&amp;amp; decimal) {
                // turn off the decimal switcher
                decimal = false;
            }else if(cur != &#39; &#39;) // not allow the char except the space
                return false;
            cursor ++;
        }
        
        return cursor == s.length() &amp;amp;&amp;amp; hasNum;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Expression Add Operators</title>
      <link>http://xmruibi.github.io/2015/11/12/expression-add-operators/</link>
      <pubDate>Thu, 12 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/12/expression-add-operators/</guid>
      <description>

&lt;p&gt;Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.&lt;/p&gt;

&lt;h3 id=&#34;examples:b80d8eb4c261a28dea46a3fd4834483e&#34;&gt;Examples&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;123&amp;quot;, 6 -&amp;gt; [&amp;quot;1+2+3&amp;quot;, &amp;quot;1*2*3&amp;quot;] 
&amp;quot;232&amp;quot;, 8 -&amp;gt; [&amp;quot;2*3+2&amp;quot;, &amp;quot;2+3*2&amp;quot;]
&amp;quot;105&amp;quot;, 5 -&amp;gt; [&amp;quot;1*0+5&amp;quot;,&amp;quot;10-5&amp;quot;]
&amp;quot;00&amp;quot;, 0 -&amp;gt; [&amp;quot;0+0&amp;quot;, &amp;quot;0-0&amp;quot;, &amp;quot;0*0&amp;quot;]
&amp;quot;3456237490&amp;quot;, 9191 -&amp;gt; []
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:b80d8eb4c261a28dea46a3fd4834483e&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;This problem has a lot of edge cases to be considered:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;overflow: we use a long type once it is larger than Integer.MAX_VALUE or minimum, we get over it.&lt;/li&gt;
&lt;li&gt;0 sequence: because we can&amp;rsquo;t have numbers with multiple digits started with zero, we have to deal with it too.&lt;/li&gt;
&lt;li&gt;a little trick is that we should save the value that is to be multiplied in the next recursion.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;solution:b80d8eb4c261a28dea46a3fd4834483e&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {

    public List&amp;lt;String&amp;gt; addOperators(String num, int target) {
        List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        helper(res, &amp;quot;&amp;quot;, num, 0, target, 0L, 0L);
        return res;
    }
    
    private void helper(List&amp;lt;String&amp;gt; res, String cur, String num, int idx, int target, long preVal, long nextVal) {
       if(idx == num.length()) {
            if(preVal == target)
                res.add(new String(cur));
            return;
       }
       
       for(int i = idx; i &amp;lt; num.length(); i++) {
           if(i != idx &amp;amp;&amp;amp; num.charAt(idx) == &#39;0&#39;) break;
           String sbstr = num.substring(idx, i+1);
           long curVal = Long.parseLong(sbstr);
           if(idx == 0)
                helper(res, sbstr, num, i+1, target, curVal, curVal);
           else {
               helper(res, cur + &amp;quot;+&amp;quot; + curVal, num, i+1, target, preVal + curVal,  curVal);
               helper(res, cur + &amp;quot;-&amp;quot; + curVal, num, i+1, target, preVal - curVal, 0 - curVal);
               helper(res, cur + &amp;quot;*&amp;quot; + curVal, num, i+1, target, preVal - nextVal + nextVal * curVal, nextVal * curVal);
           }
       }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find the Celebrity</title>
      <link>http://xmruibi.github.io/2015/11/12/find-the-celebrity/</link>
      <pubDate>Thu, 12 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/12/find-the-celebrity/</guid>
      <description>

&lt;p&gt;Suppose you are at a party with &lt;code&gt;n&lt;/code&gt; people (labeled from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n - 1&lt;/code&gt;) and among them, there may exist one celebrity. The definition of a celebrity is that all the other &lt;code&gt;n - 1&lt;/code&gt; people know him/her but &lt;strong&gt;he/she does not know any of them&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: &amp;ldquo;Hi, A. Do you know B?&amp;rdquo; to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).&lt;/p&gt;

&lt;p&gt;You are given a helper function &lt;code&gt;bool knows(a, b)&lt;/code&gt; which tells you whether A knows B. Implement a function &lt;code&gt;int findCelebrity(n)&lt;/code&gt;, your function should minimize the number of calls to &lt;code&gt;knows&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note:987915e63763fb778a6682d4a9f26f85&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;There will be exactly one celebrity if he/she is in the party. Return the celebrity&amp;rsquo;s label if there is a celebrity in the party. If there is no celebrity, return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think-1:987915e63763fb778a6682d4a9f26f85&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Based graph, check the node with &lt;code&gt;n-1&lt;/code&gt; in-degree and &lt;code&gt;0&lt;/code&gt; out-degree.&lt;/li&gt;
&lt;li&gt;Becuase other &lt;code&gt;n - 1&lt;/code&gt; people know him/her but &lt;strong&gt;he/she does not know any of them&lt;/strong&gt; (&lt;code&gt;0&lt;/code&gt; out-degree)&lt;/li&gt;
&lt;li&gt;Call times: $$O(n^2)$$&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:987915e63763fb778a6682d4a9f26f85&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public int findCelebrity(int n) {
		if (n &amp;lt;= 1)
			return -1;

		int[] inDegree = new int[n];
		int[] outDegree = new int[n];

		// call n^2 times
		for (int i = 0; i &amp;lt; n; i++) {
			for (int j = 0; j &amp;lt; n; j++) {
				if (i != j &amp;amp;&amp;amp; knows(i, j)) {
					outDegree[i]++;
					inDegree[j]++;
				}
			}
		}

		for (int i = 0; i &amp;lt; n; i++) {
			if (inDegree[i] == n - 1 &amp;amp;&amp;amp; outDegree[i] == 0) {
				return i;
			}
		}

		return -1;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2:987915e63763fb778a6682d4a9f26f85&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Iterations from head and rear to the middle(l -&amp;gt; m &amp;lt;- r).&lt;/li&gt;
&lt;li&gt;Two cases when check if [l] knows [r].

&lt;ul&gt;
&lt;li&gt;Left shouldn&amp;rsquo;t be celebrity since he knows someone.&lt;/li&gt;
&lt;li&gt;Right shouldn&amp;rsquo;t be celebrity because one of people doesn&amp;rsquo;t know him.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2:987915e63763fb778a6682d4a9f26f85&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public int findCelebrityII(int n) {
		if (n &amp;lt;= 1)
			return -1;
		
		int left = 0, right = n - 1;
		while (left &amp;lt; right) {
			if (knows(left, right))
				left++; // left shouldn&#39;t be celebrity since he knows someone
			else
				right--; // right shouldn&#39;t be celebrity because one of people doesn&#39;t know him
		}

		// check the potential candidate is celebrity
		for (int i = 0; i &amp;lt; n; i++) {
			if (i == right)
				continue;
			if (knows(right, i))
				return -1;
		}
		return right;
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find the Duplicate Number</title>
      <link>http://xmruibi.github.io/2015/11/12/find-the-duplicate-number/</link>
      <pubDate>Thu, 12 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/12/find-the-duplicate-number/</guid>
      <description>

&lt;p&gt;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.&lt;/p&gt;

&lt;h3 id=&#34;note:51072b7754d767e44ab1a140653d075f&#34;&gt;Note&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;You must not modify the array (assume the array is read only).&lt;/li&gt;
&lt;li&gt;You must use only constant, O(1) extra space.&lt;/li&gt;
&lt;li&gt;Your runtime complexity should be less than $$O(n^2)$$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is only one duplicate number in the array, but it could be repeated more than once.&lt;/p&gt;

&lt;h2 id=&#34;think-1:51072b7754d767e44ab1a140653d075f&#34;&gt;Think #1&lt;/h2&gt;

&lt;h5 id=&#34;pigeonhole-principle:51072b7754d767e44ab1a140653d075f&#34;&gt;Pigeonhole Principle&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Split the array into two pieces by the middle point.&lt;/li&gt;
&lt;li&gt;NOTE: an array nums containing &lt;code&gt;n + 1&lt;/code&gt; integers where each integer is between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; (inclusive).&lt;/li&gt;
&lt;li&gt;Let&amp;rsquo;s say if there is &lt;code&gt;10&lt;/code&gt; elements in array. The index of middle point is &lt;code&gt;4&lt;/code&gt;. Check the all elements and count how many element has the value less or equal to that index. If the counter larger than index value and according to Pigeonhole Priciple,  that means there must have number duplicated in the first half of searching range. So next time we search the first half. Otherwise, we check the last half part.&lt;/li&gt;
&lt;li&gt;NOTICE: each time we decrease the search range but still check the number in entire array.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:51072b7754d767e44ab1a140653d075f&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int findDuplicate(int[] nums) {
        int l = 0, r = nums.length - 1;
        while(l &amp;lt; r) {
            int m = l + ((r - l) &amp;gt;&amp;gt; 1);
            int cnt = 0;
            for(int i : nums)
                if(i &amp;lt;= m)
                    cnt++;
            if(cnt &amp;lt;= m)
                l = m + 1;
            else
                r = m;
        }
        return l;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Integer to English Words</title>
      <link>http://xmruibi.github.io/2015/11/12/integer-to-english-words/</link>
      <pubDate>Thu, 12 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/12/integer-to-english-words/</guid>
      <description>

&lt;p&gt;Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.&lt;/p&gt;

&lt;h3 id=&#34;example:59e47c662cbbe0ed988b094d690a4b1b&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;123&lt;/code&gt; -&amp;gt; &lt;code&gt;&amp;quot;One Hundred Twenty Three&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;12345&lt;/code&gt; -&amp;gt; &lt;code&gt;&amp;quot;Twelve Thousand Three Hundred Forty Five&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1234567&lt;/code&gt; -&amp;gt; &lt;code&gt;&amp;quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;hint:59e47c662cbbe0ed988b094d690a4b1b&#34;&gt;Hint&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Did you see a pattern in dividing the number into chunk of words? For example, 123 and 123000.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Group the number by thousands (3 digits). You can write a helper function that takes a number less than 1000 and convert just that chunk to words.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There are many edge cases. What are some good test cases? Does your code work with input such as &lt;code&gt;0&lt;/code&gt; ? Or &lt;code&gt;1000010&lt;/code&gt;? (middle chunk is zero and should not be printed out)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;think:59e47c662cbbe0ed988b094d690a4b1b&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The regular pattern in English word to count number is splitting by &lt;code&gt;1000&lt;/code&gt;, so set each &lt;code&gt;000.&lt;/code&gt; by &lt;code&gt;&amp;quot;Thousand &amp;quot;, &amp;quot;Million &amp;quot;, &amp;quot;Billion &amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Be aware to number less than &lt;code&gt;20&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:59e47c662cbbe0ed988b094d690a4b1b&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    private final String[] lessThan20 = {&amp;quot;&amp;quot;, &amp;quot;One &amp;quot;, &amp;quot;Two &amp;quot;, &amp;quot;Three &amp;quot;, &amp;quot;Four &amp;quot;, &amp;quot;Five &amp;quot;, &amp;quot;Six &amp;quot;, &amp;quot;Seven &amp;quot;, &amp;quot;Eight &amp;quot;, &amp;quot;Nine &amp;quot;, &amp;quot;Ten &amp;quot;, &amp;quot;Eleven &amp;quot;, &amp;quot;Twelve &amp;quot;, &amp;quot;Thirteen &amp;quot;, &amp;quot;Fourteen &amp;quot;, &amp;quot;Fifteen &amp;quot;, &amp;quot;Sixteen &amp;quot;, &amp;quot;Seventeen &amp;quot;, &amp;quot;Eighteen &amp;quot;, &amp;quot;Nineteen &amp;quot;};
    private final String[] tens = {&amp;quot;&amp;quot;, &amp;quot;Ten &amp;quot;, &amp;quot;Twenty &amp;quot;, &amp;quot;Thirty &amp;quot;, &amp;quot;Forty &amp;quot;, &amp;quot;Fifty &amp;quot;, &amp;quot;Sixty &amp;quot;, &amp;quot;Seventy &amp;quot;, &amp;quot;Eighty &amp;quot;, &amp;quot;Ninety &amp;quot;};
    private final String[] thousands = {&amp;quot;&amp;quot;, &amp;quot;Thousand &amp;quot;, &amp;quot;Million &amp;quot;, &amp;quot;Billion &amp;quot;};

    public String numberToWords(int num) {
        if (num == 0)
            return &amp;quot;Zero&amp;quot;;
        int i = 0;
        String words = &amp;quot;&amp;quot;;
        
        while(num &amp;gt; 0) {
            if (num % 1000 != 0)
                words = eachThousand(num % 1000)+ thousands[i] + words;
            num /= 1000;
            i++;
        }
        return words.trim();
    }
    
    private String eachThousand(int each) {
        StringBuilder sb = new StringBuilder();
        if(each / 100 &amp;gt; 0) {
            sb.append(lessThan20[each / 100] + &amp;quot;Hundred &amp;quot;);
        }
        int ten = each % 100;
        if(ten &amp;gt;= 20) {
            sb.append(tens[ten/10]);
            sb.append(lessThan20[ten%10]);
        }else {
            sb.append(lessThan20[ten]);
        }
        return sb.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Unique Word Abbreviation</title>
      <link>http://xmruibi.github.io/2015/11/12/unique-word-abbreviation/</link>
      <pubDate>Thu, 12 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/12/unique-word-abbreviation/</guid>
      <description>

&lt;p&gt;An abbreviation of a word follows the form &lt;code&gt;&amp;lt;first letter&amp;gt;&amp;lt;number&amp;gt;&amp;lt;last letter&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Below are some examples of word abbreviations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    a) it                      --&amp;gt; it    (no abbreviation)
    
         1
    b) d|o|g                   --&amp;gt; d1g
    
                  1    1  1
         1---5----0----5--8
    c) i|nternationalizatio|n  --&amp;gt; i18n
    
                  1
         1---5----0
    d) l|ocalizatio|n          --&amp;gt; l10n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word&amp;rsquo;s abbreviation is unique if no other word from the dictionary has the same abbreviation.&lt;/p&gt;

&lt;h3 id=&#34;example:a71989791a51f811869cd70e5706cbbe&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given dictionary = [ &amp;ldquo;deer&amp;rdquo;, &amp;ldquo;door&amp;rdquo;, &amp;ldquo;cake&amp;rdquo;, &amp;ldquo;card&amp;rdquo; ]&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isUnique(&amp;quot;dear&amp;quot;)&lt;/code&gt; -&amp;gt; &lt;code&gt;false&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isUnique(&amp;quot;cart&amp;quot;)&lt;/code&gt; -&amp;gt; &lt;code&gt;true&lt;/code&gt; ;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isUnique(&amp;quot;cane&amp;quot;)&lt;/code&gt; -&amp;gt; &lt;code&gt;false&lt;/code&gt;;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;isUnique(&amp;quot;make&amp;quot;)&lt;/code&gt; -&amp;gt; &lt;code&gt;true&lt;/code&gt;;&lt;/p&gt;

&lt;h2 id=&#34;think:a71989791a51f811869cd70e5706cbbe&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Save dictionary words in a set&lt;/li&gt;
&lt;li&gt;Save the abbreviation from dictionary word to a HashMap.&lt;/li&gt;
&lt;li&gt;HashMap has the key with abbreviation and value with the original word&lt;/li&gt;
&lt;li&gt;check &lt;code&gt;isUnique(word)&lt;/code&gt; by make abbreviation from that word and compare with the hashmap&lt;/li&gt;
&lt;li&gt;If hashmap doesn&amp;rsquo;t contain that word, return true.&lt;/li&gt;
&lt;li&gt;If hashmap contains that word, we should compare if the word is equal to the word saved in hashmap.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:a71989791a51f811869cd70e5706cbbe&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class UniqueWordAbbreviation {

	Set&amp;lt;String&amp;gt; dict = new HashSet&amp;lt;&amp;gt;(); // keep the dictionary has unique words
	Map&amp;lt;String, String&amp;gt; abbrDict = new HashMap&amp;lt;&amp;gt;();

	public UniqueWordAbbreviation(String[] dictionary) {
		for (String str : dictionary) {
			if (dict.contains(str))
				continue;
			String abbr = makeAbbr(str);
			if (!abbrDict.containsKey(abbr))
				abbrDict.put(abbr, str);
			else
				abbrDict.put(abbr, &amp;quot;&amp;quot;);
			dict.add(str);
		}
	}

	public boolean isUnique(String word) {
		String abbr = makeAbbr(word);
		if (abbrDict.containsKey(abbr))
			return word.equals(abbrDict.get(abbr));
		return true;
	}

    private String makeAbbr(String str) {
		if (str == null || str.length() &amp;lt;= 2)
			return str;
		int mid = str.length() - 2;
		StringBuilder sb = new StringBuilder();
		sb.append(str.charAt(0));
		sb.append(mid);
		sb.append(str.charAt(str.length() - 1));
		return sb.toString();
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>