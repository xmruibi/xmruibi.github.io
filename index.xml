<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/</link>
    <description>Recent content on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Mon, 26 Oct 2015 16:33:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Print Numbers by Recursion</title>
      <link>http://xmruibi.github.io/2015/10/26/print-numbers-by-recursion/</link>
      <pubDate>Mon, 26 Oct 2015 16:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/26/print-numbers-by-recursion/</guid>
      <description>

&lt;p&gt;Print numbers from 1 to the largest number with &lt;code&gt;N&lt;/code&gt; digits by recursion.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;N = 1&lt;/code&gt;, return &lt;code&gt;[1,2,3,4,5,6,7,8,9]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Given &lt;code&gt;N = 2&lt;/code&gt;, return &lt;code&gt;[1,2,3,4,5,6,7,8,9,10,11,12,...,99]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s pretty easy to do recursion like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;recursion(i) {
    if i &amp;gt; largest number:
        return
    results.add(i)
    recursion(i + 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However this cost a lot of recursion memory as the recursion depth maybe very large ($$10^n - 1$$). Can you do it in another way to recursive with at most N depth?&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it in recursion, not for-loop.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Think from bottom to top.&lt;/li&gt;
&lt;li&gt;Build the result list from number with one digits to N digits.&lt;/li&gt;
&lt;li&gt;Since we considering with digits as its deep, we have to set a loop to add the number in list on the new-generated base number (1 - 9 with following digits):&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;when zero digit, none;
when one digit, new-generated base number is 1, add 1,2,...9;
when two digit, new-generated base number is 10, add 10,20,...90;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Each time when having the new-generated base number, we need to pass through the original result list to fill the rest of number with beginning as new-generated base number.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;when one digit, new-generated base number is 1, add 1,2,...9, but original result list has nothing. so just add itself;
when two digit, new-generated base number is 10, when add 10, go back the original result list with &amp;quot;1, 2, 3,..., 9&amp;quot;, add them as 11, 12, 13, ..., 19, when add 20, go back the original result list with &amp;quot;1, 2, 3,..., 9&amp;quot;, add them as 21, 22, 23, ..., 29;
so the same as for 30,..., 90, 100, ..., 900, ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param n: An integer.
     * return : An array storing 1 to the largest number with n digits.
     */
    public List&amp;lt;Integer&amp;gt; numbersByRecursion(int n) {
        List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(n &amp;gt;= 0)
            add(res, n);
        return res;
    }
    
    private int add(List&amp;lt;Integer&amp;gt; res, int n){
        if(n == 0)
            return 1;
        
        int cur = add(res, n - 1);
        int size = res.size();
        for(int i = 1; i &amp;lt;= 9; i ++) {
            int digit = i * cur;
            res.add(digit);
            for(int j = 0; j &amp;lt; size; j++) {
                res.add(digit + res.get(j));
            }
        }
        return cur * 10;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis&lt;/h2&gt;

&lt;p&gt;Time: $$O(10^n - 1)$$&lt;/p&gt;

&lt;p&gt;Space: $$O(n)$$&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Boggle Game</title>
      <link>http://xmruibi.github.io/2015/10/25/boggle-game/</link>
      <pubDate>Sun, 25 Oct 2015 20:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/boggle-game/</guid>
      <description>

&lt;p&gt;Given a dictionary, a method to do lookup in dictionary and a M x N board where every cell has one character. Find all possible words that can be formed by a sequence of adjacent characters. Note that we can move to any of 8 adjacent characters, but a word should not have multiple instances of same cell.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;DFS on character board to do backtracking.&lt;/li&gt;
&lt;li&gt;Searching the character for 8 directions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {

    public List&amp;lt;String&amp;gt; findWords(HashSet&amp;lt;String&amp;gt; dict, char[][] board) {
        List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        boolean[][] visited = new boolean[board.length][board[0].length];
        for(int i = 0; i &amp;lt; board.length; i++) {
            for(int j = 0; j &amp;lt; board[i].length; j++) {
                findUtil(res, dict, board, visited, &amp;quot;&amp;quot;, i, j);
            }
        }
        return res;
    }

    private void findUtil(List&amp;lt;String&amp;gt; res, HashSet&amp;lt;String&amp;gt; dict, char[][] board, boolean[][] visited, String cur, int x, int y) {
        visited[x][y] = true;
        cur += board[x][y];

        if(dict.contains(cur)) {
            res.add(cur);
            dict.remvoe(cur);
            return;
        }
        
        int[] xs = {1,1,1,0,0,-1,-1,-1};
        int[] ys = {1,-1,0,1,-1,0,1,-1};
        for(int i = 0; i &amp;lt; 8; i++) {
            int nx = xs[i] + x;
            int ny = ys[i] + y;
            if(nx &amp;gt;= 0 &amp;amp;&amp;amp; nx &amp;lt; board.length &amp;amp;&amp;amp; ny &amp;gt;= 0 &amp;amp;&amp;amp; ny &amp;lt; board[nx].length &amp;amp;&amp;amp; !visited[nx][ny])
                findUtil(res, dict, board, visited, cur, nx, ny);
        }
        visited[x][y] = false;
        cur = cur.substring(0, cur.length() - 1);
    }

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Convert Sorted List to Binary Search Tree</title>
      <link>http://xmruibi.github.io/2015/10/25/convert-sorted-list-to-binary-search-tree/</link>
      <pubDate>Sun, 25 Oct 2015 20:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/convert-sorted-list-to-binary-search-tree/</guid>
      <description>

&lt;p&gt;Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;               2
1-&amp;gt;2-&amp;gt;3  =&amp;gt;   / \
             1   3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Find the middle point in list&lt;/li&gt;
&lt;li&gt;Divide and Conquer to build left child and right child node&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head: The first node of linked list.
     * @return: a tree node
     */
    public TreeNode sortedListToBST(ListNode head) {  
        // write your code here
        if(head == null)
            return null;
        if(head.next == null)
            return new TreeNode(head.val);
            
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode runner = head;
        ListNode walker = dummy;
        while(runner!=null &amp;amp;&amp;amp; runner.next!=null) {
            runner = runner.next.next;
            walker = walker.next;
        }
        
        ListNode m = walker.next;
        TreeNode root = new TreeNode(m.val);
        ListNode left = dummy.next;
        ListNode right = walker.next.next;
        walker.next = null;
        root.left = sortedListToBST(left);
        root.right = sortedListToBST(right);
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Remove Duplicates from Sorted List II</title>
      <link>http://xmruibi.github.io/2015/10/25/remove-duplicates-from-sorted-list-ii/</link>
      <pubDate>Sun, 25 Oct 2015 20:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/remove-duplicates-from-sorted-list-ii/</guid>
      <description>

&lt;p&gt;Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5&lt;/code&gt;, return &lt;code&gt;1-&amp;gt;2-&amp;gt;5&lt;/code&gt;.
Given &lt;code&gt;1-&amp;gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3&lt;/code&gt;, return &lt;code&gt;2-&amp;gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param ListNode head is the head of the linked list
     * @return: ListNode head of the linked list
     */
    public static ListNode deleteDuplicates(ListNode head) {
        // write your code here
        if(head == null || head.next == null)
            return head;
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        while(head != null){
            ListNode cur = head;
            while(head.next != null &amp;amp;&amp;amp; cur.val == head.next.val)
                head = head.next;
            
            if(head != cur){
                pre.next = head.next;
            }else
                pre = pre.next;
            head = head.next;
        }
        
        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Copy List with Random Pointer</title>
      <link>http://xmruibi.github.io/2015/10/25/copy-list-with-random-pointer/</link>
      <pubDate>Sun, 25 Oct 2015 20:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/copy-list-with-random-pointer/</guid>
      <description>

&lt;p&gt;Merge k sorted linked lists and return it as one sorted list.&lt;/p&gt;

&lt;p&gt;Analyze and describe its complexity.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given lists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  2-&amp;gt;4-&amp;gt;null,
  null,
  -1-&amp;gt;null
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return &lt;code&gt;-1-&amp;gt;2-&amp;gt;4-&amp;gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use a heap to receive element from linked list&lt;/li&gt;
&lt;li&gt;Tricky part:

&lt;ul&gt;
&lt;li&gt;Just entered k node in heap instead of pass all nodes in lists.&lt;/li&gt;
&lt;li&gt;When poll out element, it also need to push back the next node of polled node.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param lists: a list of ListNode
     * @return: The head of one sorted list.
     */
    public ListNode mergeKLists(List&amp;lt;ListNode&amp;gt; lists) {  
        if(lists == null)
            return null;
        
        PriorityQueue&amp;lt;ListNode&amp;gt; queue = new PriorityQueue&amp;lt;ListNode&amp;gt;(10, new Comparator&amp;lt;ListNode&amp;gt;(){
            @Override
            public int compare(ListNode o1, ListNode o2){
                return Integer.compare(o1.val, o2.val);
            }
        });
        // O(n) : n total nodes 
        for(ListNode node : lists){
            if(node != null)
                queue.offer(node);
        }
        
        ListNode dummy = new ListNode(0);
        ListNode pre = dummy;
        while(!queue.isEmpty()){
            ListNode cur = queue.remove();
            if(cur.next != null)
                queue.offer(cur.next);
            pre.next = cur;
            pre = cur;
        }
        
        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Remove Nth Node From End of List</title>
      <link>http://xmruibi.github.io/2015/10/25/remove-nth-node-from-end-of-list/</link>
      <pubDate>Sun, 25 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/remove-nth-node-from-end-of-list/</guid>
      <description>

&lt;p&gt;Given a linked list, remove the nth node from the end of list and return its head.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given linked list: &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;null&lt;/code&gt;, and n = &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After removing the second node from the end, the linked list becomes &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;5-&amp;gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The minimum number of nodes in list is n.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n) time&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Typical idea on runner and walker linked list question&lt;/li&gt;
&lt;li&gt;Let runner node run for N step further than walker node.&lt;/li&gt;
&lt;li&gt;Get the N + 1 th position from end of list.&lt;/li&gt;
&lt;li&gt;Remove walker.next which is the target node.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head: The first node of linked list.
     * @param n: An integer.
     * @return: The head of linked list.
     */
    ListNode removeNthFromEnd(ListNode head, int n) {
        if(head==null)
            return head;
        ListNode runner = head;
        ListNode pre = new ListNode(0);
        pre.next = head;
        ListNode walker = pre;
        while(n&amp;gt;0&amp;amp;&amp;amp;runner!=null){
            runner = runner.next;
            n--;
        }
        while(runner!=null){
            runner = runner.next;
            walker = walker.next;
        }
        walker.next = walker.next.next;
        return pre.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Copy List with Random Pointer</title>
      <link>http://xmruibi.github.io/2015/10/25/copy-list-with-random-pointer/</link>
      <pubDate>Sun, 25 Oct 2015 15:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/copy-list-with-random-pointer/</guid>
      <description>

&lt;p&gt;A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.&lt;/p&gt;

&lt;p&gt;Return a deep copy of the list.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Could you solve it with O(1) space?&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Three pass:

&lt;ul&gt;
&lt;li&gt;Clone every node and attach it right next of original node,&lt;/li&gt;
&lt;li&gt;Copy the random pointer for clone node (the next of origianl node&amp;rsquo;s random pointer)&lt;/li&gt;
&lt;li&gt;Cut down the original and clone one&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head: The head of linked list with a random pointer.
     * @return: A new head of a deep copy of the list.
     */
    public RandomListNode copyRandomList(RandomListNode head) {
        // write your code here
        if(head == null)
            return null;
        RandomListNode dummyHead = head;
        while(head != null) {
            RandomListNode clone = new RandomListNode(head.label);
            RandomListNode next = head.next;
            head.next = clone;
            clone.next = next;
            head = next;
        }
        head = dummyHead;
        while(head != null) {
            RandomListNode clone = head.next;
            if(head.random != null)
                clone.random = head.random.next;
            head = clone.next;
        }
        head = dummyHead;
        RandomListNode resHead = dummyHead.next;
        while(head != null) {
            RandomListNode clone = head.next;
            head.next = clone.next;
            head = head.next;
            if(head != null)
                clone.next = head.next;
        }
        
        return resHead;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Expression Tree Build</title>
      <link>http://xmruibi.github.io/2015/10/25/expression-tree-build/</link>
      <pubDate>Sun, 25 Oct 2015 15:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/expression-tree-build/</guid>
      <description>

&lt;p&gt;The structure of Expression Tree is a binary tree to evaluate certain expressions. All leaves of the Expression Tree have an number string value. All non-leaves of the Expression Tree have an operator string value.&lt;/p&gt;

&lt;p&gt;Now, given an expression array, build the expression tree of this expression, return the root of this expression tree.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For the expression &lt;code&gt;(2*6-(23+7)/(1+2))&lt;/code&gt; (which can be represented by &lt;code&gt;[&amp;quot;2&amp;quot; &amp;quot;*&amp;quot; &amp;quot;6&amp;quot; &amp;quot;-&amp;quot; &amp;quot;(&amp;quot; &amp;quot;23&amp;quot; &amp;quot;+&amp;quot; &amp;quot;7&amp;quot; &amp;quot;)&amp;quot; &amp;quot;/&amp;quot; &amp;quot;(&amp;quot; &amp;quot;1&amp;quot; &amp;quot;+&amp;quot; &amp;quot;2&amp;quot; &amp;quot;)&amp;quot;]&lt;/code&gt;). The expression tree will be like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                 [ - ]
             /          \
        [ * ]              [ / ]
      /     \           /         \
    [ 2 ]  [ 6 ]      [ + ]        [ + ]
                     /    \       /      \
                   [ 23 ][ 7 ] [ 1 ]   [ 2 ] .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After building the tree, you just need to return root node &lt;code&gt;[-]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;clarification&#34;&gt;Clarification&lt;/h3&gt;

&lt;p&gt;A binary expression tree is a specific application of a binary tree to evaluate certain expressions. Two common types of expressions that a binary expression tree can represent are algebraic[1] and boolean. These trees can represent expressions that contain both unary and binary operators.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ExpressionTreeNode {
    public String symbol;
     public ExpressionTreeNode left, right;
     public ExpressionTreeNode(String symbol) {
        this.symbol = symbol;
        this.left = this.right = null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Two stacks, one is only for operator, another is for build the result tree.&lt;/li&gt;
&lt;li&gt;The idea is similar with RPN.&lt;/li&gt;
&lt;li&gt;One pass the expression array, when it get a operand, insert as new treenode in result tree, when it get a operator, insert as new treenode in operator tree and compare the priority, if the current is less than stack top element, build a new node with operator in stack top and two node from result tree as its right and left child, then insert back to result tree with this new node.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;


public class Solution {
    /**
     * @param expression: A string array
     * @return: The root of expression tree
     */
    public ExpressionTreeNode build(String[] expression) {
        Stack&amp;lt;ExpressionTreeNode&amp;gt; ops = new Stack&amp;lt;&amp;gt;();
        Stack&amp;lt;ExpressionTreeNode&amp;gt; data = new Stack&amp;lt;&amp;gt;();
        for( int i = 0; i &amp;lt; expression.length; i++) {
            String str = expression[i];
            if(str.equals(&amp;quot;+&amp;quot;) || str.equals(&amp;quot;-&amp;quot;) ||str.equals(&amp;quot;*&amp;quot;) ||str.equals(&amp;quot;/&amp;quot;)) {
                while(!ops.isEmpty() &amp;amp;&amp;amp; operatorLevel(ops.peek().symbol) &amp;gt;= operatorLevel(str)) {
                    newNodeGtr(ops, data);
                }
                ops.push(new ExpressionTreeNode(str));
            }else if(str.equals(&amp;quot;(&amp;quot;)){
                ops.push(new ExpressionTreeNode(str));
            }else if(str.equals(&amp;quot;)&amp;quot;)) {
                while(!ops.isEmpty() &amp;amp;&amp;amp; !ops.peek().symbol.equals(&amp;quot;(&amp;quot;))
                    newNodeGtr(ops, data);
                if(!ops.isEmpty()) 
                    ops.pop(); // pop the &amp;quot;(&amp;quot;
            }else
                data.push(new ExpressionTreeNode(str));
        }
        
        while(!ops.isEmpty())
            newNodeGtr(ops, data);
        
        return data.isEmpty()? null : data.pop();
    }
    
    private void newNodeGtr(Stack&amp;lt;ExpressionTreeNode&amp;gt; ops, Stack&amp;lt;ExpressionTreeNode&amp;gt; data) {
        if(ops.isEmpty())
            return;
        ExpressionTreeNode node = ops.pop();
        node.right = data.isEmpty() ? null : data.pop();
        node.left = data.isEmpty() ? null : data.pop();
        data.push(node);
    }
    
    private int operatorLevel(String op) {
        if(op.equals(&amp;quot;+&amp;quot;) || op.equals(&amp;quot;-&amp;quot;)) 
            return 1;
        else if(op.equals(&amp;quot;*&amp;quot;) ||op.equals(&amp;quot;/&amp;quot;))
            return 2;
        else
            return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Insertion Sort for Linked List</title>
      <link>http://xmruibi.github.io/2015/10/25/insertion-sort-for-linked-list/</link>
      <pubDate>Sun, 25 Oct 2015 15:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/insertion-sort-for-linked-list/</guid>
      <description>

&lt;p&gt;Sort a linked list using insertion sort.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;1-&amp;gt;3-&amp;gt;2-&amp;gt;0-&amp;gt;null&lt;/code&gt;, return &lt;code&gt;0-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Pass nodes from head to end.&lt;/li&gt;
&lt;li&gt;Once it get an element larger than its next one, do a swap.&lt;/li&gt;
&lt;li&gt;Then return to the head and to do the passing again.&lt;/li&gt;
&lt;li&gt;Loop until get all sorted.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head: The first node of linked list.
     * @return: The head of linked list.
     */
    public ListNode insertionSortList(ListNode head) {
        if(head == null || head.next == null)
            return head;
            
            ListNode dummy = new ListNode(0);
            ListNode pre = dummy;
            ListNode cur = head;
            while(cur != null){
                pre = dummy;
                ListNode next = cur.next;
                while(pre.next != null &amp;amp;&amp;amp; pre.next.val &amp;lt; cur.val)
                    pre = pre.next;
                cur.next = pre.next;
                pre.next = cur;
                cur = next;
            }
            
            return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Reverse Nodes in k-Group</title>
      <link>http://xmruibi.github.io/2015/10/25/reverse-nodes-in-k-group/</link>
      <pubDate>Sun, 25 Oct 2015 15:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/reverse-nodes-in-k-group/</guid>
      <description>

&lt;p&gt;Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.&lt;/p&gt;

&lt;p&gt;If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.&lt;/p&gt;

&lt;p&gt;You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given this linked list: &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For k = &lt;code&gt;2&lt;/code&gt;, you should return: &lt;code&gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For k = &lt;code&gt;3&lt;/code&gt;, you should return: &lt;code&gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Consider the list like following:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;	
	dummy(pre) -&amp;gt; l1 -&amp;gt; l2 -&amp;gt; l3 -&amp;gt; l4 -&amp;gt; l5 -&amp;gt; null
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Get the reversed segment:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; when cnt % k == 0:

		pre.next	  node  node.next
		   |            |     |
	pre -&amp;gt; l1 -&amp;gt; l2 -&amp;gt; l3 -&amp;gt; l4 -&amp;gt; l5 -&amp;gt; null

		  last	  ----&amp;gt;	     end
		    |		          |
	pre -&amp;gt; l1 -&amp;gt; l2 -&amp;gt; l3 -&amp;gt; l4 -&amp;gt; l5 -&amp;gt; null
			|     |	    
		pre.next pre.next(final status)	
			   \     \
			      |  -&amp;gt; |     |
				 cur   cur	 cur.next (final status)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head a ListNode
     * @param k an integer
     * @return a ListNode
     */
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head == null || head.next == null)
            return head;
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        int cnt = 1;
        ListNode front = head;
        while(head != null) {
            if(cnt % k == 0) {
                pre = reverse(pre, head.next);
                head = pre.next;
            }else
                head = head.next;
            cnt++;
        }
        return dummy.next;
    }
    
    private ListNode reverse(ListNode pre, ListNode end) {
        ListNode last = pre.next, cur = last.next;
        while(cur != end) {
            last.next = cur.next;
            cur.next = pre.next;
            pre.next = cur;
            cur = last.next;
        }
        return last;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Expression Evaluation</title>
      <link>http://xmruibi.github.io/2015/10/25/expression-evaluation/</link>
      <pubDate>Sun, 25 Oct 2015 10:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/expression-evaluation/</guid>
      <description>

&lt;p&gt;Given an expression string array, return the final result of this expression&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For the expression &lt;code&gt;2*6-(23+7)/(1+2)&lt;/code&gt;, input is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  &amp;quot;2&amp;quot;, &amp;quot;*&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;-&amp;quot;, &amp;quot;(&amp;quot;,
  &amp;quot;23&amp;quot;, &amp;quot;+&amp;quot;, &amp;quot;7&amp;quot;, &amp;quot;)&amp;quot;, &amp;quot;/&amp;quot;,
  (&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;+&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;)&amp;quot;
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The expression contains only &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;)&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This question is combination of read string array to RPN and then read RPN to get the integer result.&lt;/li&gt;
&lt;li&gt;So&amp;hellip;. two steps:

&lt;ul&gt;
&lt;li&gt;first, build RPN&lt;/li&gt;
&lt;li&gt;second, read the RPN&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param expression: an array of strings;
     * @return: an integer
     */
    public int evaluateExpression(String[] expression) {
        // two steps:
        // first, build RPN
        ArrayList&amp;lt;String&amp;gt; list = convertToRPN(expression);
        // second, read the RPN
        return RPNreader(list);
    }
    
    public ArrayList&amp;lt;String&amp;gt; convertToRPN(String[] expression) {
        Stack&amp;lt;String&amp;gt; ops = new Stack&amp;lt;&amp;gt;();
        ArrayList&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        for(String str : expression) {
            if(str.equals(&amp;quot;+&amp;quot;) || str.equals(&amp;quot;-&amp;quot;) ||str.equals(&amp;quot;*&amp;quot;) ||str.equals(&amp;quot;/&amp;quot;)) {
                while(!ops.isEmpty() &amp;amp;&amp;amp; operatorLevel(ops.peek()) &amp;gt;= operatorLevel(str))
                    res.add(ops.pop());
                ops.push(str);
            }else if(str.equals(&amp;quot;(&amp;quot;)){
                ops.push(str);
            }else if(str.equals(&amp;quot;)&amp;quot;)) {
                while(!ops.isEmpty() &amp;amp;&amp;amp; !ops.peek().equals(&amp;quot;(&amp;quot;))
                    res.add(ops.pop());
                if(!ops.isEmpty()) 
                    ops.pop(); // pop the &amp;quot;(&amp;quot;
            }else
                res.add(str);
        }
        while(!ops.isEmpty())
            res.add(ops.pop());
        return res;
    }
    
    private int operatorLevel(String op) {
        if(op.equals(&amp;quot;+&amp;quot;) || op.equals(&amp;quot;-&amp;quot;)) 
            return 1;
        else if(op.equals(&amp;quot;*&amp;quot;) ||op.equals(&amp;quot;/&amp;quot;))
            return 2;
        else
            return 0;
    }
    
    private int RPNreader(ArrayList&amp;lt;String&amp;gt; list) {
        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        for(String str : list) {
            int curRes = 0;
            switch(str){
                case &amp;quot;+&amp;quot;:
                    curRes = (stack.isEmpty()?0:stack.pop()) + (stack.isEmpty()?0:stack.pop());
                    break;
                case &amp;quot;-&amp;quot;:
                    curRes = stack.isEmpty()?0:stack.pop();
                    curRes = (stack.isEmpty()?0:stack.pop()) - curRes;
                    break;
                case &amp;quot;*&amp;quot;:
                    curRes = (stack.isEmpty()?0:stack.pop()) *  (stack.isEmpty()?0:stack.pop());
                    break;
                case &amp;quot;/&amp;quot;:
                    curRes = stack.isEmpty()?0:stack.pop();
                    if(curRes == 0)
                        break;
                    curRes = (stack.isEmpty()?0:stack.pop()) / curRes;
                    break;
                default:
                    curRes = Integer.parseInt(str);
            }
            stack.push(curRes);
        }
        
        return stack.isEmpty()?0:stack.pop();
    }
    
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Convert Expression to Polish Notation</title>
      <link>http://xmruibi.github.io/2015/10/25/convert-expression-to-polish-notation/</link>
      <pubDate>Sun, 25 Oct 2015 10:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/convert-expression-to-polish-notation/</guid>
      <description>

&lt;p&gt;Given an expression string array, return the Polish notation of this expression. (remove the parentheses)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Polish notation, also known as Polish prefix notation or simply prefix notation, is a form of notation for logic, arithmetic, and algebra. Its distinguishing feature is that it places operators to the left of their operands. If the arity of the operators is fixed, the result is a syntax lacking parentheses or other brackets that can still be parsed without ambiguity. The Polish logician Jan Łukasiewicz invented this notation in 1924 in order to simplify sentential logic.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For the expression &lt;code&gt;[(5 − 6) * 7]&lt;/code&gt; (which represented by &lt;code&gt;[&amp;quot;(&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;−&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;)&amp;quot;, &amp;quot;*&amp;quot;, &amp;quot;7&amp;quot;]&lt;/code&gt;), the corresponding polish notation is &lt;code&gt;[* - 5 6 7]&lt;/code&gt; (which the return value should be &lt;code&gt;[&amp;quot;*&amp;quot;, &amp;quot;−&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;7&amp;quot;]&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The idea is not complext if you took the reverse polish notation question.&lt;/li&gt;
&lt;li&gt;Just two things changed:

&lt;ul&gt;
&lt;li&gt;Pass from rear to head;&lt;/li&gt;
&lt;li&gt;Every insertion is to the first index in result list&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param expression: A string array
     * @return: The Polish notation of this expression
     */
    public ArrayList&amp;lt;String&amp;gt; convertToPN(String[] expression) {
        
        Stack&amp;lt;String&amp;gt; ops = new Stack&amp;lt;&amp;gt;();
        ArrayList&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        for(int i = expression.length - 1; i &amp;gt;= 0; i--) {
            String str = expression[i];
            if(str.equals(&amp;quot;+&amp;quot;) || str.equals(&amp;quot;-&amp;quot;) ||str.equals(&amp;quot;*&amp;quot;) ||str.equals(&amp;quot;/&amp;quot;)) {
                while(!ops.isEmpty() &amp;amp;&amp;amp; operatorLevel(ops.peek()) &amp;gt; operatorLevel(str))
                    res.add(0, ops.pop());
                ops.push(str);
            }else if(str.equals(&amp;quot;)&amp;quot;)){
                ops.push(str);
            }else if(str.equals(&amp;quot;(&amp;quot;)) {
                while(!ops.isEmpty() &amp;amp;&amp;amp; !ops.peek().equals(&amp;quot;)&amp;quot;))
                    res.add(0, ops.pop());
                if(!ops.isEmpty()) 
                    ops.pop(); // pop the &amp;quot;)&amp;quot;
            }else
                res.add(0, str);
        }
        while(!ops.isEmpty())
            res.add(0, ops.pop());
        return res;
    }
    
     private int operatorLevel(String op) {
        if(op.equals(&amp;quot;+&amp;quot;) || op.equals(&amp;quot;-&amp;quot;)) 
            return 1;
        else if(op.equals(&amp;quot;*&amp;quot;) ||op.equals(&amp;quot;/&amp;quot;))
            return 2;
        else
            return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Convert Expression to Reverse Polish Notation</title>
      <link>http://xmruibi.github.io/2015/10/25/convert-expression-to-reverse-polish-notation/</link>
      <pubDate>Sun, 25 Oct 2015 10:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/convert-expression-to-reverse-polish-notation/</guid>
      <description>

&lt;p&gt;Given an expression string array, return the Reverse Polish notation of this expression. (remove the parentheses)&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For the expression &lt;code&gt;[3 - 4 + 5]&lt;/code&gt; (which denote by &lt;code&gt;[&amp;quot;3&amp;quot;, &amp;quot;-&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;+&amp;quot;, &amp;quot;5&amp;quot;]&lt;/code&gt;), return &lt;code&gt;[3 4 - 5 +]&lt;/code&gt; (which denote by &lt;code&gt;[&amp;quot;3&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;-&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;+&amp;quot;]&lt;/code&gt;)&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Always consider stack firstly, when meet a reverse polish notation problem.&lt;/li&gt;
&lt;li&gt;The operator priority (&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;) &amp;gt; (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;), when get the operator is less priority than stack top element, pop the stack util the element has the same priority as the current operator and output the pop element in result list.&lt;/li&gt;
&lt;li&gt;Push the &amp;laquo;(&amp;raquo; always but pop the stack when get the &amp;laquo;)&amp;raquo; until stack has pop the corresponding &amp;laquo;(&amp;raquo;.&lt;/li&gt;
&lt;li&gt;When get the operand, just output in result list.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param expression: A string array
     * @return: The Reverse Polish notation of this expression
     */
    public ArrayList&amp;lt;String&amp;gt; convertToRPN(String[] expression) {
        Stack&amp;lt;String&amp;gt; ops = new Stack&amp;lt;&amp;gt;();
        ArrayList&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        for(String str : expression) {
            if(str.equals(&amp;quot;+&amp;quot;) || str.equals(&amp;quot;-&amp;quot;) ||str.equals(&amp;quot;*&amp;quot;) ||str.equals(&amp;quot;/&amp;quot;)) {
                while(!ops.isEmpty() &amp;amp;&amp;amp; operatorLevel(ops.peek()) &amp;gt;= operatorLevel(str))
                    res.add(ops.pop());
                ops.push(str);
            }else if(str.equals(&amp;quot;(&amp;quot;)){
                ops.push(str);
            }else if(str.equals(&amp;quot;)&amp;quot;)) {
                while(!ops.isEmpty() &amp;amp;&amp;amp; !ops.peek().equals(&amp;quot;(&amp;quot;))
                    res.add(ops.pop());
                if(!ops.isEmpty()) 
                    ops.pop(); // pop the &amp;quot;(&amp;quot;
            }else
                res.add(str);
        }
        while(!ops.isEmpty())
            res.add(ops.pop());
        return res;
    }
    
    private int operatorLevel(String op) {
        if(op.equals(&amp;quot;+&amp;quot;) || op.equals(&amp;quot;-&amp;quot;)) 
            return 1;
        else if(op.equals(&amp;quot;*&amp;quot;) ||op.equals(&amp;quot;/&amp;quot;))
            return 2;
        else
            return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Evaluate Reverse Polish Notation</title>
      <link>http://xmruibi.github.io/2015/10/25/evaluate-reverse-polish-notation/</link>
      <pubDate>Sun, 25 Oct 2015 10:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/evaluate-reverse-polish-notation/</guid>
      <description>

&lt;p&gt;Evaluate the value of an arithmetic expression in Reverse Polish Notation.&lt;/p&gt;

&lt;p&gt;Valid operators are &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;. Each operand may be an integer or another expression.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;	[&amp;quot;2&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;+&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;*&amp;quot;] -&amp;gt; ((2 + 1) * 3) -&amp;gt; 9
	[&amp;quot;4&amp;quot;, &amp;quot;13&amp;quot;, &amp;quot;5&amp;quot;, &amp;quot;/&amp;quot;, &amp;quot;+&amp;quot;] -&amp;gt; (4 + (13 / 5)) -&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Reverse Polish Notation problems always accompany with the stack as its data structure;&lt;/li&gt;
&lt;li&gt;Setup stack only to store the integer value;&lt;/li&gt;
&lt;li&gt;One pass the tokens array, when get the integer, insert the stack, while get the operator, to do the evaluate with pop two value from stack and push back the result after calculated;&lt;/li&gt;
&lt;li&gt;Its good to use &lt;code&gt;switch&lt;/code&gt; rather than &lt;code&gt;if&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param tokens The Reverse Polish Notation
     * @return the value
     */
    public int evalRPN(String[] tokens) {
        // By use stack
        Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        for(String str : tokens) {
            int curRes = 0;
            switch(str){
                case &amp;quot;+&amp;quot;:
                    curRes = (stack.isEmpty()?0:stack.pop()) + (stack.isEmpty()?0:stack.pop());
                    break;
                case &amp;quot;-&amp;quot;:
                    curRes = stack.isEmpty()?0:stack.pop();
                    curRes = (stack.isEmpty()?0:stack.pop()) - curRes;
                    break;
                case &amp;quot;*&amp;quot;:
                    curRes = (stack.isEmpty()?0:stack.pop()) *  (stack.isEmpty()?0:stack.pop());
                    break;
                case &amp;quot;/&amp;quot;:
                    curRes = stack.isEmpty()?0:stack.pop();
                    if(curRes == 0)
                        break;
                    curRes = (stack.isEmpty()?0:stack.pop()) / curRes;
                    break;
                default:
                    curRes = Integer.parseInt(str);
            }
            stack.push(curRes);
        }
        
        return stack.isEmpty()?0:stack.pop();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Binary Representation</title>
      <link>http://xmruibi.github.io/2015/10/24/binary-representation/</link>
      <pubDate>Sat, 24 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/24/binary-representation/</guid>
      <description>

&lt;p&gt;Given a (decimal - e.g. 3.72) number that is passed in as a string, return the binary representation that is passed in as a string. If the fractional part of the number can not be represented accurately in binary with at most 32 characters, return &lt;code&gt;ERROR&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For n = &lt;code&gt;&amp;quot;3.72&amp;quot;&lt;/code&gt;, return &lt;code&gt;&amp;quot;ERROR&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For n = &lt;code&gt;&amp;quot;3.5&amp;quot;&lt;/code&gt;, return &lt;code&gt;&amp;quot;11.1&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;For Integer part, we use &lt;code&gt;% 2&lt;/code&gt; to get each digit from lowest bit to highest bit, or use a loop to make &lt;code&gt;&amp;amp;&lt;/code&gt; with &lt;code&gt;1&lt;/code&gt; and left shift until it get zero.&lt;/li&gt;
&lt;li&gt;For decimal part, we can use $$\times2$$ approach. For example: &lt;code&gt;int n = 0.75; n*2 = 1.5;&lt;/code&gt; Therefore, the first digit of binary number after &lt;code&gt;.&lt;/code&gt; is 1 (i.e. 0.1).  After constructed the first digit, n= n*2-1;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
    * Therefore, the first digit of binary number after &#39;.&#39; is 1 (i.e. 0.1).  After constructed the first digit, n= n*2-1 
     *@param n: Given a decimal number that is passed in as a string
     *@return: A string
     */
    public String binaryRepresentation(String n) {
        int intPart = Integer.parseInt(n.substring(0, n.indexOf(&#39;.&#39;)));
        StringBuilder res = new StringBuilder();
        while(intPart != 0) {
            res.insert(0, &amp;quot;&amp;quot; + (intPart &amp;amp; 1));
            intPart &amp;gt;&amp;gt;= 1;
        }
        if(res.length() == 0)
            res.append(0);
        double decPart = Double.parseDouble(n.substring(n.indexOf(&#39;.&#39;)));
        String decBit = &amp;quot;&amp;quot;;
        // if it has decimal part, creat &#39;.&#39; in result string
        if(decPart &amp;gt; 0.0)
            res.append(&amp;quot;.&amp;quot;);
        // to count how many digit in decimal binary result
        int cnt = 0;
        while(decPart &amp;gt; 0.0) {
            double cur = (decPart * 2);
            cnt++;
            if(cnt &amp;gt; 32)
                return &amp;quot;ERROR&amp;quot;;
            if(cur &amp;gt;= 1) {
                res.append(1);
                decPart = cur - 1.0;
            }else {
                res.append(0);
                decPart = cur;
            }
        }
        
        return res.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>