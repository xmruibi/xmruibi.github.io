<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/</link>
    <description>Recent content on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Wed, 21 Oct 2015 15:16:26 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Parking Lot</title>
      <link>http://xmruibi.github.io/2015/10/21/parking-lot/</link>
      <pubDate>Wed, 21 Oct 2015 15:16:26 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/21/parking-lot/</guid>
      <description>

&lt;h1 id=&#34;parking-lot&#34;&gt;Parking Lot&lt;/h1&gt;

&lt;h2 id=&#34;basic-object&#34;&gt;Basic Object&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Vehicle

&lt;ul&gt;
&lt;li&gt;size of vehicle (small, medium, large)&lt;/li&gt;
&lt;li&gt;status of vehicle (run or parked)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sedan, SUV, Bus, Truck&amp;hellip; extends Vehicle&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Slot&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;size of slot&lt;/li&gt;
&lt;li&gt;status (available or not)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lot&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;hold slots in lot&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Vehicle&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Vehicle {
	private final int size;
	private final int lisense;
	private boolean status;
	private Lot lot;

	public Vehicle(int size) {
		this.size = size;
		lisense = this.hashCode();
		lot = Lot.getInstance();
	}

	public void setStatus(boolean status) {
		this.status = status;
	}

	private Slot findSlot() {

		Slot slot;
		switch (this.size) {
		case 1:
			slot = lot.getSmallSlots().remove(0);
		case 2:
			slot = lot.getCompactSlots().remove(0);
		case 3:
			slot = lot.getLargeSlots().remove(0);
		default:
			slot = null;
		}
		return slot;
	}

	public void park() {
		Slot slot = findSlot();
		if (slot != null) {
			lot.occupiedSlots.put(this.lisense, slot);
			slot.occupy(this);
		}
	}

	public void leave() {
		Slot slot = lot.occupiedSlots.remove(this.lisense);
		slot.release();
		switch (this.size) {
		case 1:
			lot.getSmallSlots().add(slot);
		case 2:
			lot.getCompactSlots().add(slot);
		case 3:
			lot.getLargeSlots().add(slot);
		}
	}
}

public class Car extends Vehicle{
	public Car(){
		super(1);		
	}
}
public class Truck extends Vehicle{
	public Truck(){
		super(2);		
	}
}
// ... other type of vehicle
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Lot&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Lot {
	private static Lot lot = null;

	private static final int NUMBER_OF_SMALL_SLOTS = 10;
	private static final int NUMBER_OF_COMPACT_SLOTS = 10;
	private static final int NUMBER_OF_LARGE_SLOTS = 10;

	public Map&amp;lt;Integer, Slot&amp;gt; occupiedSlots;
	private List&amp;lt;Slot&amp;gt; smallSlots;
	private List&amp;lt;Slot&amp;gt; compactSlots;
	private List&amp;lt;Slot&amp;gt; largeSlots;

	private Lot() {
		smallSlots = new LinkedList&amp;lt;&amp;gt;();
		compactSlots = new LinkedList&amp;lt;&amp;gt;();
		largeSlots = new LinkedList&amp;lt;&amp;gt;();
		occupiedSlots = new HashMap&amp;lt;&amp;gt;();
		for (int i = 1; i &amp;lt;= NUMBER_OF_SMALL_SLOTS; i++)
			smallSlots.add(new Slot(i, 1));

		for (int i = 1; i &amp;lt;= NUMBER_OF_COMPACT_SLOTS; i++)
			compactSlots.add(new Slot(i, 2));

		for (int i = 1; i &amp;lt;= NUMBER_OF_LARGE_SLOTS; i++)
			largeSlots.add(new Slot(i, 3));

	}

	public List&amp;lt;Slot&amp;gt; getSmallSlots() {
		return smallSlots;
	}

	public List&amp;lt;Slot&amp;gt; getCompactSlots() {
		return compactSlots;
	}

	public List&amp;lt;Slot&amp;gt; getLargeSlots() {
		return largeSlots;
	}

	public static Lot getInstance() {
		if (lot == null)
			lot = new Lot();
		return lot;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Slot&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class Slot {
	private final int id;
	private final int size;
	private boolean available;
	private Vehicle vehicle;

	public Slot(int id, int size) {
		this.id = id;
		this.size = size;
		this.available = true;
	}

	public void occupy(Vehicle v) {
		this.vehicle = v;
		this.available = false;
	}

	public void release() {
		this.vehicle = null;
		this.available = true;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Online Book Reader System</title>
      <link>http://xmruibi.github.io/2015/10/21/online-book-reader-system/</link>
      <pubDate>Wed, 21 Oct 2015 11:16:26 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/21/online-book-reader-system/</guid>
      <description>

&lt;h1 id=&#34;online-book-reader-system&#34;&gt;Online Book Reader System&lt;/h1&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This question comes from the book named &amp;laquo;Cracking Code Interview&amp;raquo;, Chapter 7; It is very very easy problem with thinking about the insert/remove/update/retrieve action.&lt;/p&gt;

&lt;h4 id=&#34;functionality&#34;&gt;Functionality&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;User Membership Creation and Extension&lt;/li&gt;
&lt;li&gt;Search the book in memory&lt;/li&gt;
&lt;li&gt;Reading the book&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;analysis&#34;&gt;Analysis&lt;/h2&gt;

&lt;h4 id=&#34;objects&#34;&gt;Objects&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Book:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ID&lt;/li&gt;
&lt;li&gt;Title&lt;/li&gt;
&lt;li&gt;Author&lt;/li&gt;
&lt;li&gt;Content&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Books: (In-memory storage for many book objects)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Set&lt;Book&gt;&lt;/li&gt;
&lt;li&gt;Method

&lt;ul&gt;
&lt;li&gt;find&lt;/li&gt;
&lt;li&gt;add&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;User&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ID&lt;/li&gt;
&lt;li&gt;Name&lt;/li&gt;
&lt;li&gt;accoutnType
-&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Users&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Set&lt;User&gt;&lt;/li&gt;
&lt;li&gt;Method

&lt;ul&gt;
&lt;li&gt;find&lt;/li&gt;
&lt;li&gt;add&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Chess Game</title>
      <link>http://xmruibi.github.io/2015/10/21/chess-game/</link>
      <pubDate>Wed, 21 Oct 2015 11:16:26 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/21/chess-game/</guid>
      <description>

&lt;h1 id=&#34;chess-game&#34;&gt;Chess Game&lt;/h1&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This typical question in many interview&amp;rsquo;s OO Design part;&lt;/p&gt;

&lt;h2 id=&#34;some-rules&#34;&gt;Some Rules:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Player chooses piece to move.&lt;/li&gt;
&lt;li&gt;Piece makes legal move according to its own move rules.&lt;/li&gt;
&lt;li&gt;In addition to purely move-based rules, there&amp;rsquo;s also capture logic, so a bishop cannot move from a1-h8 if there&amp;rsquo;s a piece sitting on c3.&lt;/li&gt;
&lt;li&gt;If the player was previous under check and the move does not remove the check, it must be undone.&lt;/li&gt;
&lt;li&gt;If the move exposes check, it must be undone / disallowed.&lt;/li&gt;
&lt;li&gt;If player captures a piece, remove the piece (including en passant!)&lt;/li&gt;
&lt;li&gt;If the piece is a pawn reaching the back rank, promote it.&lt;/li&gt;
&lt;li&gt;If the move is a castling, set the new position of the rook accordingly. But a king and rook can only castle if they haven&amp;rsquo;t moved, so you need to keep track of that. And if the king moves through a check to castle, that&amp;rsquo;s disallowed, too.&lt;/li&gt;
&lt;li&gt;If the move results in a stalemate or checkmate, the game is over.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;basic-object-design&#34;&gt;Basic Object Design&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Game:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hold the Board and Players&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Board (Singleton):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hold spots with 8$$\times$$8&lt;/li&gt;
&lt;li&gt;Move Piece&lt;/li&gt;
&lt;li&gt;Remove Piece&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Spot:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hold Pieces&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Piece (Abstract):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Concreted classes with 8 Pawns, 2 Rooks, 2 Bishops, 2 Knights, 1 Queen, 1 King&lt;/li&gt;
&lt;li&gt;Owner(color)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Player (Abstract):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Concreted classes for Human and Computer players&lt;/li&gt;
&lt;li&gt;Own Piece&lt;/li&gt;
&lt;li&gt;Commands List&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Command&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Piece&lt;/li&gt;
&lt;li&gt;Destination x, y&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-for-basic-part&#34;&gt;Solution for Basic Part&lt;/h2&gt;

&lt;h4 id=&#34;here-we-can-achieve-the-step-move-and-check-the-win-for-player&#34;&gt;Here we can achieve the step move and check the win for player&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Game:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Game{
	final static Board board;
	Player p1;
	Player p2;

	public Game() {
		board = new Board();
	}

	public boolean enterPlayer(Player p) {
		if(p1 == null)
			this.p1 = p;
		else if(p2 == null)
			this.p2 = p;
		else
			return false;

		board.initialize(p);
		return true;
	}

	public void processTurn(Player p) {
		// Player make a command and until it is valid
		// System input
		do{
			Command cmd = new Command(input);
			p.addCommand(cmd);
		}while(!board.executeMove(p));
	}

	public startGame(){
		// player enter the game:
		enterPlayer(new ComputerPlayer(&amp;quot;Computer&amp;quot;));
		enterPlayer(new HumanPlayer(&amp;quot;Bill&amp;quot;));

		while(true) {
			processTurn(p1);
			if(this.board.getWin()) {
				System.out.println(&amp;quot;P1 win!&amp;quot;);
				break;
			}
			processTurn(p2);
			if(this.board.getWin()) {
				System.out.println(&amp;quot;P2 win!&amp;quot;);
				break;
			}
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Board:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Board{

	private Spot[][] spots;
	private boolean win; // mark the win or not

	public Board(){
		win = false;
		spots = new Spot[8][8];
	}

	public void initialize(Player p){
		// put the pieces with initial status
		for(int i=0; i&amp;lt;p.getPieces().size(); i++){
            spots[p.getPieces().get(i).getX()][p.getPieces().get(i).getY()].occupySpot(p.getPieces().get(i));
        }
	}

	public boolean executeMove(Player p) {
		Command cmd = p.getCurrentCmd();
		Piece piece = cmd.getPiece();

		// check the move step is valid for piece
		if(!piece.validMove(this, cmd.curX, cmd.curY, cmd.desX, cmd.desY)) {
			// if not valid cmd remove the command and return false
			p.removeCurrentCmd();
			return false;
		}

		// check the two pieces side
		if(spot[cmd.desX][cmd.desY] != null &amp;amp;&amp;amp; spot[cmd.desX][cmd.desY].color == piece.color)
			return false;

		// check and change the state on spot
		Piece taken = spot[cmd.desX][cmd.desY].occupySpot(piece);
		if(taken != null &amp;amp;&amp;amp;taken.getClass().getName().equals(&amp;quot;King&amp;quot;))
			board.win = true;
		spot[cmd.curX][cmd.curY].releaseSpot;
		return true;
	}

	public boolean getWin() {
		return win;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Spot:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Spot {
    int x;
    int y;
    Piece piece;

    public Spot(int x, int y) {
        super();
        this.x = x;
        this.y = y;
        piece = null;
    }

    // return original piece
    public void occupySpot(Piece piece){
    	Piece origin = this.piece;
        //if piece already here, delete it, i. e. set it dead
        if(this.piece != null) {
            this.piece.setAvailable(false);
        }
        //place piece here
        this.piece = piece;
        return origin;
    }

    public boolean isOccupied() {
        if(piece != null)
            return true;
        return false;
    }

    public Piece releaseSpot() {
        Piece releasedPiece = this.piece;
        this.piece = null;
        return releasedPiece;
    }

    public Piece getPiece() {
    	return this.piece;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Pieces:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Piece {
    private int x;
    private int y;

    private boolean available; // mark the live or dead
    private int color; // mark the owner

    public Piece(boolean available, int x, int y, int color) {
        super();
        this.available = available;
        this.x = x;
        this.y = y;
        this.color = color;
    }


    public boolean isAvailable() {
        return available;
    }
    public void setAvailable(boolean available) {
        this.available = available;
    }
    public int getX() {
        return x;
    }
    public void setX(int x) {
        this.x = x;
    }
    public int getY() {
        return y;
    }
    public void setY(int y) {
        this.y = y;
    }

    public boolean isValid(Board board, int fromX, int fromY, int toX, int toY){
        // different by character of piece
    }

}

public class King extends Piece{ 
	@Override
    public boolean isValid(Board board, int fromX, int fromY, int toX, int toY) {
    }	
}
// ..... for Queen, Rook, Bishop, Pawn

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Player:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Player {

    public int color;

    private List&amp;lt;Piece&amp;gt; pieces = new ArrayList&amp;lt;&amp;gt;();

    private List&amp;lt;Command&amp;gt; cmds = new ArrayList&amp;lt;&amp;gt;();

    public Player(int color) {
        super();
        this.color = color;
        initializePieces();
    }

    public List&amp;lt;Piece&amp;gt; getPieces() {
        return pieces;
    }

    public Command getCurrentCmd(){
    	if(cmds != null || cmds.size() != 0)
    		return null;
    	return cmds.get(cmds.size() - 1);
    }

    public void removeCurrentCmd(){
    	if(cmds != null || cmds.size() != 0)
    		return;
    	cmds.remove(cmds.size() - 1);
    }

    public void initializePieces(){
        if(this.color == 1){
            for(int i=0; i&amp;lt;8; i++){ // draw pawns
                pieces.add(new Pawn(true,i,2, 1));
            }
            pieces.add(new Rook(true, 0, 0, 1));
            pieces.add(new Rook(true, 7, 0, 1));
            pieces.add(new Bishop(true, 2, 0, 1));
            pieces.add(new Bishop(true, 5, 0, 1));
            pieces.add(new Knight(true, 1, 0, 1));
            pieces.add(new Knight(true, 6, 0, 1));
            pieces.add(new Queen(true, 3, 0, 1));
            pieces.add(new King(true, 4, 0, 1));
        }
        else{
            for(int i=0; i&amp;lt;PAWNS; i++){ // draw pawns
                pieces.add(new Pawn(true,i,6, 0));
            }
            pieces.add(new Rook(true, 0, 7, 0));
            pieces.add(new Rook(true, 7, 7, 0));
            pieces.add(new Bishop(true, 2, 7, 0));
            pieces.add(new Bishop(true, 5, 7, 0));
            pieces.add(new Knight(true, 1, 7, 0));
            pieces.add(new Knight(true, 6, 7, 0));
            pieces.add(new Queen(true, 3, 7, 0));
            pieces.add(new King(true, 4, 7, 0));
        }

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Command&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Command {
	Piece piece;
	int curX, curY, desX, desY;
	public Commanc(Piece piece, int curX, int curY, int desX, int desY) {
		this.piece = piece; 
		this.curX = curX;
		this.curY = curY;
		this.desX = desX;
		this.desY = desY;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Deck of Card</title>
      <link>http://xmruibi.github.io/2015/10/21/deck-of-card/</link>
      <pubDate>Wed, 21 Oct 2015 10:16:26 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/21/deck-of-card/</guid>
      <description>

&lt;h1 id=&#34;deck-of-card&#34;&gt;Deck of Card&lt;/h1&gt;

&lt;p&gt;Design the data structure for a generic deck of cards. How you would subclass it to implement particular card games?&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;Card has suit and value; Suit has four kinds with Club, Spadem Heart and Diamond.&lt;/p&gt;

&lt;h4 id=&#34;about-enum-type&#34;&gt;About Enum Type&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;enum 类型不支持 public 和 protected 修饰符的构造方法，因此构造函数一定要是 private 或 friendly 的。也正因为如此，所以枚举对象是无法在程序中通过直接调用其构造方法来初始化的。&lt;/li&gt;
&lt;li&gt;定义 enum 类型时候，如果是简单类型 (No more constructor)，那么最后一个枚举值后不用跟任何一个符号；但如果有定制方法，那么最后一个枚举值与后面代码要用分号&amp;rsquo;;&amp;lsquo;隔开，不能用逗号或空格。&lt;/li&gt;
&lt;li&gt;由于 enum 类型的值实际上是通过运行期构造出对象来表示的，所以在 cluster 环境下，每个虚拟机都会构造出一个同义的枚举对象。因而在做比较操作时候就需要注意，如果直接通过使用等号 ( ‘ == ’ ) 操作符，这些看似一样的枚举值一定不相等，因为这不是同一个对象实例。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Card {
	// Define the Suit by Enum type
	public enum Suit {
		CLUBS(1), SPADE(2), HEART(3), DIAMOND(4);
		int value;
		private Suit(int val) {
			this.value = val;
		}
	}

	// Card has suit and value, only two kind of data need to store
	int val;
	Suit suit;


	public Card(int value, Suit suit) {
		this.val = value;
		this.suit = suit;
	}

	public int getVal(){
		return this.val;
	}

	public Suit getSuit(){
		return this.suit;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;blackjack&#34;&gt;BlackJack&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Face cards (kings, queens, and jacks) are counted as ten points.&lt;/li&gt;
&lt;li&gt;Ace can be counted as 1 point or 11 points&lt;/li&gt;
&lt;li&gt;Other cards with value less than ten should be counted as what it values.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
class BlackJack extends Card{
	public BlackJack(int val, Suit suit) {
		super(val, suit);
	}

	@Override
	public int getVal(){
		int value = super.getVal();
		if(value &amp;lt; 10)
			return value；
		else if(value == 1)
			return 11;
		return 10;
	}

	public boolean isAce(){
		return super.getVal() == 1;
	}
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Interleaving String</title>
      <link>http://xmruibi.github.io/2015/10/20/interleaving-string/</link>
      <pubDate>Tue, 20 Oct 2015 19:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/interleaving-string/</guid>
      <description>

&lt;p&gt;Given three strings: s1, s2, s3, determine whether s3 is formed by the interleaving of s1 and s2.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For s1 = &lt;code&gt;&amp;quot;aabcc&amp;quot;&lt;/code&gt;, s2 = &lt;code&gt;&amp;quot;dbbca&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When s3 = &lt;code&gt;&amp;quot;aadbbcbcac&amp;quot;&lt;/code&gt;, return true.
When s3 = &lt;code&gt;&amp;quot;aadbbbaccc&amp;quot;&lt;/code&gt;, return false.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n2) time or better&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Typical dynamic programming with subsequence problem.&lt;/li&gt;
&lt;li&gt;Set up a 2-D dp boolean table to memorized:

&lt;ul&gt;
&lt;li&gt;Initial: memo[0][0] = true;&lt;/li&gt;
&lt;li&gt;two conditions: s1 find matched or s2 find matched;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memo[i][j] = ( i &amp;gt; 0 &amp;amp;&amp;amp; s1.charAt(i - 1) == s3.charAt(i + j - 1) &amp;amp;&amp;amp; memo[i - 1][j]) || (s2.charAt(j - 1) == s3.charAt(i + j - 1) &amp;amp;&amp;amp; memo[i][j - 1])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * Determine whether s3 is formed by interleaving of s1 and s2.
     * @param s1, s2, s3: As description.
     * @return: true or false.
     */
    public boolean isInterleave(String s1, String s2, String s3) {

        if(s1 == null || s2 == null)
            return false;
        if(s1.length() + s2.length() != s3.length())
            return false;
            
        boolean[][] memo = new boolean[s1.length() + 1][s2.length() + 1];
        for(int i = 0; i &amp;lt;= s1.length(); i++) {
            for(int j = 0; j &amp;lt;= s2.length(); j++) {
                if(i == 0 &amp;amp;&amp;amp; j == 0)
                    memo[i][j] = true;
                else{
                    if(i &amp;gt; 0 &amp;amp;&amp;amp; s1.charAt(i - 1) == s3.charAt(i + j - 1))
                        memo[i][j] = memo[i - 1][j];
                    if(j &amp;gt; 0 &amp;amp;&amp;amp;s2.charAt(j - 1) == s3.charAt(i + j - 1))
                        memo[i][j] |= memo[i][j - 1];
                }
            }
        }
        
        return memo[s1.length()][s2.length()];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Binary Search Tree Iterator</title>
      <link>http://xmruibi.github.io/2015/10/20/binary-search-tree-iterator/</link>
      <pubDate>Tue, 20 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/binary-search-tree-iterator/</guid>
      <description>

&lt;p&gt;Design an iterator over a binary search tree with the following rules:&lt;/p&gt;

&lt;p&gt;Elements are visited in ascending order (i.e. an in-order traversal)
next() and hasNext() queries run in O(1) time in average.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For the following binary search tree, in-order traversal by using iterator is [1, 6, 10, 11, 12]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   10
 /    \
1      11
 \       \
  6       12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###Challenge
Extra memory usage O(h), h is the height of the tree.&lt;/p&gt;

&lt;p&gt;Super Star: Extra memory usage O(1)&lt;/p&gt;

&lt;h2 id=&#34;think-1&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Stack: Preorder&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    // O(height of tree) space to store current left branch nodes
    Stack&amp;lt;TreeNode&amp;gt; stack;

    //@param root: The root of binary tree.
    public Solution(TreeNode root) {

        stack = new Stack&amp;lt;&amp;gt;();
        if(root == null)
            return;
        stack.push(root);
        TreeNode left = root.left;
        while(left != null) {
            stack.push(left);
            left = left.left;
        }
    }

    //@return: True if there has next node, or false
    public boolean hasNext() {
        return !stack.isEmpty();
    }
    
    //@return: return next node
    public TreeNode next() {
        TreeNode pop = stack.pop();

        // each time pop a node, push left branch nodes for current pop node&#39;s right child
        TreeNode left = pop.right;
        while(left != null) {
            stack.push(left);
            left = left.left;
        }
        return pop;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find the Weak Connected Component in the Directed Graph</title>
      <link>http://xmruibi.github.io/2015/10/20/find-the-weak-connected-component-in-the-directed-graph/</link>
      <pubDate>Tue, 20 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/find-the-weak-connected-component-in-the-directed-graph/</guid>
      <description>

&lt;p&gt;Find the number Weak Connected Component in the directed graph. Each node in the graph contains a label and a list of its neighbors. (a connected set of a directed graph is a subgraph in which any two vertices are connected by direct edge path.)&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given graph:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A-----&amp;gt;B  C
 \     |  | 
  \    |  |
   \   |  |
    \  v  v
     -&amp;gt;D  E &amp;lt;- F
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Return &lt;code&gt;{A,B,D}&lt;/code&gt;, &lt;code&gt;{C,E,F}&lt;/code&gt;. Since there are two connected component which are &lt;code&gt;{A,B,D}&lt;/code&gt; and &lt;code&gt;{C,E,F}&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;Sort the element in the set in increasing order&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Union Find&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class UnionFind{
	// child - parent pair table:
	HashMap&amp;lt;Integer, Integer&amp;gt; pairTab;

	public UnionFind(HashSet&amp;lt;Integer&amp;gt; set) {
		pairTab = new HashMap&amp;lt;&amp;gt;();
		for(Integer i : set) 
			pairTab.put(i, i);
	}

	public int find(int x) {
		int parent = pairTab.get(x);
		while(parent != pairTab.get(parent)){
			parent = pairTab.get(parent);
		}
		return parent;
	}

	public void union(int x, int y) {
		int parent_x = find(x);
		int parent_y = find(y);
		if(parent_x != parent_y)
			pairTab.put(parent_x, parent_y);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nodes a array of Directed graph node
     * @return a connected set of a directed graph
     */
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; connectedSet2(ArrayList&amp;lt;DirectedGraphNode&amp;gt; nodes) {
        
        HashSet&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        for(DirectedGraphNode node : nodes) 
            set.add(node.label);
        
        // to make union
        UnionFind uf = new UnionFind(set);
        for(DirectedGraphNode x : nodes) {
            for(DirectedGraphNode y : x.neighbors) {
                uf.union(x.label, y.label);
            }
        }
        
        HashMap&amp;lt;Integer, ArrayList&amp;lt;Integer&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(Integer label : set) {
            int parent = uf.find(label);
            if(!map.containsKey(parent)) 
                map.put(parent, new ArrayList&amp;lt;Integer&amp;gt;());
            ArrayList&amp;lt;Integer&amp;gt; cur = map.get(parent);
            cur.add(label);
            map.put(parent, cur);
        }
        
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        for(Map.Entry&amp;lt;Integer, ArrayList&amp;lt;Integer&amp;gt;&amp;gt; entry : map.entrySet()) {
            Collections.sort(entry.getValue());
            res.add(entry.getValue());
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Divide Two Integers</title>
      <link>http://xmruibi.github.io/2015/10/20/divide-two-integers/</link>
      <pubDate>Tue, 20 Oct 2015 10:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/divide-two-integers/</guid>
      <description>

&lt;p&gt;Divide two integers without using multiplication, division and mod operator.&lt;/p&gt;

&lt;p&gt;If it is overflow, return &lt;code&gt;2147483647&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given dividend = &lt;code&gt;100&lt;/code&gt; and divisor = &lt;code&gt;9&lt;/code&gt;, return &lt;code&gt;11&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Bitwise Idea:

&lt;ul&gt;
&lt;li&gt;Get the result sign (negative or positive) by &lt;code&gt;((dividend ^ divisor) &amp;gt;&amp;gt;&amp;gt; 31) == 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;This question contains many corner cases!&lt;/li&gt;
&lt;li&gt;Firstly, check the corner cases in following steps:

&lt;ul&gt;
&lt;li&gt;Divisor is zero? return &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Dividend is &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;?

&lt;ul&gt;
&lt;li&gt;if divisor is negative one? you cannot get the positive &lt;code&gt;MIN_VALUE&lt;/code&gt; so return &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dividend += Math.abs(divisor)&lt;/code&gt; so that the dividend become away from overflow but that leads the res increase one;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Divisor is &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;? return res; To avoid the inaccurate from above operation;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Make dividend and divisor both positive;&lt;/li&gt;
&lt;li&gt;Then, the main operation to do the binary substraction;

&lt;ul&gt;
&lt;li&gt;Get the most higher position(&lt;code&gt;digit&lt;/code&gt;) for bit one with increasing the divisor until it is just larger than (&lt;code&gt;dividend &amp;gt;&amp;gt; 1&lt;/code&gt;): divisor cannot larger than dividend so that we use the &lt;code&gt;dividend&amp;gt;&amp;gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Get result by add the &lt;code&gt;1&amp;lt;&amp;lt;digit&lt;/code&gt; (current bit position should be one) and &lt;code&gt;dividend -= divisor&lt;/code&gt; but if divisor larger than dividend which means current bit position should be zero so just reduce digit and divisor should shift right one position each time;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param dividend the dividend
     * @param divisor the divisor
     * @return the result
     */
    public int divide(int dividend, int divisor) {
        int res = 0;
        if(divisor == 0)
            return Integer.MAX_VALUE;
        boolean neg = ((dividend ^ divisor) &amp;gt;&amp;gt;&amp;gt; 31) == 1;  
        if(dividend == Integer.MIN_VALUE) {
            // since the dividend is negative number now so we plus the abs(divisor)
            dividend += Math.abs(divisor);
            if(divisor == -1)
                return Integer.MAX_VALUE;
            res++;
        }
        
        if(divisor == Integer.MIN_VALUE)
            return res;
        
        // the highest position for bit in result   
        int digit = 0;
        dividend = Math.abs(dividend);  
        divisor = Math.abs(divisor);
        while(divisor &amp;lt;= (dividend&amp;gt;&amp;gt;1)) {
            divisor &amp;lt;&amp;lt;= 1;
            digit ++;
        }
        
        while(digit&amp;gt;=0){
            if(dividend&amp;gt;=divisor){
                res += (1&amp;lt;&amp;lt;digit);
                dividend-=divisor;
            }
            divisor&amp;gt;&amp;gt;=1;
            digit--;
        }
        return neg?-res:res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Digit Counts</title>
      <link>http://xmruibi.github.io/2015/10/20/digit-counts/</link>
      <pubDate>Tue, 20 Oct 2015 10:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/digit-counts/</guid>
      <description>

&lt;p&gt;Count the number of k&amp;rsquo;s between 0 and n. k can be 0 - 9.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;if n=12, k=1 in &lt;code&gt;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]&lt;/code&gt;, we have &lt;code&gt;FIVE&lt;/code&gt; 1&amp;rsquo;s &lt;code&gt;(1, 10, 11, 12)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think-1&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Brute Force: Check each digit in number form (0 -&amp;gt; n) then get the count;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public int digitCounts(int k, int n) {
        int[] record = new int[10];
        Arrays.fill(record,0);
        for (int i=0;i&amp;lt;=n;i++){
            String temp = Integer.toString(i);
            for (int j=0;j &amp;lt; temp.length();j++){
                int ind = (int) (temp.charAt(j)-&#39;0&#39;);
                record[ind]++;
            }
        }
        return record[k];            
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Math:

&lt;ul&gt;
&lt;li&gt;When current digit less than &lt;code&gt;k&lt;/code&gt;, the current count should be &lt;code&gt;higher digits x digit position&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;When current digit equal to &lt;code&gt;k&lt;/code&gt;, the current count should be &lt;code&gt;higher digits x digit position + lower digits + 1&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;When current digit larger than &lt;code&gt;k&lt;/code&gt;, the current count should be &lt;code&gt;higher digits + 1(itself) x digit position&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;When &lt;code&gt;k&lt;/code&gt; == 0 and the current digit larger than &lt;code&gt;k&lt;/code&gt;, the higher digits x digit position and it need to add one in the last result;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /*
     * param k : As description.
     * param n : As description.
     * return: An integer denote the count of digit k in 1..n
     */
    public int digitCounts(int k, int n) {
        int digit = 1;
        int cnt = 0;
        while(digit &amp;lt;= n) {
            int low = n % digit; // lower digits;
            int high = n / (digit*10); // higher digits;
            int cur = n / digit % 10;
            if(cur == k) {
                // higher digits * digit + lower digits + 1;
                cnt += ((high * digit) + low + 1);
            }else if(cur &amp;lt; k) {
                // higher digits * digit
                cnt += (high * digit);
            }else{
                // (higher digits + 1: itself) * digit
                cnt += ((high + (k == 0?0:1)) * digit);   
            }
            digit *= 10;
        }
        
        return cnt + (k == 0 ? 1 : 0);
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Number of Airplanes in the Sky</title>
      <link>http://xmruibi.github.io/2015/10/19/number-of-airplanes-in-the-sky/</link>
      <pubDate>Mon, 19 Oct 2015 22:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/number-of-airplanes-in-the-sky/</guid>
      <description>

&lt;p&gt;Given an interval list which are flying and landing time of the flight. How many airplanes are on the sky at most?&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For interval list &lt;code&gt;[[1,10],[2,3],[5,8],[4,7]]&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;If landing and flying happens at the same time, we consider landing should happen at first.&lt;/p&gt;

&lt;h2 id=&#34;think-1&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Array Method (Naive):

&lt;ul&gt;
&lt;li&gt;Use an integer array to count segment occurence.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    /**
     * Array Method:
     * @param intervals: An interval array
     * @return: Count of airplanes are in the sky.
     */
    public int countOfAirplanes(List&amp;lt;Interval&amp;gt; airplanes) { 
        
        // find the min and max value in interval list;
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        for(Interval interval : airplanes) {
            min = Math.min(min, interval.start);
            max = Math.max(max, interval.end);
        }

        int maxCnt = 0;
        int[] segment = new int[max - min + 1];
        for(Interval interval : airplanes) {
            for(int i = interval.start; i &amp;lt; interval.end; i++) {
                segment[i - min]++;
                maxCnt = Math.max(maxCnt, segment[i - min]);
            }
        }
        return maxCnt;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Customized Structure:

&lt;ul&gt;
&lt;li&gt;Point Class: mark &lt;code&gt;int time&lt;/code&gt; and (&lt;code&gt;boolean start/end&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Mark those Points ordered by time.&lt;/li&gt;
&lt;li&gt;One pass all points and count increase when touch start but decrease when end;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    /**
     * Point Method:
     * @param intervals: An interval array
     * @return: Count of airplanes are in the sky.
     */
    public int countOfAirplanes(List&amp;lt;Interval&amp;gt; airplanes) { 

    	// create a list with point class
    	List&amp;lt;Point&amp;gt; points = new ArrayList&amp;lt;&amp;gt;();
    	for(Interval interval : airplanes) {
    		points.add(new Point(interval.start, 1));
    		points.add(new Point(interval.end, 0));
    	}

    	// sort
    	Collections.sort(points, new Comparator&amp;lt;Point&amp;gt;(){
    	    @Override
    	    public int compare(Point p1, Point p2) {
    	         if(p1.time == p2.time) return p1.flag - p2.flag;
                 else return p1.time - p2.time;
    	    }
    	});

    	// one pass for count
    	int count = 0;
    	int max = 0; // record the peak count;
    	for(Point p : points) {
    		if(p.flag == 1)
    			count++;
    		else
    			count--;
    		max = Math.max(max, count);
    	}

    	return max;
	}

	private class Point{
		int time;
		int flag;
		public Point(int time, int flag) {
			this.time = time;
			this.flag = flag;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Array Method (Naive):&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two pass and one of pass has one more inner loop (segment size: k): o(n + n*k) -&amp;gt; O(n^2);
An array to store occurence frequence: Space: O(n);&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Next Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/next-permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/next-permutation/</guid>
      <description>

&lt;p&gt;Given a list of integers, which denote a permutation.&lt;/p&gt;

&lt;p&gt;Find the next permutation in ascending order.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;[1,3,2,3]&lt;/code&gt;, the next permutation is &lt;code&gt;[1,3,3,2]&lt;/code&gt;
For &lt;code&gt;[4,3,2,1]&lt;/code&gt;, the next permutation is &lt;code&gt;[1,2,3,4]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The list may contains duplicate integers.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;字典序算法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从后往前寻找索引满足 a[k] &amp;lt; a[k + 1], 如果此条件不满足，则说明已遍历到最后一个。&lt;/li&gt;
&lt;li&gt;如 k == 0, 说明是字典序最后一位， 因此直接倒置整个数组即可.&lt;/li&gt;
&lt;li&gt;从后往前遍历，找到第一个比a[k]大的数a[l], 即a[k] &amp;lt; a[l].&lt;/li&gt;
&lt;li&gt;交换a[k]与a[l].&lt;/li&gt;
&lt;li&gt;反转k + 1 ~ n之间的元素.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nums: an array of integers
     * @return: return nothing (void), do not return anything, modify nums in-place instead
     */
    public int[] nextPermutation(int[] nums) {
        if(nums == null || nums.length == 1)
            return nums;
        
        // step1: find nums[i] &amp;lt; nums[i + 1]
        int i = 0;
        for (i = nums.length - 2; i &amp;gt;= 0; i--) {
            if (nums[i] &amp;lt; nums[i + 1]) {
                break;
            } else if (i == 0) {
                // reverse nums if reach maximum
                reverse(nums, 0, nums.length - 1);
                return nums;
            }
        }
        // step2: find nums[i] &amp;lt; nums[j]
        int j = 0;
        for (j = nums.length - 1; j &amp;gt; i; j--) {
            if (nums[i] &amp;lt; nums[j]) {
                break;
            }
        }
        // step3: swap betwenn nums[i] and nums[j]
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
        
        // step4: reverse between [i + 1, n - 1]
        reverse(nums, i + 1, nums.length - 1);

        return nums;
    }
    
    private void reverse(int[] nums, int l, int r) {
        while(l &amp;lt; r) {
            int tmp = nums[l];
            nums[l++] = nums[r];
            nums[r--] = tmp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis&lt;/h2&gt;

&lt;p&gt;At most, two pass o(2*n) -&amp;gt; O(n); Constant Space Complexity: O(1)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation/</guid>
      <description>

&lt;p&gt;Given a list of numbers, return all possible permutations.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For nums = [1,2,3], the permutations are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it without recursion.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;h4 id=&#34;method-one&#34;&gt;Method One:&lt;/h4&gt;

&lt;p&gt;Backtracking, with memorized the element usage, which takes space, or we can search on arraylist(more time);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /**
     * @param nums: A list of integers.
     * @return: A list of permutations.
     */
    public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; permute(ArrayList&amp;lt;Integer&amp;gt; nums) {

        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(nums == null || nums.size() == 0)
            return res;
        helper(res, new ArrayList&amp;lt;Integer&amp;gt;(), nums);
        return res;
    }
    
    private void helper(ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; res, ArrayList&amp;lt;Integer&amp;gt; list,  ArrayList&amp;lt;Integer&amp;gt; nums ) {
        
        if(list.size() == nums.size()) {
            res.add(new ArrayList&amp;lt;Integer&amp;gt;(list));
            return;
        }
        
        for(int i = 0; i&amp;lt;nums.size(); i++){
        	// to check if this number already taken
            if(list.contains(nums.get(i)))
                continue;
            
            list.add(nums.get(i));
            helper(res, list, nums);
            list.remove(list.size() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;method-two&#34;&gt;Method Two:&lt;/h4&gt;

&lt;p&gt;Swap: &lt;a href=&#34;https://www.cs.princeton.edu/~rs/talks/perms.pdf&#34;&gt;Reference&lt;/a&gt;;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://xmruibi.github.io/media/PermutationSwap.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
  private static Set&amp;lt;Integer&amp;gt; exchPermutation(int[] arr) {
    Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
    int i = 0, num = 0;
    outer: while(true) {
      
      while(i &amp;lt; arr.length - 1) {
        num = exchGenerate(arr, i, ++i);
        if(set.contains(num))
          break outer;
        set.add(num);
      }
      
      num = exchGenerate(arr, 0, 1);
      if(set.contains(num))
        break outer;
      set.add(num);
      
      while(i &amp;gt; 0) {
        num = exchGenerate(arr, --i, i+1);
        if(set.contains(num))
          break outer;
        set.add(num);
      }
      
      num = exchGenerate(arr, arr.length - 2, arr.length - 1);
      if(set.contains(num))
        break outer;
      set.add(num);
    }
    return set;
  }
  
  private static int exchGenerate(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
    
    int res = 0;
    for(int n : arr){
      res = res*10 + n;
    }
    return res;
  }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Previous Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/previous-permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/previous-permutation/</guid>
      <description>

&lt;p&gt;Given a list of integers, which denote a permutation.&lt;/p&gt;

&lt;p&gt;Find the previous permutation in ascending order.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;[1,3,2,3]&lt;/code&gt;, the previous permutation is &lt;code&gt;[1,2,3,3]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For &lt;code&gt;[1,2,3,4]&lt;/code&gt;, the previous permutation is [&lt;code&gt;4,3,2,1]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The list may contains duplicate integers.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;step 1: find last nums[k] &amp;gt; nums[k + 1];&lt;/li&gt;
&lt;li&gt;step 2: find last nums[i] &amp;gt; nums[k];&lt;/li&gt;
&lt;li&gt;step 3: swap i, j;&lt;/li&gt;
&lt;li&gt;step 4: reverse num after i;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nums: A list of integers
     * @return: A list of integers that&#39;s previous permuation
     */
    public ArrayList&amp;lt;Integer&amp;gt; previousPermuation(ArrayList&amp;lt;Integer&amp;gt; nums) {
        if(nums == null || nums.size() &amp;lt;= 1)
            return nums;
            
        // step 1: find last nums[k] &amp;gt; nums[k + 1]
        int i = nums.size() - 2;
        for (; i &amp;gt;= 0; i--) {
            if (nums.get(i) &amp;gt; nums.get(i + 1)) {
                break;
            }
            if(i &amp;lt;= 0) {
                reverse(nums, 0, nums.size() - 1);
                return nums;
            }
        }

        // step 2: find last nums[i] &amp;gt; nums[k]
        int j = nums.size() - 1;
        for (; j &amp;gt; i; j--) {
            if (nums.get(i) &amp;gt; nums.get(j)) {
                break;
            }
        }
        
        // step 3: swap i, j
        Collections.swap(nums, i, j);
        
        // step 4: reverse num after i
        reverse(nums, i + 1, nums.size() - 1);
        
        return nums;
    }
    
    private void reverse(ArrayList&amp;lt;Integer&amp;gt; nums,  int start, int end) {
        for (int i = start, j = end; i &amp;lt; j; i++, j--) {
            Collections.swap(nums, i, j);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Permutation Sequence</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation-sequence/</link>
      <pubDate>Mon, 19 Oct 2015 11:45:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation-sequence/</guid>
      <description>

&lt;p&gt;Given n and k, return the k-th permutation sequence.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For n = 3, all permutations are listed as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;123&amp;quot;
&amp;quot;132&amp;quot;
&amp;quot;213&amp;quot;
&amp;quot;231&amp;quot;
&amp;quot;312&amp;quot;
&amp;quot;321&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If k = &lt;code&gt;4&lt;/code&gt;, the fourth permutation is &amp;laquo;&lt;code&gt;231&lt;/code&gt;&amp;laquo;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;n will be between 1 and 9 inclusive.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n*k) in time complexity is easy, can you do it in O(n^2) or less?&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;a1,a2,a3&amp;hellip;..an的permutation 如果确定了a1,那么剩下的permutation就有(n-1)!种 所以 a1 = k / (n-1)! k2 = k % (n-1)! a2 = k2 / (n-2)!&lt;/p&gt;

&lt;p&gt;要注意的是&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;得到的应该是剩下选择数字的index,而不是value,所以要建一个存储可用数字的list&lt;/li&gt;
&lt;li&gt;在用完一个数字后要将它从list中删去&lt;/li&gt;
&lt;li&gt;array是0-based index, 那么K也应该减去1变为0-based的 (&lt;code&gt;k--&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /**
      * @param n: n
      * @param k: the kth permutation
      * @return: return the k-th permutation
      */
    public String getPermutation(int n, int k) {
        
        int[] factors = new int[n + 1];
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        factors[0] = 1;
        for(int i = 1; i &amp;lt;= n; i++) {
            factors[i] = i * factors[i-1];
            list.add(i);
        }
        
        StringBuilder sb = new StringBuilder();
        // for index alignment： e.g: k == 12, k / 6 = 2, 
        // however, it should still belong the number start for list.get(1); So here need to make a alignment
        k--;
        while(n &amp;gt; 1) {
            int index = k / factors[n-1];
            sb.append(list.remove(index));
            k %= factors[n-1];
            n--;
        }
        sb.append(list.get(0));
        return sb.toString();
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Permutation Index II</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation-index-ii/</link>
      <pubDate>Mon, 19 Oct 2015 11:45:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation-index-ii/</guid>
      <description>

&lt;p&gt;Given a permutation which may contain repeated numbers, find its index in all the permutations of these numbers, which are ordered in lexicographical order. The index begins at 1.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given the permutation &lt;code&gt;[1, 4, 2, 2]&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;The key is counting from low digit(right) to higher digit(left), and checking how many digits are less than current digits. Then using that count as the coefficient with positional weight. However, there are duplicates occured. So that means we can use a hash map to do the count.
But the positional system should be modified. The multiple of the factorial of the duplicates occurence should be divided by original position system. That means the &lt;code&gt;entry.value&lt;/code&gt; need to to the factorial and multiply those factors.
Why? For example, n numbers with 2 duplicates, like &lt;code&gt;2,4,3,3&lt;/code&gt;, when &lt;code&gt;4&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param A an integer array
     * @return a long integer
     */
    public long permutationIndexII(int[] A) {
        if(A == null || A.length == 0)
            return 0L;
        
        int pos = 2;
        long factor = 1;
        long index = 1;
        for(int i = A.length - 2; i &amp;gt;= 0; i--) {
            HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
            int cnt = 0;
            // count itself
            map.put(A[i], 1);
            for(int j = i + 1; j &amp;lt; A.length; j++) {
                // count all occurence on following element in Array
                map.put(A[j], map.containsKey(A[j])?map.get(A[j])+1:1);
                if(A[i] &amp;gt; A[j])
                    cnt++;
            }
            index += (cnt*factor)/factorialMultiple(map);
            factor *= pos;
            pos++;
        }
        
        return index;
    }
    
    private int factorialMultiple(HashMap&amp;lt;Integer, Integer&amp;gt; map) {
        int res = 1;
        for(int value : map.values()) {
            // do the factor on occurence
            int factor = 1;
            for(int i = 1; i &amp;lt;= value; i++)
                factor*= i;
            // get the multiple of occurence factor
            res *= factor;
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>