<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/</link>
    <description>Recent content on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Mon, 19 Oct 2015 22:43:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Number of Airplanes in the Sky</title>
      <link>http://xmruibi.github.io/2015/10/19/number-of-airplanes-in-the-sky/</link>
      <pubDate>Mon, 19 Oct 2015 22:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/number-of-airplanes-in-the-sky/</guid>
      <description>

&lt;p&gt;Given an interval list which are flying and landing time of the flight. How many airplanes are on the sky at most?&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For interval list &lt;code&gt;[[1,10],[2,3],[5,8],[4,7]]&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;If landing and flying happens at the same time, we consider landing should happen at first.&lt;/p&gt;

&lt;h2 id=&#34;think-1&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Array Method (Naive):

&lt;ul&gt;
&lt;li&gt;Use an integer array to count segment occurence.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    /**
     * Array Method:
     * @param intervals: An interval array
     * @return: Count of airplanes are in the sky.
     */
    public int countOfAirplanes(List&amp;lt;Interval&amp;gt; airplanes) { 
        
        // find the min and max value in interval list;
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        for(Interval interval : airplanes) {
            min = Math.min(min, interval.start);
            max = Math.max(max, interval.end);
        }

        int maxCnt = 0;
        int[] segment = new int[max - min + 1];
        for(Interval interval : airplanes) {
            for(int i = interval.start; i &amp;lt; interval.end; i++) {
                segment[i - min]++;
                maxCnt = Math.max(maxCnt, segment[i - min]);
            }
        }
        return maxCnt;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Customized Structure:

&lt;ul&gt;
&lt;li&gt;Point Class: mark &lt;code&gt;int time&lt;/code&gt; and (&lt;code&gt;boolean start/end&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Mark those Points ordered by time.&lt;/li&gt;
&lt;li&gt;One pass all points and count increase when touch start but decrease when end;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    /**
     * Point Method:
     * @param intervals: An interval array
     * @return: Count of airplanes are in the sky.
     */
    public int countOfAirplanes(List&amp;lt;Interval&amp;gt; airplanes) { 

    	// create a list with point class
    	List&amp;lt;Point&amp;gt; points = new ArrayList&amp;lt;&amp;gt;();
    	for(Interval interval : airplanes) {
    		points.add(new Point(interval.start, 1));
    		points.add(new Point(interval.end, 0));
    	}

    	// sort
    	Collections.sort(points, new Comparator&amp;lt;Point&amp;gt;(){
    	    @Override
    	    public int compare(Point p1, Point p2) {
    	         if(p1.time == p2.time) return p1.flag - p2.flag;
                 else return p1.time - p2.time;
    	    }
    	});

    	// one pass for count
    	int count = 0;
    	int max = 0; // record the peak count;
    	for(Point p : points) {
    		if(p.flag == 1)
    			count++;
    		else
    			count--;
    		max = Math.max(max, count);
    	}

    	return max;
	}

	private class Point{
		int time;
		int flag;
		public Point(int time, int flag) {
			this.time = time;
			this.flag = flag;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Array Method (Naive):&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two pass and one of pass has one more inner loop (segment size: k): o(n + n*k) -&amp;gt; O(n^2);
An array to store occurence frequence: Space: O(n);&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Next Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/next-permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/next-permutation/</guid>
      <description>

&lt;p&gt;Given a list of integers, which denote a permutation.&lt;/p&gt;

&lt;p&gt;Find the next permutation in ascending order.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;[1,3,2,3]&lt;/code&gt;, the next permutation is &lt;code&gt;[1,3,3,2]&lt;/code&gt;
For &lt;code&gt;[4,3,2,1]&lt;/code&gt;, the next permutation is &lt;code&gt;[1,2,3,4]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The list may contains duplicate integers.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;字典序算法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从后往前寻找索引满足 a[k] &amp;lt; a[k + 1], 如果此条件不满足，则说明已遍历到最后一个。&lt;/li&gt;
&lt;li&gt;如 k == 0, 说明是字典序最后一位， 因此直接倒置整个数组即可.&lt;/li&gt;
&lt;li&gt;从后往前遍历，找到第一个比a[k]大的数a[l], 即a[k] &amp;lt; a[l].&lt;/li&gt;
&lt;li&gt;交换a[k]与a[l].&lt;/li&gt;
&lt;li&gt;反转k + 1 ~ n之间的元素.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nums: an array of integers
     * @return: return nothing (void), do not return anything, modify nums in-place instead
     */
    public int[] nextPermutation(int[] nums) {
        if(nums == null || nums.length == 1)
            return nums;
        
        // step1: find nums[i] &amp;lt; nums[i + 1]
        int i = 0;
        for (i = nums.length - 2; i &amp;gt;= 0; i--) {
            if (nums[i] &amp;lt; nums[i + 1]) {
                break;
            } else if (i == 0) {
                // reverse nums if reach maximum
                reverse(nums, 0, nums.length - 1);
                return nums;
            }
        }
        // step2: find nums[i] &amp;lt; nums[j]
        int j = 0;
        for (j = nums.length - 1; j &amp;gt; i; j--) {
            if (nums[i] &amp;lt; nums[j]) {
                break;
            }
        }
        // step3: swap betwenn nums[i] and nums[j]
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
        
        // step4: reverse between [i + 1, n - 1]
        reverse(nums, i + 1, nums.length - 1);

        return nums;
    }
    
    private void reverse(int[] nums, int l, int r) {
        while(l &amp;lt; r) {
            int tmp = nums[l];
            nums[l++] = nums[r];
            nums[r--] = tmp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis&lt;/h2&gt;

&lt;p&gt;At most, two pass o(2*n) -&amp;gt; O(n); Constant Space Complexity: O(1)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation/</guid>
      <description>

&lt;p&gt;Given a list of numbers, return all possible permutations.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For nums = [1,2,3], the permutations are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it without recursion.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;h4 id=&#34;method-one&#34;&gt;Method One:&lt;/h4&gt;

&lt;p&gt;Backtracking, with memorized the element usage, which takes space, or we can search on arraylist(more time);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /**
     * @param nums: A list of integers.
     * @return: A list of permutations.
     */
    public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; permute(ArrayList&amp;lt;Integer&amp;gt; nums) {

        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(nums == null || nums.size() == 0)
            return res;
        helper(res, new ArrayList&amp;lt;Integer&amp;gt;(), nums);
        return res;
    }
    
    private void helper(ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; res, ArrayList&amp;lt;Integer&amp;gt; list,  ArrayList&amp;lt;Integer&amp;gt; nums ) {
        
        if(list.size() == nums.size()) {
            res.add(new ArrayList&amp;lt;Integer&amp;gt;(list));
            return;
        }
        
        for(int i = 0; i&amp;lt;nums.size(); i++){
        	// to check if this number already taken
            if(list.contains(nums.get(i)))
                continue;
            
            list.add(nums.get(i));
            helper(res, list, nums);
            list.remove(list.size() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;method-two&#34;&gt;Method Two:&lt;/h4&gt;

&lt;p&gt;Swap: &lt;a href=&#34;https://www.cs.princeton.edu/~rs/talks/perms.pdf&#34;&gt;Reference&lt;/a&gt;;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://xmruibi.github.io/media/PermutationSwap.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
  private static Set&amp;lt;Integer&amp;gt; exchPermutation(int[] arr) {
    Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
    int i = 0, num = 0;
    outer: while(true) {
      
      while(i &amp;lt; arr.length - 1) {
        num = exchGenerate(arr, i, ++i);
        if(set.contains(num))
          break outer;
        set.add(num);
      }
      
      num = exchGenerate(arr, 0, 1);
      if(set.contains(num))
        break outer;
      set.add(num);
      
      while(i &amp;gt; 0) {
        num = exchGenerate(arr, --i, i+1);
        if(set.contains(num))
          break outer;
        set.add(num);
      }
      
      num = exchGenerate(arr, arr.length - 2, arr.length - 1);
      if(set.contains(num))
        break outer;
      set.add(num);
    }
    return set;
  }
  
  private static int exchGenerate(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
    
    int res = 0;
    for(int n : arr){
      res = res*10 + n;
    }
    return res;
  }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Previous Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/previous-permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/previous-permutation/</guid>
      <description>

&lt;p&gt;Given a list of integers, which denote a permutation.&lt;/p&gt;

&lt;p&gt;Find the previous permutation in ascending order.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;[1,3,2,3]&lt;/code&gt;, the previous permutation is &lt;code&gt;[1,2,3,3]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For &lt;code&gt;[1,2,3,4]&lt;/code&gt;, the previous permutation is [&lt;code&gt;4,3,2,1]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The list may contains duplicate integers.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;step 1: find last nums[k] &amp;gt; nums[k + 1];&lt;/li&gt;
&lt;li&gt;step 2: find last nums[i] &amp;gt; nums[k];&lt;/li&gt;
&lt;li&gt;step 3: swap i, j;&lt;/li&gt;
&lt;li&gt;step 4: reverse num after i;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nums: A list of integers
     * @return: A list of integers that&#39;s previous permuation
     */
    public ArrayList&amp;lt;Integer&amp;gt; previousPermuation(ArrayList&amp;lt;Integer&amp;gt; nums) {
        if(nums == null || nums.size() &amp;lt;= 1)
            return nums;
            
        // step 1: find last nums[k] &amp;gt; nums[k + 1]
        int i = nums.size() - 2;
        for (; i &amp;gt;= 0; i--) {
            if (nums.get(i) &amp;gt; nums.get(i + 1)) {
                break;
            }
            if(i &amp;lt;= 0) {
                reverse(nums, 0, nums.size() - 1);
                return nums;
            }
        }

        // step 2: find last nums[i] &amp;gt; nums[k]
        int j = nums.size() - 1;
        for (; j &amp;gt; i; j--) {
            if (nums.get(i) &amp;gt; nums.get(j)) {
                break;
            }
        }
        
        // step 3: swap i, j
        Collections.swap(nums, i, j);
        
        // step 4: reverse num after i
        reverse(nums, i + 1, nums.size() - 1);
        
        return nums;
    }
    
    private void reverse(ArrayList&amp;lt;Integer&amp;gt; nums,  int start, int end) {
        for (int i = start, j = end; i &amp;lt; j; i++, j--) {
            Collections.swap(nums, i, j);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Permutation Index II</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation-index-ii/</link>
      <pubDate>Mon, 19 Oct 2015 11:45:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation-index-ii/</guid>
      <description>

&lt;p&gt;Given a permutation which may contain repeated numbers, find its index in all the permutations of these numbers, which are ordered in lexicographical order. The index begins at 1.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given the permutation &lt;code&gt;[1, 4, 2, 2]&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;The key is counting from low digit(right) to higher digit(left), and checking how many digits are less than current digits. Then using that count as the coefficient with positional weight. However, there are duplicates occured. So that means we can use a hash map to do the count.
But the positional system should be modified. The multiple of the factorial of the duplicates occurence should be divided by original position system. That means the &lt;code&gt;entry.value&lt;/code&gt; need to to the factorial and multiply those factors.
Why? For example, n numbers with 2 duplicates, like &lt;code&gt;2,4,3,3&lt;/code&gt;, when &lt;code&gt;4&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param A an integer array
     * @return a long integer
     */
    public long permutationIndexII(int[] A) {
        if(A == null || A.length == 0)
            return 0L;
        
        int pos = 2;
        long factor = 1;
        long index = 1;
        for(int i = A.length - 2; i &amp;gt;= 0; i--) {
            HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
            int cnt = 0;
            // count itself
            map.put(A[i], 1);
            for(int j = i + 1; j &amp;lt; A.length; j++) {
                // count all occurence on following element in Array
                map.put(A[j], map.containsKey(A[j])?map.get(A[j])+1:1);
                if(A[i] &amp;gt; A[j])
                    cnt++;
            }
            index += (cnt*factor)/factorialMultiple(map);
            factor *= pos;
            pos++;
        }
        
        return index;
    }
    
    private int factorialMultiple(HashMap&amp;lt;Integer, Integer&amp;gt; map) {
        int res = 1;
        for(int value : map.values()) {
            // do the factor on occurence
            int factor = 1;
            for(int i = 1; i &amp;lt;= value; i++)
                factor*= i;
            // get the multiple of occurence factor
            res *= factor;
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Permutation Sequence</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation-sequence/</link>
      <pubDate>Mon, 19 Oct 2015 11:45:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation-sequence/</guid>
      <description>

&lt;p&gt;Given n and k, return the k-th permutation sequence.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For n = 3, all permutations are listed as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;123&amp;quot;
&amp;quot;132&amp;quot;
&amp;quot;213&amp;quot;
&amp;quot;231&amp;quot;
&amp;quot;312&amp;quot;
&amp;quot;321&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If k = &lt;code&gt;4&lt;/code&gt;, the fourth permutation is &amp;laquo;&lt;code&gt;231&lt;/code&gt;&amp;laquo;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;n will be between 1 and 9 inclusive.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n*k) in time complexity is easy, can you do it in O(n^2) or less?&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;a1,a2,a3&amp;hellip;..an的permutation 如果确定了a1,那么剩下的permutation就有(n-1)!种 所以 a1 = k / (n-1)! k2 = k % (n-1)! a2 = k2 / (n-2)!&lt;/p&gt;

&lt;p&gt;要注意的是&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;得到的应该是剩下选择数字的index,而不是value,所以要建一个存储可用数字的list&lt;/li&gt;
&lt;li&gt;在用完一个数字后要将它从list中删去&lt;/li&gt;
&lt;li&gt;array是0-based index, 那么K也应该减去1变为0-based的 (&lt;code&gt;k--&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /**
      * @param n: n
      * @param k: the kth permutation
      * @return: return the k-th permutation
      */
    public String getPermutation(int n, int k) {
        
        int[] factors = new int[n + 1];
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        factors[0] = 1;
        for(int i = 1; i &amp;lt;= n; i++) {
            factors[i] = i * factors[i-1];
            list.add(i);
        }
        
        StringBuilder sb = new StringBuilder();
        // for index alignment： e.g: k == 12, k / 6 = 2, 
        // however, it should still belong the number start for list.get(1); So here need to make a alignment
        k--;
        while(n &amp;gt; 1) {
            int index = k / factors[n-1];
            sb.append(list.remove(index));
            k %= factors[n-1];
            n--;
        }
        sb.append(list.get(0));
        return sb.toString();
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Permutation Index</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation-index/</link>
      <pubDate>Mon, 19 Oct 2015 11:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation-index/</guid>
      <description>

&lt;p&gt;Given a permutation which contains no repeated number, find its index in all the permutations of these numbers, which are ordered in lexicographical order. The index begins at 1.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;[1,2,4]&lt;/code&gt;, return &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;thinking&#34;&gt;Thinking&lt;/h2&gt;

&lt;p&gt;Illustrating by manually getting the index of {2, 4, 3, 1}. Since this is a 4-element set, we know there are 4! permutations (4! = 4*3*2*1). If the set only had 3 elements, we would have 3*2*1 permutations. If the set only had 2 elements, we would have 2!=2*1 permutations; and so on.&lt;/p&gt;

&lt;p&gt;ASIDE: The decimal system of counting is a positional system. A 3-element decimal number, for instance, has the following three positional weights: hundred, ten, unit. Hence, we know the value of the number 472 because we understand: 4*hundred + 7*ten + 2*unit.&lt;/p&gt;

&lt;p&gt;If we treat our 4-element set as a positional system, then we get the following positional weights: 3!, 2!, 1!, 0. So that the index of {2, 4, 3, 1} is: x*3!+y*2!+z*1!+w*0. Presently it suffices to find the values of x,y,z to calculate the index (we ignore w because it is paired with 0). x,y,z are counters: the number of succeeding elements less than the element being considered. For example, in {2, 4, 3, 1}, there are two succeeding elements less than 4 (namely 3 and 1). For 2 it&amp;rsquo;s 1 (1); for 4 it&amp;rsquo;s 2 (3 and 1); for 3 it&amp;rsquo;s 1 (1); for 1 it&amp;rsquo;s 0. Now we can calculate the index of {2, 4, 3, 1} as: x=1, y=2, z=1:
    &lt;code&gt;x*3!+y*2!+z*1!+w*0 = 1*3! + 2*2! + 1*1! = 6 + 4 + 1 = 11&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The key is counting from low digit(right) to higher digit(left), and checking how many digits are less than current digits. Then using that count as the coefficient with positional weight.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param A an integer array
     * @return a long integer
     */
    public long permutationIndex(int[] A) {
        
        if(A == null || A.length == 0)
            return 0L;
        
        int pos = 2;
        long factor = 1;
        long index = 1;
        for(int i = A.length - 2; i &amp;gt;= 0; i--) {
            int cnt = 0;
            for(int j = i + 1; j &amp;lt; A.length; j++) {
                if(A[i] &amp;gt; A[j])
                    cnt++;
            }
            index += (cnt*factor);
            factor *= pos;
            pos++;
        }
        
        return index;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis&lt;/h2&gt;

&lt;p&gt;Two loop: &lt;code&gt;i range 0 -&amp;gt; length - 2&lt;/code&gt; and &lt;code&gt;j range i + 1 -&amp;gt; length - 1&lt;/code&gt;, So it is &lt;code&gt;O(n^2)&lt;/code&gt;;
Constant Space with some integer variable, Space: &lt;code&gt;O(1)&lt;/code&gt;;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Max Points on a Line</title>
      <link>http://xmruibi.github.io/2015/10/18/max-points-on-a-line/</link>
      <pubDate>Sun, 18 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/max-points-on-a-line/</guid>
      <description>

&lt;p&gt;Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given 4 points: &lt;code&gt;(1,2)&lt;/code&gt;, &lt;code&gt;(3,6)&lt;/code&gt;, &lt;code&gt;(0,0)&lt;/code&gt;, &lt;code&gt;(1,3)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The maximum number is &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use one point as a baseline. (&lt;code&gt;Point pa&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Iterate other points (&lt;code&gt;Point pb&lt;/code&gt;) (index greater than &lt;code&gt;pa&lt;/code&gt;): &lt;code&gt;j = i + 1&lt;/code&gt; and&lt;/li&gt;
&lt;li&gt;Use Hash Map to record the ratio and count&lt;/li&gt;
&lt;li&gt;Note:

&lt;ul&gt;
&lt;li&gt;Ratio is &lt;code&gt;double radio = (double)(pa.y - pb.y) / (double)(pa.x - pb.x)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;When pa.x == pb.x &amp;amp;&amp;amp; pa.y == pb.y, consider two points are the same, also need to count the same point.&lt;/li&gt;
&lt;li&gt;When only &lt;code&gt;pa.x == pb.x&lt;/code&gt;, that means the ratio is infinity as &lt;code&gt;(double)Integer.MAX_VALUE&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;When only &lt;code&gt;pa.y == pb.y&lt;/code&gt;, that means the ratio is zero;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Iterate Hash Map and get the local max with updating the global max;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param points an array of point
     * @return an integer
     */
    public int maxPoints(Point[] points) {
        if(points == null || points.length == 0)
            return 0;
        
       
        int maxLine = 0;
        for(int i = 0; i &amp;lt; points.length; i++) {
            Map&amp;lt;Double, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
            Point pa = points[i];
            int same = 0;
            for(int j = i + 1; j &amp;lt; points.length; j++) {
                    Point pb = points[j];
                    int cnt = 0;
                    if(pa.x == pb.x &amp;amp;&amp;amp; pa.y == pb.y)
                        same ++;
                    else if(pa.x == pb.x) {
                        map.put((double)Integer.MAX_VALUE, map.containsKey((double)Integer.MAX_VALUE)?map.get((double)Integer.MAX_VALUE) + 1 : 2);
                    }else if(pa.y == pb.y)
                        map.put((double)0, map.containsKey((double)0)?map.get((double)0) + 1 : 2);
                    else{
                        double radio = (double)(pa.y - pb.y) / (double)(pa.x - pb.x);
                        map.put(radio, map.containsKey(radio)?map.get(radio) + 1 : 2);
                    }
            }
            int localMax = 1;
            for (Integer value : map.values())   
                localMax = Math.max(localMax, value);
            localMax += same;  
            maxLine = Math.max(maxLine, localMax); 
        }
        
        return maxLine;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Count of Smaller Number</title>
      <link>http://xmruibi.github.io/2015/10/18/count-of-smaller-number/</link>
      <pubDate>Sun, 18 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/count-of-smaller-number/</guid>
      <description>

&lt;p&gt;Give you an integer array (index from 0 to n-1, where n is the size of this array, value from 0 to 10000) and an query list. For each query, give you an integer, return the number of element in the array that are smaller that the given integer.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For array &lt;code&gt;[1,2,7,8,5]&lt;/code&gt;, and queries &lt;code&gt;[1,8,5]&lt;/code&gt;, return &lt;code&gt;[0,4,2]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Could you use three ways to do it.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Just loop&lt;/li&gt;
&lt;li&gt;Sort and binary search&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;1-solution-by-loop-with-o-n-2&#34;&gt;1. Solution by Loop with O(n^2)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;

   /** O(n^2) Loop implement
     * @param A: An integer array
     * @return: The number of element in the array that 
     *          are smaller that the given integer
     */
    public ArrayList&amp;lt;Integer&amp;gt; countOfSmallerNumber(int[] A, int[] queries) {
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(A == null || queries == null)
            return res;
            
        for(int i = 0; i &amp;lt; queries.length; i++) {
            int cnt = 0;
            for(int j = 0; j &amp;lt; A.length; j++) {
                if(A[j] &amp;lt; queries[i])
                    cnt++;
            }
            res.add(cnt);
        }
        return res;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-solution-by-sort-and-binary-search-with-o-nlogn&#34;&gt;2. Solution by Sort and Binary search with O(nlogn)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    /** O(nlogn) Sort and Binary search
     * @param A: An integer array
     * @return: The number of element in the array that 
     *          are smaller that the given integer
     */
    public ArrayList&amp;lt;Integer&amp;gt; countOfSmallerNumber(int[] A, int[] queries) {
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(queries == null)
            return res;
         
        Arrays.sort(A);
        for(int i = 0; i &amp;lt; queries.length; i++) {
            int cnt = binarySearch(A, queries[i]);
            res.add(cnt);
        }
        return res;
    }
    
    private int binarySearch(int[] A, int value) {
        if(A == null || A.length == 0)
            return 0;
        int l = 0, r = A.length - 1;
        while(l + 1 &amp;lt; r) {
            int m = l + ((r - l) &amp;gt;&amp;gt; 1);
            if(value &amp;gt; A[m])
                l = m;
            else
                r = m;
        }
        if(A[l] &amp;lt; value)
            return l + 1;
        else
            return l; 
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Smallest Difference</title>
      <link>http://xmruibi.github.io/2015/10/18/smallest-difference/</link>
      <pubDate>Sun, 18 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/smallest-difference/</guid>
      <description>

&lt;p&gt;Given two array of integers(the first array is array A, the second array is array B), now we are going to find a element in array A which is A[i], and another element in array B which is B[j], so that the difference between A[i] and B&lt;a href=&#34;|A[i] - B[j]|&#34;&gt;j&lt;/a&gt; is as small as possible, return their smallest difference.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For example, given array A = &lt;code&gt;[3,6,7,4]&lt;/code&gt;, B = &lt;code&gt;[2,8,9,3]&lt;/code&gt;, return &lt;code&gt;0&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n log n) time&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Do sort on one of array&lt;/li&gt;
&lt;li&gt;One pass on another array and do binary search on the sorted array.&lt;/li&gt;
&lt;li&gt;Search the target value from passing array and get the minimum difference on sorted array&lt;/li&gt;
&lt;li&gt;Update the global minimum difference each time.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param A, B: Two integer arrays.
     * @return: Their smallest difference.
     */
    public int smallestDifference(int[] A, int[] B) {
        if(A == null || B == null || A.length == 0 || B.length == 0)
            return 0;
        Arrays.sort(B);
        int mindiff = Integer.MAX_VALUE;
        for(int i = 0; i &amp;lt; A.length; i++) {
            int curdiff = binarySearch(B, A[i]);
            mindiff = Math.min(mindiff, curdiff);
        }
        return mindiff;
    }
    
    
    private int binarySearch(int[] A, int value) {
        if(A == null || A.length == 0)
            return 0;
        int l = 0, r = A.length - 1;
        while(l + 1 &amp;lt; r) {
            int m = l + ((r - l) &amp;gt;&amp;gt; 1);
            if(value &amp;gt; A[m])
                l = m;
            else
                r = m;
        }
        return Math.min(Math.abs(A[l] - value), Math.abs(A[r] - value));
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Interval Minimum Number</title>
      <link>http://xmruibi.github.io/2015/10/18/interval-minimum-number/</link>
      <pubDate>Sun, 18 Oct 2015 15:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/interval-minimum-number/</guid>
      <description>

&lt;p&gt;Given an integer array (index from 0 to n-1, where n is the size of this array), and an query list. Each query has two integers [start, end]. For each query, calculate the minimum number between index start and end in the given array, return the result list.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For array &lt;code&gt;[1,2,7,8,5]&lt;/code&gt;, and queries &lt;code&gt;[(1,2),(0,4),(2,4)]&lt;/code&gt;, return &lt;code&gt;[2,1,5]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(logN) time for each query (Segment Tree)&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     *@param A, queries: Given an integer array and an query list
     *@return: The result list
     */
    public ArrayList&amp;lt;Integer&amp;gt; intervalMinNumber(int[] A, 
                                                ArrayList&amp;lt;Interval&amp;gt; queries) {
        IntervalTree tree = new IntervalTree(A);
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        for(Interval interval : queries) {
            res.add(tree.query(interval.start, interval.end));
        }
        return res;
    }
}

/**
* Build Interval Tree with Min of segment!
*
*/
class IntervalTree{
        IntervalNode root;
        
        public IntervalTree(int[] A) {
            root = build(A, 0, A.length - 1);
        }
        
        private IntervalNode build(int[] A, int start, int end) {
            if(start &amp;gt; end)
                return null;
            IntervalNode node = new IntervalNode(start, end);
            
            if(start == end) {
                node.min = A[start];
                return node;
            }
            
            int m = start + ((end - start)&amp;gt;&amp;gt;1);
            node.left = build(A, start, m);
            node.right = build(A, m+1, end);
            node.min = Math.min(node.left.min, node.right.min);
            return node;
        }
        
        public int query(int start, int end) {
            return queryhelper(root, start, end);
        }
        
        private int queryhelper(IntervalNode node, int start, int end) {
            if(start &amp;lt;= node.start &amp;amp;&amp;amp; end &amp;gt;= node.end)
                return node.min;
            
            int m = node.start + ((node.end - node.start)&amp;gt;&amp;gt;1);
            if(m &amp;lt; start) {
                return queryhelper(node.right, start, end);
            }else if(m &amp;gt;= end){
                return queryhelper(node.left, start, end);
            }else
                return Math.min(queryhelper(node.left, start, m), queryhelper(node.right, m+1, end));
        }

        private class IntervalNode {
            int start, end, min;
            IntervalNode left, right;
            IntervalNode(int start, int end) {
                this.start = start;
                this.end = end;
            }
        }
}


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Interval Sum</title>
      <link>http://xmruibi.github.io/2015/10/18/interval-sum/</link>
      <pubDate>Sun, 18 Oct 2015 15:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/interval-sum/</guid>
      <description>

&lt;p&gt;Given an integer array (index from 0 to n-1, where n is the size of this array), and an query list. Each query has two integers [start, end]. For each query, calculate the sum number between index start and end in the given array, return the result list.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For array &lt;code&gt;[1,2,7,8,5]&lt;/code&gt;, and queries &lt;code&gt;[(0,4),(1,2),(2,4)]&lt;/code&gt;, return &lt;code&gt;[23,9,20]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(logN) time for each query&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// Segment tree for sum
class IntervalTree{
        IntervalNode root;
        
        public IntervalTree(int[] A) {
            root = build(A, 0, A.length - 1);
        }
        
        private IntervalNode build(int[] A, int start, int end) {
            if(start &amp;gt; end)
                return null;
            IntervalNode node = new IntervalNode(start, end);
            
            if(start == end) {
                node.val = (long)A[start];
                return node;
            }
            
            int m = start + ((end - start)&amp;gt;&amp;gt;1);
            node.left = build(A, start, m);
            node.right = build(A, m+1, end);
            node.val = node.left.val + node.right.val;
            return node;
        }
        
        public long query(int start, int end) {
            return queryhelper(root, start, end);
        }
        
        private long queryhelper(IntervalNode node, int start, int end) {
            if(start &amp;lt;= node.start &amp;amp;&amp;amp; end &amp;gt;= node.end)
                return node.val;
            
            int m = node.start + ((node.end - node.start)&amp;gt;&amp;gt;1);
            if(m &amp;lt; start) {
                return queryhelper(node.right, start, end);
            }else if(m &amp;gt;= end){
                return queryhelper(node.left, start, end);
            }else
                return queryhelper(node.left, start, m) + queryhelper(node.right, m+1, end);
        }

        private class IntervalNode {
            int start, end;
            long val;
            IntervalNode left, right;
            IntervalNode(int start, int end) {
                this.start = start;
                this.end = end;
            }
        }
}

public class Solution {
    /**
     *@param A, queries: Given an integer array and an query list
     *@return: The result list
     */
    public ArrayList&amp;lt;Long&amp;gt; intervalSum(int[] A, 
                                       ArrayList&amp;lt;Interval&amp;gt; queries) {
        IntervalTree tree = new IntervalTree(A);
        ArrayList&amp;lt;Long&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        for(Interval interval : queries) {
            res.add(tree.query(interval.start, interval.end));
        }
        return res;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Interval Sum II</title>
      <link>http://xmruibi.github.io/2015/10/18/interval-sum-ii/</link>
      <pubDate>Sun, 18 Oct 2015 15:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/interval-sum-ii/</guid>
      <description>

&lt;p&gt;Given an integer array in the construct method, implement two methods query(start, end) and modify(index, value):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For query(start, end), return the sum from index start to index end in the given array.&lt;/li&gt;
&lt;li&gt;For modify(index, value), modify the number in the given index to value.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given array A = &lt;code&gt;[1,2,7,8,5]&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;query(0, 2)&lt;/code&gt;, return &lt;code&gt;10&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modify(0, 4)&lt;/code&gt;, change &lt;code&gt;A[0]&lt;/code&gt; from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;4&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;query(0, 1)&lt;/code&gt;, return &lt;code&gt;6&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modify(2, 1)&lt;/code&gt;, change &lt;code&gt;A[2]&lt;/code&gt; from &lt;code&gt;7&lt;/code&gt;to &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;query(2, 4)&lt;/code&gt;, return &lt;code&gt;14&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(logN) time for query and modify.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /* you may need to use some attributes here */
    
    IntervalNode root;
    /**
     * @param A: An integer array
     */
    public Solution(int[] A) {
        root = build(A, 0, A.length - 1);
    }
    
    private IntervalNode build(int[] A, int start, int end) {
            if(start &amp;gt; end)
                return null;
            IntervalNode node = new IntervalNode(start, end);
            
            if(start == end) {
                node.val = (long)A[start];
                return node;
            }
                
            int m = start + ((end - start)&amp;gt;&amp;gt;1);
            node.left = build(A, start, m);
            node.right = build(A, m+1, end);
            node.val = node.left.val + node.right.val;
            return node;
    }
        
    /**
     * @param start, end: Indices
     * @return: The sum from start to end
     */
    public long query(int start, int end) {
        return query(root, start, end);
    }
        
    private long query(IntervalNode node, int start, int end) {
        if(start &amp;lt;= node.start &amp;amp;&amp;amp; end &amp;gt;= node.end)
            return node.val;
            
        int m = node.start + ((node.end - node.start)&amp;gt;&amp;gt;1);
        if(m &amp;lt; start) {
            return query(node.right, start, end);
        }else if(m &amp;gt;= end){
            return query(node.left, start, end);
        }else
            return query(node.left, start, m) + query(node.right, m+1, end);
    }
    
    /**
     * @param index, value: modify A[index] to value.
     */
    public void modify(int index, int value) {
        modify(root, index, value);
    }
    
    private void modify(IntervalNode node, int index, int value) {
        if(node.start == node.end) {
            node.val = value;
            return;
        }
        
        int m = node.start + ((node.end - node.start)&amp;gt;&amp;gt;1);
         if(m &amp;lt; index) 
            modify(node.right, index, value);
        else
            modify(node.left, index, value);
        node.val = node.right.val + node.left.val;
    }
    
    
    
    private class IntervalNode {
        int start, end;
        long val;
        IntervalNode left, right;
        IntervalNode(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Segment Tree Build</title>
      <link>http://xmruibi.github.io/2015/10/18/segment-tree-build/</link>
      <pubDate>Sun, 18 Oct 2015 14:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/segment-tree-build/</guid>
      <description>

&lt;p&gt;The structure of Segment Tree is a binary tree which each node has two attributes &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; denote an segment / interval.&lt;/p&gt;

&lt;p&gt;start and end are both integers, they should be assigned in following rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The root&amp;rsquo;s start and end is given by &lt;code&gt;build&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;The left child of node A has &lt;code&gt;start=A.left, end=(A.left + A.right) / 2&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The right child of node A has &lt;code&gt;start=(A.left + A.right) / 2 + 1, end=A.right&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;if start equals to end, there will be no children for this node.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Implement a &lt;code&gt;build&lt;/code&gt; method with two parameters start and end, so that we can create a corresponding segment tree with every node has the correct start and end value, return the root of this segment tree.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given start=0, end=3. The segment tree will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;               [0,  3]
             /        \
      [0,  1]           [2, 3]
      /     \           /     \
   [0, 0]  [1, 1]     [2, 2]  [3, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given start=1, end=6. The segment tree will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;               [1,  6]
             /        \
      [1,  3]           [4,  6]
      /     \           /     \
   [1, 2]  [3,3]     [4, 5]   [6,6]
   /    \           /     \
[1,1]   [2,2]     [4,4]   [5,5]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;clarification&#34;&gt;Clarification&lt;/h3&gt;

&lt;p&gt;Segment Tree (a.k.a Interval Tree) is an advanced data structure which can support queries like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;which of these intervals contain a given point&lt;/li&gt;
&lt;li&gt;which of these points are in a given interval&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class SegmentTreeNode {
    public int start, end, max;
    public SegmentTreeNode left, right;
    public SegmentTreeNode(int start, int end, int max) {
        this.start = start;
        this.end = end;
        this.max = max
        this.left = this.right = null;
    }
}

public class Solution {
    /**
     *@param start, end: Denote an segment / interval
     *@return: The root of Segment Tree
     */
    public SegmentTreeNode build(int start, int end) {
        if(end &amp;lt; start)
            return null;
        SegmentTreeNode node = new SegmentTreeNode(start, end);
        if(start == end)
            return node;
        int m = left + ((right - left)&amp;gt;&amp;gt;1);
        node.left = build(start, m);
        node.right = build(m+1,end);
        return node;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Segment Tree Build II</title>
      <link>http://xmruibi.github.io/2015/10/18/segment-tree-build-ii/</link>
      <pubDate>Sun, 18 Oct 2015 14:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/segment-tree-build-ii/</guid>
      <description>

&lt;p&gt;The structure of Segment Tree is a binary tree which each node has two attributes &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; denote an segment / interval.&lt;/p&gt;

&lt;p&gt;start and end are both integers, they should be assigned in following rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The root&amp;rsquo;s start and end is given by &lt;code&gt;build&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;The left child of node A has &lt;code&gt;start=A.left, end=(A.left + A.right) / 2&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The right child of node A has &lt;code&gt;start=(A.left + A.right) / 2 + 1, end=A.right&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;if start equals to end, there will be no children for this node.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Implement a build method with a given array, so that we can create a corresponding segment tree with every node value represent the corresponding interval max value in the array, return the root of this segment tree.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given [3,2,1,4]. The segment tree will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                 [0,  3] (max = 4)
                  /            \
        [0,  1] (max = 3)     [2, 3]  (max = 4)
        /        \               /             \
[0, 0](max = 3)  [1, 1](max = 2)[2, 2](max = 1) [3, 3] (max = 4)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;clarification&#34;&gt;Clarification&lt;/h3&gt;

&lt;p&gt;Segment Tree (a.k.a Interval Tree) is an advanced data structure which can support queries like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;which of these intervals contain a given point&lt;/li&gt;
&lt;li&gt;which of these points are in a given interval&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     *@param A: a list of integer
     *@return: The root of Segment Tree
     */
    public SegmentTreeNode build(int[] A) {
        return builder(A, 0, A.length - 1);
    }
    
    private SegmentTreeNode builder(int[] A, int left, int right) {
        if(left &amp;gt; right)
            return null;
        if(left == right)
            return new SegmentTreeNode(left, right, A[left]);
        int m = left + ((right - left)&amp;gt;&amp;gt;1);
        SegmentTreeNode leftNode = builder(A, left, m);
        SegmentTreeNode rightNode = builder(A, m+1, right);
        SegmentTreeNode node = new SegmentTreeNode(left, right, Math.max(leftNode.max, rightNode.max));
        node.left = leftNode;
        node.right = rightNode;
        return node;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>