+++
date = "2015-10-22T14:43:13-07:00"
levels = []
tags = ["String", "Palindrome", "Dynamic Programming"]
title = "Longest Palindromic Substring"
topics = ["Amazon","Leetcode","Algorithm"]
banner = "/media/leetcode.png"
+++

Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.
<!--more-->

### Example
Given the string = `"abcdzdcab"`, return `"cdzdc"`.

### Challenge
O(n2) time is acceptable. Can you do it in O(n) time.

## Think #2
- One pass on each position in string characters, assume the axis of symmetry on each character or between two character:

		    |						|
	    c a b a c f     or     c a b a c f

	
- On each axis of symmetry we get the left and right pointers and make them move toward left or right

        left right			 
	       \ /                 
	    c a b a c f 
        
        ...or...	    
	    
	        l r
	        | |
	    c a b a c f
	   
## Solution

```java
public class Solution {
    /**
     * @param s input string
     * @return the longest palindromic substring
     */
    private String LongestPalindromeSubstringI(String str) {
        int maxLen = 0;
        String maxSubstr = "";
        // memorized whether it is palindromical in str (i, j)
        boolean[][] memo = new boolean[str.length()][str.length()];
        for (int i = str.length() - 1; i >= 0; i--) {
            for (int j = i; j < str.length(); j++) {
                if ((j - i < 2 || memo[i + 1][j - 1])
                        && str.charAt(i) == str.charAt(j)) {
                    memo[i][j] = true;
                    if (j - i + 1 > maxLen) {
                        maxSubstr = str.substring(i, j + 1);
                        maxLen = j - i + 1;
                    }
                }
            }
        }
        return maxSubstr;
    }

    private String LongestPalindromeSubstringII(String str) {
        int maxLen = 0;
        String maxSubstr = "";
        for (int i = 0; i < str.length(); i++) {
            String case1 = expandFromCenter(str, i, i);
            String case2 = expandFromCenter(str, i, i + 1);
            if (Math.max(case1.length(), case2.length()) > maxLen) {
                maxLen = Math.max(case1.length(), case2.length());
                maxSubstr = case1.length() > case2.length() ? case1 : case2;
            }
        }
        return maxSubstr;
    }

    private String expandFromCenter(String str, int left, int right) {
        while ( left >= 0
                && right < str.length()&&str.charAt(left) == str.charAt(right)) {
            left--;
            right++;
        }
        return str.substring(left + 1, right);
    }
}
```

## Analysis
One pass from 0 - $$len \times 2$$; inside the loop the palindromic substring search also costs a loop from l - r; So the total is O($$n^2$$);
