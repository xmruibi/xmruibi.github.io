<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Coder Thinking -- Home Page</title>
    <link>http://xmruibi.github.io/post/</link>
    <description>Recent content in Posts on Coder Thinking -- Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Mon, 12 Oct 2015 21:43:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Closest Number</title>
      <link>http://xmruibi.github.io/2015/10/12/closest-number/</link>
      <pubDate>Mon, 12 Oct 2015 21:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/12/closest-number/</guid>
      <description>

&lt;p&gt;Given an unsorted array, find out the most closest two elements in this array. Output&lt;/p&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Sort is important here! You must think about sort first. Since other may may cost&lt;/li&gt;
&lt;li&gt;Then the gap between adjacent elements are the&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
&lt;code class=&#34;java&#34;&gt;
public ArrayList&lt;int[]&gt; closestNumber(int[] arr){
    ArrayList&lt;int[]&gt; res = new ArrayList&lt;&gt;();
    if(arr == null || arr.length == 0)
        return res;
    Arrays.sort(arr);

    int mindiff = Integer.MAX_VALUE;
    for(int i = 1; i &lt; arr.length; i++) {
        int curdiff = arr[i] - arr[i - 1];
        if(curdiff &gt;= mindiff) {
            if(curdiff &gt; mindiff)
                res.clear();
            int[] cres = new int[]{arr[i - 1], arr[i]};
            res.add(cres);
        }
    }
    return res;
}
&lt;/code&gt;
&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Route Between Two Nodes in Directed Graph</title>
      <link>http://xmruibi.github.io/2015/10/11/route-between-two-nodes-in-directed-graph/</link>
      <pubDate>Sun, 11 Oct 2015 15:14:18 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/11/route-between-two-nodes-in-directed-graph/</guid>
      <description>

&lt;p&gt;Given a directed graph, design an algorithm to find out whether there is a route between two nodes.&lt;/p&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Most typical Graph algorithm question!&lt;/li&gt;
&lt;li&gt;Try two ways: DFS, BFS.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
&lt;code class=&#34;java&#34;&gt;
public class Solution {
   /**
     * @param graph: A list of Directed graph node
     * @param s: the starting Directed graph node
     * @param t: the terminal Directed graph node
     * @return: a boolean value
     */
     
     // BFS
     public boolean hasRoute(ArrayList&lt;DirectedGraphNode&gt; graph, 
                            DirectedGraphNode s, DirectedGraphNode t) {
        
        if(s == t)
            return true;

        Queue&lt;DirectedGraphNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(s);
        graph.remove(s);
        while(!queue.isEmpty()) {
            DirectedGraphNode cur = queue.remove();
            graph.remove(cur);
            for(DirectedGraphNode next : cur.neighbors) {
                if(!graph.contains(next))
                    continue;
                if(next == t)
                    return true;
                queue.offer(next);
            }
        }
        return false;
    }
     
     
    // DFS
    public boolean hasRoute(ArrayList&lt;DirectedGraphNode&gt; graph, 
                            DirectedGraphNode s, DirectedGraphNode t) {
        // write your code here
        if(s == t)
            return true;
            
        graph.remove(s);
        for(DirectedGraphNode next : s.neighbors) {
            if(!graph.contains(next))
                    continue;
            if(hasRoute(graph, next, t))
                return true;
        }
        graph.add(s);
        return false;
    }
}


&lt;/code&gt;
&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Minimum Window Substring</title>
      <link>http://xmruibi.github.io/2015/10/08/minimum-window-substring/</link>
      <pubDate>Thu, 08 Oct 2015 22:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/08/minimum-window-substring/</guid>
      <description>

&lt;p&gt;Given a string source and a string target, find the minimum window in source which will contain all the characters in target.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;source = &amp;laquo;ADOBECODEBANC&amp;raquo; target = &amp;laquo;ABC&amp;raquo; Minimum window is &amp;laquo;BANC&amp;raquo;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;If there is no such window in source that covers all characters in target, return the emtpy string &amp;laquo;&amp;raquo;.&lt;/p&gt;

&lt;p&gt;If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in source.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Can you do it in time complexity O(n) ?&lt;/p&gt;

&lt;h3 id=&#34;clarification&#34;&gt;Clarification&lt;/h3&gt;

&lt;p&gt;The characters in minimum window doesn&amp;rsquo;t need to has the same order in target.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public String minWindow(String source, String target) {
        // preload for target checking
        if(source == null || source.length() == 0 || target == null || target.length() == 0)
            return &amp;quot;&amp;quot;;
        
        
        int tarLen = target.length();
        HashMap&amp;lt;Character, Integer&amp;gt; dict = new HashMap&amp;lt;&amp;gt;();
        for(char c : target.toCharArray()) 
            dict.put(c, dict.containsKey(c)? dict.get(c) + 1 : 1);
        
        int hitCount = 0; // record current window hits how many characters in target
        int prevIdx = 0; // record the left bound of current window
        int minWindow = source.length() + 1; // initial the minimum window length
        int start = 0;
        for(int i = 0; i &amp;lt; source.length(); i++) {
            char cur = source.charAt(i);
            // if current char is not in dict, continue
            if(!dict.containsKey(cur))
                continue;
            
            dict.put(cur, dict.get(cur) - 1);
            if(dict.get(cur) &amp;gt;= 0)
                hitCount++;
            
            // check the windows has amount of this char more than it in target string
            // loop until the amount back to normal, but always reduce the prev index char
            while(hitCount == tarLen) {
                if( minWindow &amp;gt; i - prevIdx + 1) {
                    start = prevIdx;
                    minWindow = i - prevIdx + 1;
                }
                char prevChar = source.charAt(prevIdx);
                if(dict.containsKey(prevChar)) {
                    dict.put(prevChar, dict.get(prevChar)+1);
                    if(dict.get(prevChar) &amp;gt; 0)
                        hitCount--;
                }
                prevIdx++;
            }
        }
        // 
        if(minWindow &amp;gt; source.length())
            return &amp;quot;&amp;quot;;
        return source.substring(start, start + minWindow);
    }

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Partition Array</title>
      <link>http://xmruibi.github.io/2015/10/08/partition-array/</link>
      <pubDate>Thu, 08 Oct 2015 22:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/08/partition-array/</guid>
      <description>&lt;p&gt;Given an array &lt;code&gt;nums&lt;/code&gt; of integers and an int &lt;code&gt;k&lt;/code&gt;, partition the array (i.e move the elements in &amp;laquo;nums&amp;raquo;) such that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All elements &amp;lt; k are moved to the left&lt;/li&gt;
&lt;li&gt;All elements &amp;gt;= k are moved to the right&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Return the partitioning index, i.e the first index i nums[i] &amp;gt;= k.&lt;/p&gt;

&lt;p&gt;Solution:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Typical index rotate two pointer problem, looks like the idea of quick sort .&lt;/li&gt;
&lt;li&gt;Set an index &lt;code&gt;pivot&lt;/code&gt; for marking the real position of element less than &lt;code&gt;k&lt;/code&gt; during pass the orginal array.&lt;/li&gt;
&lt;li&gt;Once the current passing index &lt;code&gt;i&lt;/code&gt; hits the element less than &lt;code&gt;k&lt;/code&gt;, we do the swap with &lt;code&gt;pivot&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Make sure the &lt;code&gt;pivot&lt;/code&gt; should add 1 after swap since the marked position is increase for next one.&lt;/li&gt;
&lt;li&gt;However in new &lt;code&gt;pivot&lt;/code&gt; position we not sure the element&amp;rsquo;s value, so&amp;hellip; we need to check in next procedure.&lt;/li&gt;
&lt;li&gt;Make sure the &lt;code&gt;i&lt;/code&gt; position decrease 1, because we just did a swap and we need to check the new &lt;code&gt;i&lt;/code&gt; is less than &amp;lsquo;k&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /** 
     *@param nums: The integer array you should partition
     *@param k: As description
     *return: The index after partition
     */
    public int partitionArray(int[] nums, int k) {
        if(nums == null || nums.length == 0)
            return 0;
            
        int pivot = 0;
        for(int i = 0; i &amp;lt; nums.length; i++) {
            if(i &amp;gt; pivot &amp;amp;&amp;amp; nums[i] &amp;lt; k) {
                int tmp = nums[pivot];
                nums[pivot++] = nums[i];
                nums[i--] = tmp;
            }
        }
        // this is just for corner case when the last element still less than k
        if(nums[nums.length - 1] &amp;lt; k)
            return nums.length;
        return pivot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Search In 2D Matrix II</title>
      <link>http://xmruibi.github.io/2015/09/22/search-in-2d-matrix-ii/</link>
      <pubDate>Tue, 22 Sep 2015 13:35:30 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/09/22/search-in-2d-matrix-ii/</guid>
      <description>

&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix, return the occurrence of it.&lt;/p&gt;

&lt;p&gt;This matrix has the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Integers in each row are sorted from left to right.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Integers in each column are sorted from up to bottom.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;No duplicate integers in each row or column.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Typical Matrix Search Problem, using a condition for driven coordinate moving.&lt;/li&gt;
&lt;li&gt;Here the value and target comparasion is the driven condition.&lt;/li&gt;
&lt;li&gt;Since the sorted matrix, we can start from right top element.&lt;/li&gt;
&lt;li&gt;Because on the diagonal from right top to left down, all the left elements are less than the right elments.&lt;/li&gt;
&lt;li&gt;So we have three type of running condition and set the x, y coordinate differently.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
&lt;code class=&#34;java&#34;&gt;
public class Solution {
    /**
     * @param matrix: A list of lists of integers
     * @param: A number you want to search in the matrix
     * @return: An integer indicate the occurrence of target in the given matrix
     */

    public int searchMatrix(int[][] matrix, int target) {
        // write your code here
        if(matrix == null || matrix.length == 0)
            return 0;
        int rightTop = matrix[0][matrix[0].length - 1];
        int x = 0, y = matrix[0].length - 1;
        int occ = 0;
        while(x &lt; matrix.length &amp;&amp; y &gt;= 0) {
            int cur = matrix[x][y];
            if(cur == target) {
                occ ++;
                x++; y--;
            }else if(cur &lt; target)
                x++;
            else
                y--;
        }       
        return occ;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Search In 2D Matrix I</title>
      <link>http://xmruibi.github.io/2015/09/21/search-in-2d-matrix-i/</link>
      <pubDate>Mon, 21 Sep 2015 13:37:08 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/09/21/search-in-2d-matrix-i/</guid>
      <description>

&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix.&lt;/p&gt;

&lt;p&gt;This matrix has the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Integers in each row are sorted from left to right.&lt;/li&gt;
&lt;li&gt;The first integer of each row is greater than the last integer of the previous row.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;First binary search with checking the first element in each row so that we can find the row may contain the target number;&lt;/li&gt;
&lt;li&gt;So we search the lowbound of target number. However, we also can do if the element is just equals to target number then directly return for reducing time.&lt;/li&gt;
&lt;li&gt;Once we get the target row, then we do the second binary search in this row to find the target number.&lt;/li&gt;
&lt;li&gt;All in all, two binary search to find the target!&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
&lt;code class=&#34;java&#34;&gt;
public class Solution {
    /**
     * @param matrix, a list of lists of integers
     * @param target, an integer
     * @return a boolean, indicate whether matrix contains target
     */
    public boolean searchMatrix(int[][] matrix, int target) {
        // write your code here
        if(matrix == null || matrix.length == 0)
            return false;
        
        int up = 0, down = matrix.length - 1;
        while(up &lt; down - 1) {
            int mrow = up + ((down - up) &gt;&gt; 1);
            if(matrix[mrow][0] == target)
                return true;
            if(matrix[mrow][0] &lt; target)
                up = mrow;
            else
                down = mrow;
        }
        int curRow;
        if(matrix[up][0] &gt; target)
            return false;
        else if(matrix[up][0] &lt;= target &amp;&amp; matrix[down][0] &gt; target)
            curRow = up;
        else
            curRow = down;
        
        int l = 0, r = matrix[curRow].length - 1;
        while(l &lt; r - 1) {
            int m = l + ((r - l) &gt;&gt; 1);
            if(matrix[curRow][m] == target)
                return true;
            else if(matrix[curRow][m] &lt; target)
                l = m;
            else
                r = m;
        }
        
        if(matrix[curRow][l] == target || matrix[curRow][r] == target)
            return true;
        else
            return false;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Set Matrix Zeroes</title>
      <link>http://xmruibi.github.io/2015/09/18/set-matrix-zeroes/</link>
      <pubDate>Fri, 18 Sep 2015 22:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/09/18/set-matrix-zeroes/</guid>
      <description>

&lt;p&gt;Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.&lt;/p&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Use the first row (up row) and the first col (left col) to record the position info of zeroes in matrix;&lt;/li&gt;
&lt;li&gt;But we also need to set two boolean value to check if there is zero in first row and first col;&lt;/li&gt;
&lt;li&gt;Then go through the matrix again, when [i][0] is marked zero or [0][j] is marked zero set current position as zero! This is important!;&lt;/li&gt;
&lt;li&gt;Finally, go back to check two boolean value, and set that row or col as zero if boolean value is true;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
&lt;code class=&#34;java&#34;&gt;
public class Solution {
    /**
     * @param matrix: A list of lists of integers
     * @return: Void
     */
    public void setZeroes(int[][] matrix) {

        if(matrix == null || matrix.length == 0)
            return;
        
        boolean row = false;
        boolean col = false;
                        
        for(int i = 0; i &lt; matrix.length; i++)
            if(matrix[i][0] == 0)
                col = true;
                
        for(int j = 0; j &lt; matrix[0].length; j++)
            if(matrix[0][j] == 0)
                row = true;
        
        for(int i = 1; i &lt; matrix.length; i++)
            for(int j = 1; j &lt; matrix[i].length; j++) 
                if(matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
                
        for(int i = 1; i &lt; matrix.length; i++){ 
            for(int j = 1; j &lt; matrix[0].length; j++){
                if(matrix[i][0] == 0 || matrix[0][j] == 0)
                    matrix[i][j] = 0;
            }   
        }
        
        if(row)
            for(int j = 0; j &lt; matrix[0].length; j++)
                    matrix[0][j] = 0;
                    
        if(col)
            for(int i = 0; i &lt; matrix.length; i++)
                    matrix[i][0] = 0;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>What Is Good Java API</title>
      <link>http://xmruibi.github.io/2015/09/12/what-is-good-java-api/</link>
      <pubDate>Sat, 12 Sep 2015 00:00:00 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/09/12/what-is-good-java-api/</guid>
      <description>

&lt;p&gt;Here are some good points for designing a good Java API!&lt;/p&gt;

&lt;h2 id=&#34;rule-1-establish-strong-terms&#34;&gt;Rule #1: Establish strong terms&lt;/h2&gt;

&lt;p&gt;If your API grows, there will be repetitive use of the same terms, over and over again. For instance, some actions will be come in several flavours resulting in various classes / types / methods, that differ only subtly in behaviour. The fact that they’re similar should be reflected by their names. Names should use strong terms. Take JDBC for instance. No matter how you execute a Statement, you will always use the term execute to do it. For instance, you will call any of these methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;execute(String)
executeBatch()
executeQuery(String)
executeUpdate(String)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In a similar fashion, you will always use the term close to release resources, no matter which resource you’re releasing. For instance, you will call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Connection.close()
Statement.close()
ResultSet.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a matter of fact, close is such a strong and established term in the JDK, that it has lead to the interfaces java.io.Closeable (since Java 1.5), and java.lang.AutoCloseable (since Java 1.7), which generally establish a contract of releasing resources.&lt;/p&gt;

&lt;p&gt;Rule violation: Observable&lt;/p&gt;

&lt;p&gt;This rule is violated a couple of times in the JDK. For instance, in the java.util.Observable class. While other “Collection-like” types established the terms&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;size()
remove()
removeAll()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;… this class declares&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;countObservers()
deleteObserver(Observer)
deleteObservers()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no good reason for using other terms in this context. The same applies to Observer.update(), which should really be called notify(), an otherwise established term in JDK APIs&lt;/p&gt;

&lt;p&gt;Rule violation: Spring. Most of it&lt;/p&gt;

&lt;p&gt;Spring has really gotten popular in the days when J2EE was weird, slow, and cumbersome. Think about EJB 2.0… There may be similar opinions on Spring out there, which are off-topic for this post. Here’s how Spring violates this concrete rule. A couple of random examples where Spring fails to establish strong terms, and uses long concatenations of meaningless, inconcise words instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AbstractBeanFactoryBasedTargetSourceCreator
AbstractInterceptorDrivenBeanDefinitionDecorator
AbstractRefreshablePortletApplicationContext
AspectJAdviceParameterNameDiscoverer
BeanFactoryTransactionAttributeSourceAdvisor
ClassPathScanningCandidateComponentProvider
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;… this could go on indefinitely, my favourite being …&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apart from “feeling” like a horrible API (to me), here’s some more objective analysis:&lt;/p&gt;

&lt;p&gt;What’s the difference between a Creator and a Factory
What’s the difference between a Source and a Provider?
What’s the non-subtle difference between an Advisor and a Provider?
What’s the non-subtle difference between a Discoverer and a Provider?
Is an Advisor related to an AspectJAdvice?
Is it a ScanningCandidate or a CandidateComponent?
What’s a TargetSource? And how would it be different from a SourceTarget if not a SourceSource or my favourite: A SourceSourceTargetProviderSource?
Gary Fleming commented on my previous blog post about Spring’s funny class names:&lt;/p&gt;

&lt;p&gt;I’d be willing to bet that a Markov-chain generated class name (based on Spring Security) would be indistinguishable from the real thing.&lt;/p&gt;

&lt;p&gt;Back to more seriousness…&lt;/p&gt;

&lt;h2 id=&#34;rule-2-apply-symmetry-to-term-combinations&#34;&gt;Rule #2: Apply symmetry to term combinations&lt;/h2&gt;

&lt;p&gt;Once you’ve established strong terms, you will start combining them. When you look at the JDK’s Collection APIs, you will notice the fact that they are symmetric in a way that they’ve established the terms add(), remove(), contains(), and all, before combining them symmetrically:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;add(E)
addAll(Collection&amp;lt;? extends E&amp;gt;)
remove(Object)
removeAll(Collection&amp;lt;?&amp;gt;)
contains(Object)
containsAll(Collection&amp;lt;?&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, the Collection type is a good example where an exception to this rule may be acceptable, when a method doesn’t “pull its own weight”. This is probably the case for retainAll(Collection&amp;lt;?&amp;gt;), which doesn’t have an equivalent retain(E) method. It might just as well be a regular violation of this rule, though.&lt;/p&gt;

&lt;p&gt;####Rule violation: Map&lt;/p&gt;

&lt;p&gt;This rule is violated all the time, mostly because of some methods not pulling their own weight (which is ultimately a matter of taste). With Java 8′s defender methods, there will no longer be any excuse of not adding default implementations for useful utility methods that should’ve been on some types. For instance: Map. It violates this rule a couple of times:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It has keySet() and also containsKey(Object)&lt;/li&gt;
&lt;li&gt;It has values() and also containsValue(Object)&lt;/li&gt;
&lt;li&gt;It has entrySet() but no containsEntry(K, V)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Observe also, that there is no point of using the term Set in the method names. The method signature already indicates that the result has a Set type. It would’ve been more consistent and symmetric if those methods would’ve been named keys(), values(), entries(). (On a side-note, Sets and Lists are another topic that I will soon blog about, as I think those types do not pull their own weight either)&lt;/p&gt;

&lt;p&gt;At the same time, the Map interface violates this rule by providing&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;put(K, V) and also putAll(Map)&lt;/li&gt;
&lt;li&gt;remove(Object), but no removeAll(Collection&amp;lt;?&amp;gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Besides, establishing the term clear() instead of reusing removeAll() with no arguments is unnecessary. This applies to all Collection API members. In fact, the clear() method also violates rule #1. It is not immediately obvious, if clear does anything subtly different from remove when removing collection elements.&lt;/p&gt;

&lt;h2 id=&#34;rule-3-add-convenience-through-overloading&#34;&gt;Rule #3: Add convenience through overloading&lt;/h2&gt;

&lt;p&gt;There is mostly only one compelling reason, why you would want to overload a method: Convenience. Often you want to do precisely the same thing in different contexts, but constructing that very specific method argument type is cumbersome. So, for convenience, you offer your API users another variant of the same method, with a “friendlier” argument type set. This can be observed again in the Collection type. We have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;toArray(), which is a convenient overload of…
toArray(T[])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another example is the Arrays utility class. We have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;copyOf(T[], int), which is an incompatible overload of…
copyOf(boolean[], int), and of…
copyOf(int[], int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;… and all the others
Overloading is mostly used for two reasons:&lt;/p&gt;

&lt;p&gt;Providing “default” argument behaviour, as in Collection.toArray()
Supporting several incompatible, yet “similar” argument sets, as in Arrays.copyOf()
Other languages have incorporated these concepts into their language syntax. Many languages (e.g. PL/SQL) formally support named default arguments. Some languages (e.g. JavaScript) don’t even care how many arguments there really are. And another, new JVM language called Ceylon got rid of overloading by combining the support for named, default arguments with union types. As Ceylon is a statically typed language, this is probable the most powerful approach of adding convenience to your API.&lt;/p&gt;

&lt;p&gt;####Rule violation: TreeSet&lt;/p&gt;

&lt;p&gt;It is hard to find a good example of a case where this rule is violated in the JDK. But there is one: the TreeSet and TreeMap. Their constructors are overloaded several times. Let’s have a look at these two constructors:&lt;/p&gt;

&lt;p&gt;TreeSet(Collection&amp;lt;? extends E&amp;gt;)
TreeSet(SortedSet&lt;E&gt;)
The latter “cleverly” adds some convenience to the first in that it extracts a well-known Comparator from the argument SortedSet to preserve ordering. This behaviour is quite different from the compatible (!) first constructor, which doesn’t do an instanceof check of the argument collection. I.e. these two constructor calls result in different behaviour:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SortedSet&amp;lt;Object&amp;gt; original = // [...]
// Preserves ordering:
new TreeSet&amp;lt;Object&amp;gt;(original);
// Resets ordering:
new TreeSet&amp;lt;Object&amp;gt;((Collection&amp;lt;Object&amp;gt;) original);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These constructors violate the rule in that they produce completely different behaviour. They’re not just mere convenience.&lt;/p&gt;

&lt;h2 id=&#34;rule-4-consistent-argument-ordering&#34;&gt;Rule #4: Consistent argument ordering&lt;/h2&gt;

&lt;p&gt;Be sure that you consistently order arguments of your methods. This is an obvious thing to do for overloaded methods, as you can immediately see how it is better to always put the array first and the int after in the previous example from the Arrays utility class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;copyOf(T[], int), which is an incompatible overload of…
copyOf(boolean[], int)
copyOf(int[], int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;… and all the others
But you will quickly notice that all methods in that class will put the array being operated on first. Some examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;binarySearch(Object[], Object)
copyOfRange(T[], int, int)
fill(Object[], Object)
sort(T[], Comparator&amp;lt;? super T&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;####Rule violation: Arrays&lt;/p&gt;

&lt;p&gt;The same class also “subtly” violates this rule in that it puts optional arguments in between other arguments, when overloading methods. For instance, it declares&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fill(Object[], Object)
fill(Object[], int, int, Object)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the latter should’ve been fill(Object[], Object, int, int). This is a “subtle” rule violation, as you may also argue that those methods in Arrays that restrict an argument array to a range will always put the array and the range argument together. In that way, the fill() method would again follow the rule as it provides the same argument order as copyOfRange(), for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fill(Object[], int, int, Object)
copyOfRange(T[], int, int)
copyOfRange(T[], int, int, Class)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will never be able to escape this problem if you heavily overload your API. Unfortunately, Java doesn’t support named parameters, which helps formally distinguishing arguments in a large argument list, as sometimes, large argument lists cannot be avoided.&lt;/p&gt;

&lt;p&gt;Rule violation: String&lt;/p&gt;

&lt;p&gt;Another case of a rule violation is the String class:&lt;/p&gt;

&lt;p&gt;regionMatches(int, String, int, int)
regionMatches(boolean, int, String, int, int)
The problems here are:&lt;/p&gt;

&lt;p&gt;It is hard to immediately understand the difference between the two methods, as the optional boolean argument is inserted at the beginning of the argument list
It is hard to immediately understand the purpose of every int argument, as there are many arguments in a single method&lt;/p&gt;

&lt;h2 id=&#34;rule-5-establish-return-value-types&#34;&gt;Rule #5: Establish return value types&lt;/h2&gt;

&lt;p&gt;This may be a bit controversial as people may have different views on this topic. No matter what your opinion is, however, you should create a consistent, regular API when it comes to defining return value types. An example rule set (on which you may disagree):&lt;/p&gt;

&lt;p&gt;Methods returning a single object should return null when no object was found
Methods returning several objects should return an empty List, Set, Map, array, etc. when no object was found (never null)
Methods should only throw exceptions in case of an … well, an exception
With such a rule set, it is not a good practice to have 1-2 methods lying around, which:&lt;/p&gt;

&lt;p&gt;… throw ObjectNotFoundExceptions when no object was found
… return null instead of empty Lists
Rule violation: File&lt;/p&gt;

&lt;p&gt;File is an example of a JDK class that violates many rules. Among them, the rule of regular return types. Its File.list() Javadoc reads:&lt;/p&gt;

&lt;p&gt;An array of strings naming the files and directories in the directory denoted by this abstract pathname. The array will be empty if the directory is empty. Returns null if this abstract pathname does not denote a directory, or if an I/O error occurs.&lt;/p&gt;

&lt;p&gt;So, the correct way to iterate over file names (if you’re doing defensive programming) is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String[] files = file.list();
// You should never forget this null check!
if (files != null) {
    for (String file : files) {
    // Do things with your file
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, we could argue that the Java 5 expert group could’ve been nice with us and worked that null check into their implementation of the foreach loop. Similar to the missing null check when switching over an enum (which should lead to the default: case). They’ve probably preferred the “fail early” approach in this case.
The point here is that File already has sufficient means of checking if file is really a directory (File.isDirectory()). And it should throw an IOException if something went wrong, instead of returning null. This is a very strong violation of this rule, causing lots of pain at the call-site… Hence:&lt;/p&gt;

&lt;p&gt;NEVER return null when returning arrays or collections!&lt;/p&gt;

&lt;p&gt;####Rule violation: JPA&lt;/p&gt;

&lt;p&gt;An example of how JPA violates this rule is the way how entities are retrieved from the EntityManager or from a Query:&lt;/p&gt;

&lt;p&gt;EntityManager.find() methods return null if no entity could be found
Query.getSingleResult() throws a NoResultException if no entity could be found
As NoResultException is a RuntimeException this flaw heavily violates the Principle of Least Astonishment, as you might stay unaware of this difference until runtime!&lt;/p&gt;

&lt;p&gt;IF you insist on throwing NoResultExceptions, make them checked exceptions as client code MUST handle them&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fast Power</title>
      <link>http://xmruibi.github.io/2015/09/11/fast-power/</link>
      <pubDate>Fri, 11 Sep 2015 19:06:42 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/09/11/fast-power/</guid>
      <description>

&lt;p&gt;Calculate the an % b where a, b and n are all 32bit integers.&lt;/p&gt;

&lt;p&gt;*Example: *
 For 231 % 3 = 2
 For 1001000 % 1000 = 0&lt;/p&gt;

&lt;p&gt;*Challenge: *
 O(logn)&lt;/p&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Divide and Conquer&lt;/li&gt;
&lt;li&gt;Think about the two basic condition: n is 1 and n is 0;&lt;/li&gt;
&lt;li&gt;Each time we divide the n into two part (n/2);&lt;/li&gt;
&lt;li&gt;Then we got the combine value (divide * divide) from both parts (they&amp;rsquo;re eqaul, actually);&lt;/li&gt;
&lt;li&gt;While n is odd, we need to add one more &amp;laquo;a&amp;raquo; time (*a);&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
&lt;code class=&#34;java&#34;&gt;
class Solution {
    /*
     * @param a, b, n: 32bit integers
     * @return: An integer
     */
    public int fastPower(int a, int b, int n) {

        if(n == 1)
            return a % b;
        
        if(n == 0)
            return 1 % b;
        
        long divide = fastPower(a, b, n/2);
        long combine = divide * divide;
        combine %= b;
        if(n % 2 == 1)
            combine *= (long)a;
        combine %= b;
        return (int)combine;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Rotate Image</title>
      <link>http://xmruibi.github.io/2015/09/11/rotate-image/</link>
      <pubDate>Fri, 11 Sep 2015 16:06:19 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/09/11/rotate-image/</guid>
      <description>

&lt;p&gt;You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise).&lt;/p&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Headache Implement question!&lt;/li&gt;
&lt;li&gt;Very carefully to treat index.&lt;/li&gt;
&lt;li&gt;Only calculate the &amp;frac14; of index in matrix!&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
&lt;code class=&#34;java&#34;&gt;
public class Solution {
    /**
     * @param matrix: A list of lists of integers
     * @return: Void
     */
    public void rotate(int[][] matrix) {
        
        int n = matrix.length;

        // One of i or j need to consider boundry!
        for(int i = 0; i &lt; ( n &gt;&gt; 1); i ++) {
        // that&#39;s why j &lt; (n+1) / 2, that is the boundry!
            for(int j = 0; j &lt; ( n+1 &gt;&gt; 1); j++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = tmp;
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Subarray Sum I</title>
      <link>http://xmruibi.github.io/2015/09/09/subarray-sum-i/</link>
      <pubDate>Wed, 09 Sep 2015 10:40:49 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/09/09/subarray-sum-i/</guid>
      <description>&lt;p&gt;Given an integer array, find a subarray where the sum of numbers is zero. Your code should return the index of the first number and the index of the last number.&lt;/p&gt;

&lt;pre&gt;
    &lt;code class=&#34;java&#34;&gt;
public class Solution {
    /**
     * @param nums: A list of integers
     * @return: A list of integers includes the index of the first number 
     *          and the index of the last number
     */
    public ArrayList&lt;Integer&gt; subarraySum(int[] nums) {
        // write your code here
        ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        if(nums == null || nums.length == 0)
            return res;       
        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer&gt;();
        int sum = 0;
        map.put(0, 0);
        for(int i = 0; i &lt; nums.length; i++) {
            if(map.containsKey(sum+nums[i])) {
                res.add(map.get(sum+nums[i]));
                res.add(i);
                return res;
            }
            map.put(sum+=nums[i], i+1);
        }
        return res;
    }
}   

&lt;/code&gt;

&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Subarray Sum II</title>
      <link>http://xmruibi.github.io/2015/09/08/subarray-sum-ii/</link>
      <pubDate>Tue, 08 Sep 2015 21:18:09 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/09/08/subarray-sum-ii/</guid>
      <description>&lt;p&gt;Given an integer array, find a subarray where the sum of numbers is between two given interval. Your code should return the number of possible answer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;java&#34;&gt;
public int subarraySumII(int[] A, int start, int end) {
    int res = 0;
        for(int i = 1; i &lt; A.length; i++)
            A[i] += A[i - 1];
        
        Arrays.sort(A);
        for(int i = 0; i &lt; A.length; i++) {
            if(A[i] &gt;= start &amp;&amp; A[i] &lt;= end)
                res++;
            // start &lt;= A[i] - A[j] &lt;= end
            // so the max bound and min bound of A[j] are following:
            int max = A[i] - start;
            int min = A[i] - end;
            // max + 1 make sure the right bound of max value and also index problem
            int range = findInsPos(A, max + 1) - findInsPos(A, min);
            res += range;
        }
        return res;
}
private int findInsPos(int[] A, int value) {
        int l = 0, r = A.length - 1;
        
        while(l &lt; r - 1) {
            int m = l + ((r - l) &gt;&gt;1);
            if(A[m] &lt; value)
                l = m;
            else
                r = m;
        }
        if(A[l] &gt;= value)
            return l;
        else
            return r;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Immutable Classes</title>
      <link>http://xmruibi.github.io/2015/08/11/immutable-classes/</link>
      <pubDate>Tue, 11 Aug 2015 23:57:44 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/08/11/immutable-classes/</guid>
      <description>

&lt;h3 id=&#34;what-is-immutable-classes&#34;&gt;What is Immutable Classes&lt;/h3&gt;

&lt;p&gt;不可变对象（immutable objects），后面文章我将使用immutable objects来代替不可变对象！&lt;/p&gt;

&lt;p&gt;那么什么是immutable objects?什么又是mutable Objects呢？&lt;/p&gt;

&lt;p&gt;immutable Objects就是那些一旦被创建，它们的状态就不能被改变的Objects，每次对他们的改变都是产生了新的immutable的对象，而mutable Objects就是那些创建后，状态可以被改变的Objects.&lt;/p&gt;

&lt;p&gt;举个例子：String和StringBuilder，String是immutable的，每次对于String对象的修改都将产生一个新的String对象，而原来的对象保持不变，而StringBuilder是mutable，因为每次对于它的对象的修改都作用于该对象本身，并没有产生新的对象。&lt;/p&gt;

&lt;p&gt;但有的时候String的immutable特性也会引起安全问题，这就是密码应该存放在字符数组中而不是String中的原因！&lt;/p&gt;

&lt;p&gt;immutable objects 比传统的mutable对象在多线程应用中更具有优势，它不仅能够保证对象的状态不被改变，而且还可以不使用锁机制就能被其他线程共享。&lt;/p&gt;

&lt;p&gt;实际上JDK本身就自带了一些immutable类，比如String，Integer以及其他包装类。为什么说String是immutable的呢？比如：java.lang.String 的trim，uppercase,substring等方法，它们返回的都是新的String对象，而并不是直接修改原来的对象。&lt;/p&gt;

&lt;p&gt;如何在Java中写出Immutable的类？&lt;/p&gt;

&lt;p&gt;要写出这样的类，需要遵循以下几个原则：&lt;/p&gt;

&lt;p&gt;1）immutable对象的状态在创建之后就不能发生改变，任何对它的改变都应该产生一个新的对象。&lt;/p&gt;

&lt;p&gt;2）Immutable类的所有的field都应该是final的。&lt;/p&gt;

&lt;p&gt;3）对象必须被正确的创建，比如：对象引用在对象创建过程中不能泄露(leak)。&lt;/p&gt;

&lt;p&gt;4）对象应该是final的，以此来限制子类继承父类，以避免子类改变了父类的immutable特性。&lt;/p&gt;

&lt;p&gt;5）如果类中包含mutable类对象，那么返回给客户端的时候，返回该对象的一个拷贝，而不是该对象本身（该条可以归为第一条中的一个特例）&lt;/p&gt;

&lt;p&gt;当然不完全遵守上面的原则也能够创建immutable的类，比如String的hashcode就不是final的，但它能保证每次调用它的值都是一致的，无论你多少次计算这个值，它都是一致的，因为这些值的是通过计算final的属性得来的！&lt;/p&gt;

&lt;p&gt;另外，如果你的Java类中存在很多可选的和强制性的字段，你也可以使用建造者模式来创建一个immutable的类。&lt;/p&gt;

&lt;p&gt;下面是一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final class Contacts {
 
    private final String name;
    private final String mobile;
 
    public Contacts(String name, String mobile) {
        this.name = name;
        this.mobile = mobile;
    }
   
    public String getName(){
        return name;
    }
   
    public String getMobile(){
        return mobile;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们为类添加了final修饰，从而避免因为继承和多态引起的immutable风险。
上面是最简单的一种实现immutable类的方式，可以看到它的所有属性都是final的。&lt;/p&gt;

&lt;p&gt;有时候你要实现的immutable类中可能包含mutable的类，比如java.util.Date,尽管你将其设置成了final的，但是它的值还是可以被修改的，为了避免这个问题，我们建议返回给用户该对象的一个拷贝，这也是Java的最佳实践之一。下面是一个创建包含mutable类对象的immutable类的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final class ImmutableReminder{
    private final Date remindingDate;
   
    public ImmutableReminder (Date remindingDate) {
        if(remindingDate.getTime() &amp;lt; System.currentTimeMillis()){
            throw new IllegalArgumentException(&amp;quot;Can not set reminder” +
                        “ for past time: &amp;quot; + remindingDate);
        }
        this.remindingDate = new Date(remindingDate.getTime());
    }
   
    public Date getRemindingDate() {
        return (Date) remindingDate.clone();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的getRemindingDate()方法可以看到，返回给用户的是类中的remindingDate属性的一个拷贝，这样的话如果别人通过getRemindingDate()方法获得了一个Date对象，然后修改了这个Date对象的值，那么这个值的修改将不会导致ImmutableReminder类对象中remindingDate值的修改。
使用Immutable类的好处：
1）Immutable对象是线程安全的，可以不用被synchronize就在并发环境中共享&lt;/p&gt;

&lt;p&gt;2）Immutable对象简化了程序开发，因为它无需使用额外的锁机制就可以在线程间共享&lt;/p&gt;

&lt;p&gt;3）Immutable对象提高了程序的性能，因为它减少了synchroinzed的使用&lt;/p&gt;

&lt;p&gt;4）Immutable对象是可以被重复使用的，你可以将它们缓存起来重复使用，就像字符串字面量和整型数字一样。你可以使用静态工厂方法来提供类似于valueOf（）这样的方法，它可以从缓存中返回一个已经存在的Immutable对象，而不是重新创建一个。&lt;/p&gt;

&lt;p&gt;immutable也有一个缺点就是会制造大量垃圾，由于他们不能被重用而且对于它们的使用就是”用“然后”扔“，字符串就是一个典型的例子，它会创造很多的垃圾，给垃圾收集带来很大的麻烦。当然这只是个极端的例子，合理的使用immutable对象会创造很大的价值。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Algorithm Questions Conclusion</title>
      <link>http://xmruibi.github.io/2015/08/11/algorithm-questions-conclusion/</link>
      <pubDate>Tue, 11 Aug 2015 00:04:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/08/11/algorithm-questions-conclusion/</guid>
      <description>

&lt;h4 id=&#34;preface&#34;&gt;Preface:&lt;/h4&gt;

&lt;p&gt;This is the collection of interview questions concluded by me, which is including questions from LeetCode, Cracking Code Interview, and Handwriting Coding Handbook.&lt;/p&gt;

&lt;h2 id=&#34;main&#34;&gt;Main:&lt;/h2&gt;

&lt;h3 id=&#34;1-basic-algorithm-part&#34;&gt;1. Basic Algorithm Part:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linked List Summary:
&lt;a href=&#34;https://www.zybuluo.com/xmruibi/note/71287&#34;&gt;https://www.zybuluo.com/xmruibi/note/71287&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Stack &amp;amp; Queue Summary:
&lt;a href=&#34;https://www.zybuluo.com/xmruibi/note/71283&#34;&gt;https://www.zybuluo.com/xmruibi/note/71283&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Binary Tree Summary:
&lt;a href=&#34;https://www.zybuluo.com/xmruibi/note/56634&#34;&gt;https://www.zybuluo.com/xmruibi/note/56634&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mathematical Problem Summary:
&lt;a href=&#34;https://www.zybuluo.com/xmruibi/note/71211&#34;&gt;https://www.zybuluo.com/xmruibi/note/71211&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Big Number Problem Summary:
&lt;a href=&#34;https://www.zybuluo.com/xmruibi/note/71208&#34;&gt;https://www.zybuluo.com/xmruibi/note/71208&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-data-structure&#34;&gt;2. Data Structure:&lt;/h3&gt;

&lt;h4 id=&#34;java-collection-summary&#34;&gt;Java Collection Summary&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Abstract Collection
&lt;a href=&#34;https://www.zybuluo.com/xmruibi/note/71477&#34;&gt;https://www.zybuluo.com/xmruibi/note/71477&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;list&#34;&gt;- List&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;List Interface &amp;amp; Abstract List &amp;amp; Abstract Sequential List
&lt;a href=&#34;https://www.zybuluo.com/xmruibi/note/71582&#34;&gt;https://www.zybuluo.com/xmruibi/note/71582&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ArrayList
&lt;a href=&#34;https://www.zybuluo.com/xmruibi/note/71425&#34;&gt;https://www.zybuluo.com/xmruibi/note/71425&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;set&#34;&gt;- Set&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Set &amp;amp; Abstract Set
&lt;a href=&#34;https://www.zybuluo.com/xmruibi/note/71585&#34;&gt;https://www.zybuluo.com/xmruibi/note/71585&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;map&#34;&gt;- Map&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Map &amp;amp; Abstract Map
&lt;a href=&#34;https://www.zybuluo.com/xmruibi/note/71595&#34;&gt;https://www.zybuluo.com/xmruibi/note/71595&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HashMap
&lt;a href=&#34;https://www.zybuluo.com/xmruibi/note/71622&#34;&gt;https://www.zybuluo.com/xmruibi/note/71622&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;graph&#34;&gt;- Graph&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Undirected Graph&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Directed Graph&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-algorithm-thinking&#34;&gt;3 Algorithm Thinking&lt;/h3&gt;

&lt;h4 id=&#34;sort&#34;&gt;Sort&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Comparsion Sort Problems Summary:
&lt;a href=&#34;https://www.zybuluo.com/xmruibi/note/71280&#34;&gt;https://www.zybuluo.com/xmruibi/note/71280&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Linear Sort Solutions Summary:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Big Data Sort Solutions Summary:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;search&#34;&gt;Search&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Binary Search Summary:
&lt;a href=&#34;https://www.zybuluo.com/xmruibi/note/71214&#34;&gt;https://www.zybuluo.com/xmruibi/note/71214&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;dfs-and-bfs&#34;&gt;DFS AND BFS&lt;/h4&gt;

&lt;h4 id=&#34;divide-and-conquer&#34;&gt;Divide and Conquer&lt;/h4&gt;

&lt;h4 id=&#34;dynamic-programming&#34;&gt;Dynamic Programming&lt;/h4&gt;

&lt;h3 id=&#34;4-misc&#34;&gt;4 Misc.&lt;/h3&gt;

&lt;h3 id=&#34;5-java-techs&#34;&gt;5 Java Techs&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>AccessControl</title>
      <link>http://xmruibi.github.io/2015/07/12/accesscontrol/</link>
      <pubDate>Sun, 12 Jul 2015 00:03:07 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/07/12/accesscontrol/</guid>
      <description>&lt;p&gt;Reading Note while reading Java Best Practice.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Access Level&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Private:&lt;/li&gt;
&lt;li&gt;Package-private: Default&lt;/li&gt;
&lt;li&gt;Protected:&lt;/li&gt;
&lt;li&gt;Public&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Make each class or member as inaccessiable as possible!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Implements Serializable may leak this class in API.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instance field and static field must not be public!
Lost the control of this field and not thread safety but may be okay for immutable final instance field.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An array with not-zero length is mutable!
Cannnot return public static array field.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The only two ways to return above field is by establish a immutable list or create a public method returning clone object!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Don&amp;rsquo;t expose the internal data field:
public class should not expose any mutable field;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>