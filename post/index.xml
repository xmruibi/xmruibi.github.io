<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Geek Think</title>
    <link>http://xmruibi.github.io/post/</link>
    <description>Recent content in Posts on Geek Think</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Sat, 14 Nov 2015 00:30:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Constant Time Random Picker</title>
      <link>http://xmruibi.github.io/2015/11/14/constant-time-random-picker/</link>
      <pubDate>Sat, 14 Nov 2015 00:30:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/constant-time-random-picker/</guid>
      <description>

&lt;p&gt;Design a data structure that supports insert, delete, search and getRandom in constant time.&lt;/p&gt;

&lt;p&gt;Design a data structure that supports following operations in Θ(1) time.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;insert(x)&lt;/code&gt;: Inserts an item x to the data structure if not already present.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove(x)&lt;/code&gt;: Removes an item x from the data structure if present.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;search(x)&lt;/code&gt;: Searches an item x in the data structure.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getRandom()&lt;/code&gt;: Returns a random element from current set of elements&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;think:fbe9fdf4f7686b0780359874c12ae63a&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;We can use hashing to support first 3 operations in Θ(1) time. How to do the 4th operation? The idea is to use a resizable array (ArrayList in Java, vector in C) together with hashing. Resizable arrays support insert in Θ(1) amortized time complexity. To implement getRandom(), we can simply pick a random number from 0 to size-1 (size is number of current elements) and return the element at that index. The hash map stores array values as keys and array indexes as values.&lt;/p&gt;

&lt;p&gt;Following are detailed operations.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;insert(x)&lt;/li&gt;
&lt;li&gt;Check if x is already present by doing a hash map lookup.&lt;/li&gt;
&lt;li&gt;If not present, then insert it at the end of the array.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add in hash table also, x is added as key and last array index as index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;remove(x)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check if x is present by doing a hash map lookup.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If present, then find its index and remove it from hash map.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swap the last element with this element in array and remove the last element.
Swapping is done because the last element can be removed in O(1) time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Update index of last element in hash map.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getRandom()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generate a random number from 0 to last index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Return the array element at the randomly generated index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;search(x)
Do a lookup for x in hash map.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:fbe9fdf4f7686b0780359874c12ae63a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ConstantTimeRandomPicker {
	
	private final ArrayList&amp;lt;Integer&amp;gt; arr;
	private final HashMap&amp;lt;Integer, Integer&amp;gt; map; // value - index
    Random r;
	
	public ConstantTimeRandomPicker() {
		this.arr = new ArrayList&amp;lt;Integer&amp;gt;();
		this.map = new HashMap&amp;lt;Integer, Integer&amp;gt;();
	}
	
	public void add(int val) {
		arr.add(val);
		map.put(arr.size() - 1, val);
	}
	
	public void remove(int val) {
		remove(map.get(val), val);
	}
	
	public void removeRandom() {
		int val = arr.get(r.nextInt(arr.size()));
		remove(map.get(val), val);
	}
	
	public int getRandom() {
		return arr.get(r.nextInt(arr.size()));
	}
	
	public int search(int val) {
		return arr.get(map.get(val));
	}

	private void remove(int idx, int val) {
		
		// swap with the last element
		int last = arr.get(arr.size() - 1);
		// put the last element to the current index
		arr.set(idx, last);
		// remove the last element
		arr.remove(arr.size() - 1);
				
		// update the last element&#39;s index in hashmap
		map.put(last, idx);		
		// remove the removal value
		map.remove(val);
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Intervals and Covered Length</title>
      <link>http://xmruibi.github.io/2015/11/14/intervals-and-covered-length/</link>
      <pubDate>Sat, 14 Nov 2015 00:30:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/intervals-and-covered-length/</guid>
      <description>

&lt;p&gt;Design a structrue can get interval pair and a function which can return the total cover length.&lt;/p&gt;

&lt;h2 id=&#34;partial-code:a398446ee2bc7e4d0eef3e4051fe083f&#34;&gt;Partial Code&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Intervals {

	/**
	 * Adds an interval [from, to] into internal structure.
	 */
	void addInterval(int from, int to);

	/**
	 * Returns a total length covered by intervals. If several intervals
	 * intersect, intersection should be counted only once. Example:
	 *
	 * addInterval(3, 6) addInterval(8, 9) addInterval(1, 5)
	 *
	 * getTotalCoveredLength() -&amp;gt; 6 i.e. [1,5] and [3,6] intersect and give a
	 * total covered interval [1,6] [1,6] and [8,9] don&#39;t intersect so total
	 * covered length is a sum for both intervals, that is 6.
	 *
	 * _________ ___ ____________
	 *
	 * 0 1 2 3 4 5 6 7 8 9 10
	 *
	 */
	int getTotalCoveredLength();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:a398446ee2bc7e4d0eef3e4051fe083f&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IntervalProblem implements Intervals {

    private class Interval {
        int from, to;

        public Interval(int from, int to) {
            this.from = from;
            this.to = to;
        }
    }

    List&amp;lt;Interval&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    @Override
    public void addInterval(int start, int end) {
        if (list.size() == 0) {
            list.add(new Interval(start, end));
            return;
        }       

        ListIterator&amp;lt;Interval&amp;gt; li = list.listIterator();

        while(li.hasNext()){
            Interval itv = li.next();
            if(start &amp;lt;= itv.to){
                if(end &amp;lt; itv.from){ //newInterval does not overlap with current itv, time to insert
                    li.remove();
                    li.add(new Interval(start, end));
                    li.add(itv);
                    return;
                }
                // still some overlap so compare start &amp;amp; end
                start = Math.min(start, itv.from);
                end = Math.max(end, itv.to);
                li.remove();
            }
        }
        list.add(new Interval(start, end));
    }

    @Override
    public int getTotalCoveredLength() {
        if (list.size() == 0) 
            return 0;
        int sum = 0;
        for (int i = 0; i &amp;lt; list.size(); i++) {
            sum += (list.get(i).to - list.get(i).from);
        }
        return sum;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>K Nearest Points</title>
      <link>http://xmruibi.github.io/2015/11/13/k-nearest-points/</link>
      <pubDate>Fri, 13 Nov 2015 23:50:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/k-nearest-points/</guid>
      <description>

&lt;p&gt;Find K nearest Points by given the central point. Complete the class design for Point as implementing Comparable interface.&lt;/p&gt;

&lt;h2 id=&#34;think:8857fa3e9119e0ac4dde82275e35c3e7&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Comparable interface and Max heap&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:8857fa3e9119e0ac4dde82275e35c3e7&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class KNearestPoints {

    // finding k nearest neighbor from the original point using a MAX heap, each
    // time if the dist is less than the MAX we put it into the q.
    public Collection&amp;lt;Point&amp;gt; getClosestPoints(Collection&amp;lt;Point&amp;gt; points, int k) {
        PriorityQueue&amp;lt;Point&amp;gt; queue = new PriorityQueue&amp;lt;Point&amp;gt;(k);
        int i = 0;
        for(Point p:points) {
            if(i &amp;lt; k) {
                queue.add(p);
            }else{
                if(p.compareTo(queue.peek()) &amp;lt; 0) {
                    queue.poll();
                    queue.offer(p);
                }
            }
            i++;
        }
        return queue;
    }
}

class Point implements Comparable&amp;lt;Point&amp;gt; {
    final int x, y;
    final double dist;

    public Point(int x, int y, Point origin) {
        this.x = x;
        this.y = y;
        this.dist = Math.hypot(x - origin.x, y - origin.y);
    }

    @Override
    public int compareTo(Point o) {
        return Double.compare(this.dist, o.dist);
    }

    @Override
    public String toString() {
        return &amp;quot;x: &amp;quot; + x + &amp;quot; y: &amp;quot; + y;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Text File Iterator</title>
      <link>http://xmruibi.github.io/2015/11/13/text-file-iterator/</link>
      <pubDate>Fri, 13 Nov 2015 20:40:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/text-file-iterator/</guid>
      <description>

&lt;p&gt;Implement a (Java) Iterable object that iterates lines one by one from a text file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** A reference to a file. */
public class TextFile implements Iterable&amp;lt;String&amp;gt; {
  public TextFile(String fileName) { 
  	// please implement this
  }
  /** Begin reading the file, line by line. The returned Iterator.next() will return a line. */ 
  @Override
  public Iterator&amp;lt;String&amp;gt; iterator() { 
  	// please implement this
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-1:c8747d864080a32ac128d8a7bbaf43e1&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Keep maintain a BufferedReader&lt;/li&gt;
&lt;li&gt;The tricky part is the hasNext function, we should not use checking &lt;code&gt;br.readline() != null&lt;/code&gt; in this function, since it will cause the line skipping.&lt;/li&gt;
&lt;li&gt;So notice the &lt;code&gt;mark()&lt;/code&gt; and &lt;code&gt;reset()&lt;/code&gt; method in bufferedreader.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:c8747d864080a32ac128d8a7bbaf43e1&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TextFileIterator implements Iterable&amp;lt;String&amp;gt; {

	private final BufferedReader br;

	public TextFileIterator(String path) throws FileNotFoundException {
		br = new BufferedReader(new InputStreamReader(new FileInputStream(
				new File(path))));

	}

	public Iterator&amp;lt;String&amp;gt; iterator() {
		return new Iterator&amp;lt;String&amp;gt;() {
			@Override
			public boolean hasNext() {
				try {
					br.mark(1);
					if (br.read() &amp;lt; 0) 
						return false;					
					br.reset();
					return true;
				} catch (IOException e) {
					return false;
				}
			}

			@Override
			public String next() {
				try {
					return br.readLine();
				} catch (IOException e) {
					return null;
				}
			}
		};
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2:c8747d864080a32ac128d8a7bbaf43e1&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Scanner&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2:c8747d864080a32ac128d8a7bbaf43e1&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TextFileIterator implements Iterable&amp;lt;String&amp;gt; {

	private final Scanner sc;
	
	public TextFileIterator(String path) throws FileNotFoundException {
			sc = new Scanner(new File(path));
	}

	public Iterator&amp;lt;String&amp;gt; iterator() {
		return new Iterator&amp;lt;String&amp;gt;() {
			@Override
			public boolean hasNext() {
				return sc.hasNext();
			}

			@Override
			public String next() {
				return sc.nextLine();
			}
		};
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Zigzag Iterator</title>
      <link>http://xmruibi.github.io/2015/11/13/zigzag-iterator/</link>
      <pubDate>Fri, 13 Nov 2015 20:40:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/zigzag-iterator/</guid>
      <description>

&lt;p&gt;Given two 1d vectors, implement an iterator to return their elements alternately.&lt;/p&gt;

&lt;h3 id=&#34;example:c39b4a8138ca1f78be5fe1b3f188b037&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given two 1d vectors:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;v1&lt;/code&gt; = &lt;code&gt;[1, 2]&lt;/code&gt;
&lt;code&gt;v2&lt;/code&gt; = &lt;code&gt;[3, 4, 5, 6]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: &lt;code&gt;[1, 3, 2, 4, 5, 6]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;follow-up:c39b4a8138ca1f78be5fe1b3f188b037&#34;&gt;Follow up&lt;/h3&gt;

&lt;p&gt;What if you are given k 1d vectors? How well can your code be extended to such cases?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reverse a Stack using Recursion</title>
      <link>http://xmruibi.github.io/2015/11/13/reverse-a-stack-using-recursion/</link>
      <pubDate>Fri, 13 Nov 2015 20:39:16 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/reverse-a-stack-using-recursion/</guid>
      <description>

&lt;p&gt;Reverse a stack using recursion.&lt;/p&gt;

&lt;p&gt;You are not allowed to use loop constructs like while, for..etc, and you can only use the following ADT functions on Stack S:
- &lt;code&gt;isEmpty(S)&lt;/code&gt;
- &lt;code&gt;push(S)&lt;/code&gt;
- &lt;code&gt;pop(S)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think:67652d66ff3aed8bc58d000794c76ecc&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Very very trick problem&lt;/li&gt;
&lt;li&gt;The idea of the solution is to hold all values in Function Call Stack until the stack becomes empty. When the stack becomes empty, insert all held items one by one at the bottom of the stack.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:67652d66ff3aed8bc58d000794c76ecc&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void recrusion(Stack&amp;lt;Integer&amp;gt; stack) {
        if (stack.isEmpty())
            return;
        int tmp = stack.pop();
        recrusion(stack);
        helper(stack, tmp);
    }

    private static void helper(Stack&amp;lt;Integer&amp;gt; stack, int val) {
        if (stack.isEmpty())
            stack.push(val);
        else {
            int tmp = stack.pop();
            helper(stack, val);
            stack.push(tmp);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Two Sum Implementation</title>
      <link>http://xmruibi.github.io/2015/11/13/two-sum-implementation/</link>
      <pubDate>Fri, 13 Nov 2015 19:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/two-sum-implementation/</guid>
      <description>

&lt;p&gt;Finish a implementation for a interface where it store some data and returns true if there is any pair of numbers in the internal data structure which have sum @param val, and false otherwise.&lt;/p&gt;

&lt;h3 id=&#34;given-code:7520a8219794c9e393cc99906f6d5dad&#34;&gt;Given Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface TwoSum {
    /**
     * Stores @param input in an internal data structure.
     */
    void store(int input);
    /**
     * Returns true if there is any pair of numbers in the internal data structure which
     * have sum @param val, and false otherwise.
     * For example, if the numbers 1, -2, 3, and 6 had been stored,
     * the method should return true for 4, -1, and 9, but false for 10, 5, and 0
     */
    boolean test(int val);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:7520a8219794c9e393cc99906f6d5dad&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Two Sum problem has two way to solve

&lt;ul&gt;
&lt;li&gt;Sort strategy (O(nlogn) time, O(1) space);&lt;/li&gt;
&lt;li&gt;Set strategy (O(n) time, O(n) space);&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:7520a8219794c9e393cc99906f6d5dad&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TwoSumProblem implements TwoSum{
    
    // thread not safe, use CopyOnWriteArrayList&amp;lt;E&amp;gt; for thread safe
    List&amp;lt;Integer&amp;gt; list; 
    // save the previous data for unnecessary duplicate computation
    HashSet&amp;lt;Integer&amp;gt; set;
    
    public TwoSumProblem() {
        list = new ArrayList&amp;lt;&amp;gt;();
        set = new HashSet&amp;lt;&amp;gt;();
    }
    
    @Override
    public void store(int input) {
        list.add(input);    
    }

    @Override
    public boolean test(int val) {
        if(set.contains(val))
            return true;
        return checkTwoSum(val);
    }

    // sort strategy (O(nlogn) time, O(1) space)
    private boolean checkTwoSum(int target){
        Collections.sort(list);
        int l = 0, r = list.size() - 1;
        while(l &amp;lt; r) {
            int sum = list.get(l) + list.get(r);
            if(sum == target){
                set.add(target);
                return true;
            }else if(sum &amp;lt; target)
                l++;
            else
                r--;
        }
        return false;
    }

    // set strategy (O(n) time, O(n) space)
    private boolean checkTwoSumII(int target){
         int len = list.size();
           Set&amp;lt;Integer&amp;gt; mem = new HashSet();
            for(int i = 0; i &amp;lt; len; i++){
                if ( mem.contains(target - list.get(i)) 
                        return true;
               else 
                    mem.add(list.get(i));
            }
            return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Level Order with Position Preserved</title>
      <link>http://xmruibi.github.io/2015/11/13/level-order-with-position-preserved/</link>
      <pubDate>Fri, 13 Nov 2015 17:50:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/level-order-with-position-preserved/</guid>
      <description>

&lt;p&gt;Given a Tree, each node contains one digit value, print each level in a format with relative position preserved.&lt;/p&gt;

&lt;h3 id=&#34;example:2d2b69a30dfde4d7f80bc31959b14b6c&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;       eg.           1
                   /   \
                 2      4
                  \       \
                  3        7
    output:
                   1
               2      4
                 3      7
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:2d2b69a30dfde4d7f80bc31959b14b6c&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Tricky part is we should know the depth firstly. So that we can know how many space should be reserved in final line. Since the each line should preserved as most the length with the node&amp;rsquo;s amount in full tree of that depth.&lt;/li&gt;
&lt;li&gt;The length of each line should be the $2^{depth} - 1$&lt;/li&gt;
&lt;li&gt;Recursively to set the node value in the middle of left and right range.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:2d2b69a30dfde4d7f80bc31959b14b6c&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TreeLevelOrder {
	public List&amp;lt;String&amp;gt; printLevelwithSpacePreserved(TreeNode root) {
		List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
		int depth = getDepth(root);
		int len = (int) Math.pow(2, depth) - 1;
		List&amp;lt;List&amp;lt;Character&amp;gt;&amp;gt; space = new ArrayList&amp;lt;&amp;gt;();
		for (int i = 0; i &amp;lt; depth; i++) {
			List&amp;lt;Character&amp;gt; line = new ArrayList&amp;lt;&amp;gt;();
			for(int j = 0; j &amp;lt; len; j++)
				line.add(&#39; &#39;);
			space.add(line);
		}
		levelOrderRecrusion(space, root, 0, len - 1, 0);
		for (List&amp;lt;Character&amp;gt; cs : space) {
			StringBuilder sb = new StringBuilder();
			for (char c : cs)
				sb.append(c);
			res.add(sb.toString());
		}
		return res;
	}

	private void levelOrderRecrusion(List&amp;lt;List&amp;lt;Character&amp;gt;&amp;gt; res, TreeNode node,
			int l, int r, int lv) {
		if (node == null)
			return;
		List&amp;lt;Character&amp;gt; line = res.get(lv);
		int m = l + ((r - l) &amp;gt;&amp;gt; 1);
		line.set(m, (char) (node.val + &#39;0&#39;));
		levelOrderRecrusion(res, node.left, l, m - 1, lv + 1);
		levelOrderRecrusion(res, node.right, m + 1, r, lv + 1);
	}

	private int getDepth(TreeNode node) {
		if (node == null)
			return 0;
		return 1 + Math.max(getDepth(node.left), getDepth(node.right));
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Middle Index Stack</title>
      <link>http://xmruibi.github.io/2015/11/13/middle-index-stack/</link>
      <pubDate>Fri, 13 Nov 2015 17:50:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/middle-index-stack/</guid>
      <description>

&lt;p&gt;Design a stack with operations on middle element.&lt;/p&gt;

&lt;p&gt;How to implement a stack which will support following operations in O(1) time complexity?
1) push() which adds an element to the top of stack.
2) pop() which removes an element from top of stack.
3) findMiddle() which will return middle element of the stack.
4) deleteMiddle() which will delete the middle element.
Push and pop are standard stack operations.&lt;/p&gt;

&lt;h2 id=&#34;think:df16d69c6148fbc9ca34a1b8691b475e&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;The important question is, whether to use a linked list or array for implementation of stack?
- The key of this question is to design an doubly linked list to deal with those required functions.&lt;/p&gt;

&lt;h2 id=&#34;solution:df16d69c6148fbc9ca34a1b8691b475e&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MidStack implements MyStack{
    int size;
    Node top;
    Node mid;
    
    public MidStack() {
        int size = 0;
        top = mid = null;
    }
    @Override
    public void push(int val) {
        Node newNode = new Node(val);
        if(top == null) {
            top = newNode;
            mid = top;
        }else{
            top.next = newNode;
            newNode.prev = top;
            top = newNode;
            if(size % 2 ==0)
                mid = mid.next;
        }
        size++;
    }
    @Override
    public int pop() {
        int pop = top.val;
        top = top.prev;
        top.next = null;
        if(size % 2 !=0)
            mid = mid.prev;
        size--;
        return pop;
    }
    @Override
    public int findMiddle() {
        return mid.val;
    }
    @Override
    public void deleteMiddle() {
        if(size &amp;lt;= 2) {
            mid = top;
            top.prev = null;
            size--;
            return;
        }
            
        mid.next.prev = mid.prev;
        mid.prev.next = mid.next;
        mid = mid.prev;
        size--;
    }
    
    public static void main(String[] args) {
        MidStack stack = new MidStack();
        stack.push(1);stack.push(2);
        stack.push(3);stack.push(4);    
        System.out.println(stack.pop());
        System.out.println(stack.findMiddle());
        stack.deleteMiddle();
        stack.push(2);
        stack.push(3);stack.push(4);    
        System.out.println(stack.findMiddle());
        System.out.println(stack.pop());
        System.out.println(stack.findMiddle());
        System.out.println(stack.pop());
    }
}

interface MyStack{
    public void push(int val);
    public int pop();
    public int findMiddle();
    public void deleteMiddle();
}
class Node{
    int val;
    Node prev, next;
    public Node(int val) {
        this.val = val;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>The Second Minimum in Tournament Tree</title>
      <link>http://xmruibi.github.io/2015/11/13/the-second-minimum-in-tournament-tree/</link>
      <pubDate>Fri, 13 Nov 2015 17:50:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/the-second-minimum-in-tournament-tree/</guid>
      <description>

&lt;p&gt;Given a tournament tree try to find the second minimum value. Here the tournament tree is represented by a tree with node has the minimum value of children.&lt;/p&gt;

&lt;h3 id=&#34;example:87bd1bfcb3ac65273c0a27e5e481ef2e&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;By given the following tree, it should return &lt;code&gt;5&lt;/code&gt; as the second minimum value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                2
              /   \
            2      7
          /  \     |  \
         5    2    8   7
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:87bd1bfcb3ac65273c0a27e5e481ef2e&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This a full tree and each root is the min value of two children&lt;/li&gt;
&lt;li&gt;Each time we only concern the subtree root has the value equal to the root and record another child&amp;rsquo;s value as the candidate of second minimum.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:87bd1bfcb3ac65273c0a27e5e481ef2e&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TournamentTree {
    static int secMin = Integer.MAX_VALUE;

    // the given tree is a minimum value tree
    public static int getSecMin(TreeNode root) {
        if (root == null)
            throw new IllegalArgumentException(&amp;quot;Illeagal Input!&amp;quot;);
        
        if (root.left == null &amp;amp;&amp;amp; root.right == null)
            return secMin;
        
        if (root.left.val == root.val) {
            secMin = Math.min(secMin, root.right.val);
            return getSecMin(root.left);
        } else {
            secMin = Math.min(secMin, root.left.val);
            return getSecMin(root.right);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Valid Number</title>
      <link>http://xmruibi.github.io/2015/11/13/valid-number/</link>
      <pubDate>Fri, 13 Nov 2015 16:13:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/valid-number/</guid>
      <description>

&lt;p&gt;Validate if a given string is numeric.&lt;/p&gt;

&lt;h3 id=&#34;example:d0ba9336933b8515213de1bc6935949b&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot; 0.1 &amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;1 a&amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;2e10&amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think:d0ba9336933b8515213de1bc6935949b&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This question focus on thinking about all of corner case

&lt;ol&gt;
&lt;li&gt;sign before the number (one sign; two sign)&lt;/li&gt;
&lt;li&gt;space before the number&lt;/li&gt;
&lt;li&gt;invalid character before / after the number&lt;/li&gt;
&lt;li&gt;&amp;lsquo;e&amp;rsquo; or &amp;lsquo;E&amp;rsquo; in the middle of number&lt;/li&gt;
&lt;li&gt;space after the number&lt;/li&gt;
&lt;li&gt;decimal checker&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:d0ba9336933b8515213de1bc6935949b&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public boolean isNumber(String s) {
		if(s == null)
			return false;
        boolean eFlagAllow = true; // switcher for &#39;e&#39; or &#39;E&#39;
        boolean decimal = true; // switcher for &#39;.&#39;
        boolean hasNum = false; // make sure it contains number
        int cursor = 0;
        // skip previous space.
        while(cursor &amp;lt; s.length() &amp;amp;&amp;amp; s.charAt(cursor) == &#39; &#39;)
            cursor++;
            
        // check the sign, only one position allow for &#39;-&#39;
        if(cursor &amp;lt; s.length() &amp;amp;&amp;amp; s.charAt(cursor) == &#39;-&#39;)
            cursor++;
            
        while(cursor &amp;lt; s.length()) {
            char cur = s.charAt(cursor);
            // if has number 
            if(cur &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; cur &amp;lt;= &#39;9&#39;){
                if(!hasNum)
                    hasNum = true;
            }else if((cur == &#39;e&#39; || cur == &#39;E&#39;) &amp;amp;&amp;amp; eFlagAllow &amp;amp;&amp;amp; hasNum) { 
                // previous position should contain the number first 
                eFlagAllow = false; // turn off the e/E switcher
            }else if(cur == &#39;.&#39; &amp;amp;&amp;amp; decimal) {
                // turn off the decimal switcher
                decimal = false;
            }else if(cur != &#39; &#39;) // not allow the char except the space
                return false;
            cursor ++;
        }
        
        return cursor == s.length() &amp;amp;&amp;amp; hasNum;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Nested List</title>
      <link>http://xmruibi.github.io/2015/11/13/nested-list/</link>
      <pubDate>Fri, 13 Nov 2015 13:13:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/nested-list/</guid>
      <description>

&lt;p&gt;Given a nested list of integers, returns the sum of all integers in the list weighted by their depth.&lt;/p&gt;

&lt;h3 id=&#34;partial-code:cd5432d5a5299bdbe44a28444996274a&#34;&gt;Partial Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 
 * This is the interface that represents nested lists. 
 * You should not implement it, or speculate about its implementation. 
 */ 
public interface NestedInteger { 
    // Returns true if this NestedInteger holds a single integer, rather than a nested list 
    public boolean isInteger(); 

    // Returns the single integer that this NestedInteger holds, if it holds a single integer 
    // Returns null if this NestedInteger holds a nested list 
    public Integer getInteger(); 

    // Returns the nested list that this NestedInteger holds, if it holds a nested list 
    // Returns null if this NestedInteger holds a single integer 
    public List getList(); 
}

public class Solution {
	public int depthSum(List&amp;lt;NestedInteger&amp;gt; input) {
        //Implement this function
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;example:cd5432d5a5299bdbe44a28444996274a&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given the list &lt;code&gt;{{1,1},2,{1,1}}&lt;/code&gt; the function should return &lt;code&gt;10&lt;/code&gt; (four 1&amp;rsquo;s at depth 2, one 2 at depth 1);
Given the list &lt;code&gt;{1,{4,{6}}}&lt;/code&gt; the function should return &lt;code&gt;27&lt;/code&gt; (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3);&lt;/p&gt;

&lt;h2 id=&#34;think:cd5432d5a5299bdbe44a28444996274a&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Recursion with DFS&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:cd5432d5a5299bdbe44a28444996274a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
	public int depthSum(List&amp;lt;NestedInteger&amp;gt; input) {
		return dfsHelper(input, 1);
    }

    private int dfsHelper(List&amp;lt;NestedInteger&amp;gt; input, int depth) {
    	int sum = 0;
    	for(NestedInteger cur : input) {
    		if(cur.isInteger())
    			sum += (cur.getInteger() * depth);
    		else
    			sum += dfsHelper(cur.getList(), depth + 1);
    	}
    	return sum;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;followup-1:cd5432d5a5299bdbe44a28444996274a&#34;&gt;Followup #1&lt;/h2&gt;

&lt;p&gt;Get the sum by reversed level.&lt;/p&gt;

&lt;h4 id=&#34;think-1:cd5432d5a5299bdbe44a28444996274a&#34;&gt;Think&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Should get depth at first and then recursively reduce the depth for DFS&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public static int reversedDepthSum(List&amp;lt;NestedInteger&amp;gt; input) {
		int depth = getDepth(input);
		return dfsReverseHelper(input, depth);
	}

	private static int dfsReverseHelper(List&amp;lt;NestedInteger&amp;gt; input, int depth) {
		int sum = 0;
		for (NestedInteger cur : input) {
			if (cur.isInteger())
				sum += (cur.getInteger() * depth);
			else
				sum += dfsReverseHelper(cur.getList(), depth - 1);
		}
		return sum;
	}
	
	private static int getDepth(List&amp;lt;NestedInteger&amp;gt; input) {
		int depth = 0;
		for (NestedInteger cur : input) {
			if (!cur.isInteger())
				depth = Math.max(depth, getDepth(cur.getList()));
		}
		return depth + 1;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;followup-2:cd5432d5a5299bdbe44a28444996274a&#34;&gt;Followup #2&lt;/h2&gt;

&lt;p&gt;Implement the Nested Integer interface&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class NestedIntImpl implements NestedInteger {
	Object obj;

	public NestedIntegerImpl(Object obj) {
		this.obj = obj;
	}

	@Override
	public boolean isInteger() {	
		return obj instanceof Integer;
	}

	@Override
	public Integer getInteger() {
		if(obj instanceof Integer)
			return (Integer)obj;
		return null;
	}

	@Override
	public List&amp;lt;NestedInteger&amp;gt; getList() {
		if(obj instanceof List)
			return (List&amp;lt;NestedInteger&amp;gt;)obj;
		return null;
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Braces Check</title>
      <link>http://xmruibi.github.io/2015/11/13/braces-check/</link>
      <pubDate>Fri, 13 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/braces-check/</guid>
      <description>

&lt;p&gt;Design a function determines if the braces (&amp;lsquo;(&amp;rsquo; and &amp;lsquo;)&amp;rsquo;) in a string are properly matched. Please ignores non-brace characters.&lt;/p&gt;

&lt;h3 id=&#34;examples:39c9785383d6c2c463872fe27d7b000d&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;quot;()()()()&amp;quot;&lt;/code&gt;   -&amp;gt; &lt;code&gt;true&lt;/code&gt;
&lt;code&gt;&amp;quot;((45+)*a3)&amp;quot;&lt;/code&gt; -&amp;gt; &lt;code&gt;true&lt;/code&gt;
&lt;code&gt;&amp;quot;(((())())&amp;quot;&lt;/code&gt;  -&amp;gt; &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think:39c9785383d6c2c463872fe27d7b000d&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Parenthese check problem three way to solve.

&lt;ul&gt;
&lt;li&gt;If it only contains one kind of parenthese, it can just use a counter.&lt;/li&gt;
&lt;li&gt;Stack solution with hashmap assistance&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:39c9785383d6c2c463872fe27d7b000d&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    // counter method
    public boolean matched(String s) {
        if(s == null || s.length() == 0)
            return true;
        int cnt = 0;
        int idx = 0;
        while(idx &amp;lt; s.length()) {
            if(s.charAt(idx) == &#39;(&#39;)
                cnt++;
            else if(s.charAt(idx) == &#39;)&#39;) {
                if(cnt &amp;lt;= 0) 
                    return false;
                cnt--;
            }
        }
        return cnt == 0;
    }

    // 
    public boolean matchedII(String s) {
        if(s == null || s.length() == 0)
            return true;
        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        HashMap&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&#39;(&#39;, &#39;)&#39;); map.put(&#39;{&#39;, &#39;}&#39;); map.put(&#39;[&#39;, &#39;]&#39;);
        int idx = 0;
        while(idx &amp;lt; s.length()) {
            char c = s.charAt(idx);
            if(map.containsKey(c))
                stack.push(c);
            else if(map.values().contains(c)){
                if(!stack.isEmpty() &amp;amp;&amp;amp; map.get(stack.pop()) != c)
                    return false;
            }
        }
        return stack.isEmpty()
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Expression Add Operators</title>
      <link>http://xmruibi.github.io/2015/11/12/expression-add-operators/</link>
      <pubDate>Thu, 12 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/12/expression-add-operators/</guid>
      <description>

&lt;p&gt;Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.&lt;/p&gt;

&lt;h3 id=&#34;examples:b80d8eb4c261a28dea46a3fd4834483e&#34;&gt;Examples&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;123&amp;quot;, 6 -&amp;gt; [&amp;quot;1+2+3&amp;quot;, &amp;quot;1*2*3&amp;quot;] 
&amp;quot;232&amp;quot;, 8 -&amp;gt; [&amp;quot;2*3+2&amp;quot;, &amp;quot;2+3*2&amp;quot;]
&amp;quot;105&amp;quot;, 5 -&amp;gt; [&amp;quot;1*0+5&amp;quot;,&amp;quot;10-5&amp;quot;]
&amp;quot;00&amp;quot;, 0 -&amp;gt; [&amp;quot;0+0&amp;quot;, &amp;quot;0-0&amp;quot;, &amp;quot;0*0&amp;quot;]
&amp;quot;3456237490&amp;quot;, 9191 -&amp;gt; []
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:b80d8eb4c261a28dea46a3fd4834483e&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;This problem has a lot of edge cases to be considered:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;overflow: we use a long type once it is larger than Integer.MAX_VALUE or minimum, we get over it.&lt;/li&gt;
&lt;li&gt;0 sequence: because we can&amp;rsquo;t have numbers with multiple digits started with zero, we have to deal with it too.&lt;/li&gt;
&lt;li&gt;a little trick is that we should save the value that is to be multiplied in the next recursion.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;solution:b80d8eb4c261a28dea46a3fd4834483e&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {

    public List&amp;lt;String&amp;gt; addOperators(String num, int target) {
        List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        helper(res, &amp;quot;&amp;quot;, num, 0, target, 0L, 0L);
        return res;
    }
    
    private void helper(List&amp;lt;String&amp;gt; res, String cur, String num, int idx, int target, long preVal, long nextVal) {
       if(idx == num.length()) {
            if(preVal == target)
                res.add(new String(cur));
            return;
       }
       
       for(int i = idx; i &amp;lt; num.length(); i++) {
           if(i != idx &amp;amp;&amp;amp; num.charAt(idx) == &#39;0&#39;) break;
           String sbstr = num.substring(idx, i+1);
           long curVal = Long.parseLong(sbstr);
           if(idx == 0)
                helper(res, sbstr, num, i+1, target, curVal, curVal);
           else {
               helper(res, cur + &amp;quot;+&amp;quot; + curVal, num, i+1, target, preVal + curVal,  curVal);
               helper(res, cur + &amp;quot;-&amp;quot; + curVal, num, i+1, target, preVal - curVal, 0 - curVal);
               helper(res, cur + &amp;quot;*&amp;quot; + curVal, num, i+1, target, preVal - nextVal + nextVal * curVal, nextVal * curVal);
           }
       }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find the Celebrity</title>
      <link>http://xmruibi.github.io/2015/11/12/find-the-celebrity/</link>
      <pubDate>Thu, 12 Nov 2015 12:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/12/find-the-celebrity/</guid>
      <description>

&lt;p&gt;Suppose you are at a party with &lt;code&gt;n&lt;/code&gt; people (labeled from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n - 1&lt;/code&gt;) and among them, there may exist one celebrity. The definition of a celebrity is that all the other &lt;code&gt;n - 1&lt;/code&gt; people know him/her but &lt;strong&gt;he/she does not know any of them&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: &amp;ldquo;Hi, A. Do you know B?&amp;rdquo; to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).&lt;/p&gt;

&lt;p&gt;You are given a helper function &lt;code&gt;bool knows(a, b)&lt;/code&gt; which tells you whether A knows B. Implement a function &lt;code&gt;int findCelebrity(n)&lt;/code&gt;, your function should minimize the number of calls to &lt;code&gt;knows&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note:987915e63763fb778a6682d4a9f26f85&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;There will be exactly one celebrity if he/she is in the party. Return the celebrity&amp;rsquo;s label if there is a celebrity in the party. If there is no celebrity, return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think-1:987915e63763fb778a6682d4a9f26f85&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Based graph, check the node with &lt;code&gt;n-1&lt;/code&gt; in-degree and &lt;code&gt;0&lt;/code&gt; out-degree.&lt;/li&gt;
&lt;li&gt;Becuase other &lt;code&gt;n - 1&lt;/code&gt; people know him/her but &lt;strong&gt;he/she does not know any of them&lt;/strong&gt; (&lt;code&gt;0&lt;/code&gt; out-degree)&lt;/li&gt;
&lt;li&gt;Call times: $$O(n^2)$$&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:987915e63763fb778a6682d4a9f26f85&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public int findCelebrity(int n) {
		if (n &amp;lt;= 1)
			return -1;

		int[] inDegree = new int[n];
		int[] outDegree = new int[n];

		// call n^2 times
		for (int i = 0; i &amp;lt; n; i++) {
			for (int j = 0; j &amp;lt; n; j++) {
				if (i != j &amp;amp;&amp;amp; knows(i, j)) {
					outDegree[i]++;
					inDegree[j]++;
				}
			}
		}

		for (int i = 0; i &amp;lt; n; i++) {
			if (inDegree[i] == n - 1 &amp;amp;&amp;amp; outDegree[i] == 0) {
				return i;
			}
		}

		return -1;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2:987915e63763fb778a6682d4a9f26f85&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Iterations from head and rear to the middle(l -&amp;gt; m &amp;lt;- r).&lt;/li&gt;
&lt;li&gt;Two cases when check if [l] knows [r].

&lt;ul&gt;
&lt;li&gt;Left shouldn&amp;rsquo;t be celebrity since he knows someone.&lt;/li&gt;
&lt;li&gt;Right shouldn&amp;rsquo;t be celebrity because one of people doesn&amp;rsquo;t know him.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2:987915e63763fb778a6682d4a9f26f85&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public int findCelebrityII(int n) {
		if (n &amp;lt;= 1)
			return -1;
		
		int left = 0, right = n - 1;
		while (left &amp;lt; right) {
			if (knows(left, right))
				left++; // left shouldn&#39;t be celebrity since he knows someone
			else
				right--; // right shouldn&#39;t be celebrity because one of people doesn&#39;t know him
		}

		// check the potential candidate is celebrity
		for (int i = 0; i &amp;lt; n; i++) {
			if (i == right)
				continue;
			if (knows(right, i))
				return -1;
		}
		return right;
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>