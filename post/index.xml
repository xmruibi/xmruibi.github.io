<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Geek Think</title>
    <link>http://xmruibi.github.io/post/</link>
    <description>Recent content in Posts on Geek Think</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Sat, 14 Nov 2015 22:43:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Balanced Point in Array</title>
      <link>http://xmruibi.github.io/2015/11/14/balanced-point-in-array/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/balanced-point-in-array/</guid>
      <description>

&lt;p&gt;Balanced index of an array is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes.&lt;/p&gt;

&lt;h3 id=&#34;example:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;In an arrya A:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A[0] = -7, A[1] = 1, A[2] = 5, A[3] = 2, A[4] = -4, A[5] = 3, A[6]=0
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;3&lt;/code&gt; is an Balanced index, because: &lt;code&gt;A[0] + A[1] + A[2] = A[4] + A[5] + A[6]&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;6&lt;/code&gt; is also an Balanced index, because sum of zero elements is zero, i.e., &lt;code&gt;A[0] + A[1] + A[2] + A[3] + A[4] + A[5]=0&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;7&lt;/code&gt; is not an Balanced index, because it is not a valid index of array A.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Write a function int &lt;code&gt;balancedPoint(int[] arr)&lt;/code&gt;; that given a sequence arr[] of size n, returns an Balanced index (if any) or -1 if no Balanced indexes exist.&lt;/p&gt;

&lt;h2 id=&#34;think:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;The idea is to get total sum of array first. Then Iterate through the array and keep updating the left sum which is initialized as zero. In the loop, we can get right sum by subtracting the elements one by one.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1) Initialize leftsum  as 0
2) Get the total sum of the array as sum
3) Iterate through the array and for each index i, do following.
    a)  Update sum to get the right sum.  
           sum = sum - arr[i] 
       // sum is now right sum
    b) If leftsum is equal to sum, then return current index. 
    c) leftsum = leftsum + arr[i] // update leftsum for next iteration.
4) return -1 // If we come out of loop without returning then
             // there is no equilibrium index
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:4e2c86d4518587f1b252aab20ac5c10d&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	// find all balance point in an array return balanced index
	public List&amp;lt;Integer&amp;gt; findBalancedPoint(int[] arr) {
		int leftsum = 0, rightsum = 0;
		List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();

		for (int i = 0; i &amp;lt; arr.length; i++) 
			leftsum += arr[i];
		
		for (int i = arr.length - 1; i&amp;gt;=0; i--) {
			leftsum -= arr[i];
			if(leftsum == rightsum)
				res.add(i);
			rightsum+=arr[i];
		}
		return -1;
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find Valid IP Address in a File</title>
      <link>http://xmruibi.github.io/2015/11/14/find-valid-ip-address-in-a-file/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/find-valid-ip-address-in-a-file/</guid>
      <description>

&lt;p&gt;Given a file with many lines of Strings, find those valid IP address from them.&lt;/p&gt;

&lt;h2 id=&#34;solution:ed817a74e0c3a1097fc0cfb76d5d85e1&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ValidIPAddress {

    public List&amp;lt;String&amp;gt; findValidIPAddr(String filePath) throws IOException {
        List&amp;lt;String&amp;gt; addresses = new ArrayList&amp;lt;&amp;gt;();
        Scanner sc = new Scanner(new File(filePath));
        while (sc.hasNext()) {
            String line = sc.next();
            if(validIP(line))
                addresses.add(line);
        }
        return addresses;
    }

    private boolean validIP(String str) {
        try {
            String[] parts = str.split(&amp;quot;.&amp;quot;);
            // check segment length;
            if (parts.length != 4 || str.endsWith(&amp;quot;.&amp;quot;))
                return false;

            // check each segment valid or not
            for (int i = 0; i &amp;lt; parts.length; i++) {
                String s = parts[i];
                int val = Integer.parseInt(s);
                if ((s.charAt(0) == &#39;0&#39;) || (val &amp;lt; 0 || val &amp;gt; 255)
                        || (i == 0 &amp;amp;&amp;amp; val == 0))
                    return false;
            }
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Isomorphic Pair</title>
      <link>http://xmruibi.github.io/2015/11/14/isomorphic-pair/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/isomorphic-pair/</guid>
      <description>

&lt;p&gt;Given two words as Strings, determine if they are isomorphic. Two words are called isomorphic if the letters in one word can be remapped to get the second word. Remapping a letter means replacing all occurrences of it with another letter while the ordering of the letters remains unchanged. No two letters may map to the same letter, but a letter may map to itself.&lt;/p&gt;

&lt;h2 id=&#34;think-1:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Two Hashmap for mapping A-B and B-A.&lt;/li&gt;
&lt;li&gt;make sure both mapping are correct if any character appear in its corresponding mapping.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public boolean isomorphicString(String str1, String str2) {
		if (str1 == null || str2 == null || str1.length() != str2.length())
			return false;
		HashMap&amp;lt;Character, Character&amp;gt; mapAB = new HashMap&amp;lt;&amp;gt;();
		HashMap&amp;lt;Character, Character&amp;gt; mapBA = new HashMap&amp;lt;&amp;gt;();
		for (int i = 0; i &amp;lt; str1.length(); i++) {
			char a = str1.charAt(i);
			char b = str2.charAt(i);
			if (!mapAB.containsKey(a) &amp;amp;&amp;amp; !mapBA.containsKey(b)) {
				mapAB.put(a, b);
				mapBA.put(b, a);
			} else {
				if (mapAB.containsKey(a) &amp;amp;&amp;amp; mapAB.get(a) != b)
					return false;
				if (mapBA.containsKey(b) &amp;amp;&amp;amp; mapBA.get(b) != a)
					return false;
			}
		}
		return true;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;One Hashmap&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public boolean isomorphicStringII(String str1, String str2) {
		if ((str1 == null &amp;amp;&amp;amp; str2 == null)
				|| (str1.length() == 0 &amp;amp;&amp;amp; str2.length() == 0)
				|| str1.equals(str2))
			return true;
		if (str1 == null || str2 == null || str1.length() != str2.length())
			return false;
		HashMap&amp;lt;Character, Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
		int i = 0;
		while (i &amp;lt; str1.length()) {
			char a = str1.charAt(i);
			char b = str2.charAt(i);
			if (map.containsKey(a)) {
				if (map.get(a) != b)
					return false;
			} else {
				if (map.containsValue(b))
					return false;
				map.put(a, b);
			}
			i++;
		}
		return true;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-3:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Think #3&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Integer Array with 512 length&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-3:7ab6663e72843fc1770a695321dc7d8b&#34;&gt;Solution #3&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public boolean isIsomorphic(String s1, String s2) {
        int[] m = new int[512];
        for (int i = 0; i &amp;lt; s1.length(); i++) {
            if (m[s1.charAt(i)] != m[s2.charAt(i)+256]) 
                return false;
            m[s1.charAt(i)] = m[s2.charAt(i)+256] = i+1;
        }
        return true;	
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Maximum Subarray of Sum / Product</title>
      <link>http://xmruibi.github.io/2015/11/14/maximum-subarray-of-sum-/-product/</link>
      <pubDate>Sat, 14 Nov 2015 22:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/maximum-subarray-of-sum-/-product/</guid>
      <description>

&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest sum.&lt;/p&gt;

&lt;p&gt;For example, given the array &lt;code&gt;[−2,1,−3,4,−1,2,1,−5,4]&lt;/code&gt;,
the contiguous subarray &lt;code&gt;[4,−1,2,1]&lt;/code&gt; has the largest sum = &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int maxSubArray(int[] arr) {
        int maxSum = Integer.MIN_VALUE;
		int curSum = 0;
		for (int i = 0; i &amp;lt; arr.length; i++) {
			curSum += arr[i];
			maxSum = Math.max(maxSum, curSum);
			if (curSum &amp;lt; 0)
				curSum = 0;
		}
		return maxSum;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-record-index:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution #Record Index&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int[] maxSubArray(int[] arr) {
        int maxSum = Integer.MIN_VALUE;
		int curSum = 0;
		int prev = 0, l = 0, r = 0;
		for (int i = 0; i &amp;lt; arr.length; i++) {
			curSum += arr[i];
			if(curSum &amp;gt; maxSum) {
				maxSum = curSum;
				l = prev;
				r = i;
			}
			if (curSum &amp;lt; 0) {
				curSum = 0;
				prev = i + 1;
			}
		}
		return new int[]{l, r};
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest product.&lt;/p&gt;

&lt;p&gt;For example, given the array &lt;code&gt;[2,3,-2,4]&lt;/code&gt;,
the contiguous subarray &lt;code&gt;[2,3]&lt;/code&gt; has the largest product = &lt;code&gt;6&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution-1:f78387a942b57f331cbfb70191f2872a&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int maxProduct(int[] nums) {
        int glMax = Integer.MIN_VALUE;
        
        int localMin = 1; // record the current max
        int localMax = 1; // record the current min, since the negative number multiply with current number may leads to next product as the positive max
        for(int i = 0; i &amp;lt; nums.length; i++) {
            int tmp = localMax;
            localMax = Math.max(localMax*nums[i], Math.max(localMin*nums[i], nums[i]));
            localMin = Math.min(tmp*nums[i], Math.min(localMin*nums[i], nums[i]));
            glMax = Math.max(glMax, localMax);
        }
        
        return glMax;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Binary Tree Upside Down</title>
      <link>http://xmruibi.github.io/2015/11/14/binary-tree-upside-down/</link>
      <pubDate>Sat, 14 Nov 2015 15:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/binary-tree-upside-down/</guid>
      <description>

&lt;p&gt;Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root.&lt;/p&gt;

&lt;h3 id=&#34;example:33643332a2ae687d0e663b807ba8b06f&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given a binary tree &lt;code&gt;{1,2,3,4,5}&lt;/code&gt;,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     1
    / \
   2   3
  / \
 4   5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return the root of the binary tree &lt;code&gt;[4,5,2,#,#,3,1]&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     4
    / \
   5   2
      / \
     3   1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think:33643332a2ae687d0e663b807ba8b06f&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Mark the parent node &lt;code&gt;parent&lt;/code&gt; from next right node position.&lt;/li&gt;
&lt;li&gt;Mark the current right child &lt;code&gt;node.right&lt;/code&gt; from next left &lt;code&gt;left&lt;/code&gt; node position&lt;/li&gt;
&lt;li&gt;Mark the next iteration node &lt;code&gt;next&lt;/code&gt; by current left child &lt;code&gt;node.left&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Replace the current node&amp;rsquo;s left child as the recorded &lt;code&gt;right&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Replace the current node&amp;rsquo;s right child as the recorded &lt;code&gt;parent&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Replace current iteration node by &lt;code&gt;next&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-iterative:33643332a2ae687d0e663b807ba8b06f&#34;&gt;Solution #Iterative&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public TreeNode UpsideDownBinaryTree(TreeNode node) {  
        TreeNode parent = null, right = null;
		while(node != null) {
			TreeNode next = node.left;
			node.left = right;						
			right = node.right;
			node.right = parent;
			parent = node;
			node = next;
		}
		return parent;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-recursive:33643332a2ae687d0e663b807ba8b06f&#34;&gt;Solution #Recursive&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static TreeNode upsideDown(TreeNode node) {
        if(node == null)
            return node;
        TreeNode root = node, left = node.left, right = node.right;
        if(left != null) {
            TreeNode newroot = upsideDown(node.left);
            left.left = right;
            left.right = root;
            return newroot;
        }
        return node;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Course Schedule I/II</title>
      <link>http://xmruibi.github.io/2015/11/14/course-schedule-i/ii/</link>
      <pubDate>Sat, 14 Nov 2015 13:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/course-schedule-i/ii/</guid>
      <description>

&lt;h2 id=&#34;problem-i:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Problem I&lt;/h2&gt;

&lt;p&gt;There are a total of n courses you have to take, labeled from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n - 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: &lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2, [[1,0]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2, [[1,0],[0,1]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.&lt;/p&gt;

&lt;h3 id=&#34;solution-topological-sort:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Solution #Topological Sort&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        HashMap&amp;lt;Integer, Course&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(int[] pair : prerequisites) {
            int pre = pair[1];
            int cur = pair[0];
            if(!map.containsKey(pre))
                map.put(pre, new Course(pre));
            if(!map.containsKey(cur))
                map.put(cur, new Course(cur));
            map.get(pre).nexts.add(map.get(cur));
            map.get(cur).preq++;
        }
        Queue&amp;lt;Course&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
        for(Course c : map.values()) {
            if(c.preq == 0)
                queue.offer(c);
        }
        
        while(!queue.isEmpty()) {
            Course cur = queue.poll();
            map.remove(cur.idx);
            for(Course next : cur.nexts) {
                next.preq--;
                if(next.preq == 0)
                    queue.offer(next);
            }
        }
        return map.size() == 0;
    }
}
class Course{
    int idx;
    int preq;
    ArrayList&amp;lt;Course&amp;gt; nexts;
    public Course(int index) {
        this.idx = index;
        this.preq = 0;
        this.nexts = new ArrayList&amp;lt;&amp;gt;();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;problem-ii:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Problem II&lt;/h2&gt;

&lt;p&gt;Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.&lt;/p&gt;

&lt;p&gt;There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.&lt;/p&gt;

&lt;h4 id=&#34;example:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Example&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;2, [[1,0]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a total of 2 courses to take. To take course &lt;code&gt;1&lt;/code&gt; you should have finished course &lt;code&gt;0&lt;/code&gt;. So the correct course order is &lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;4, [[1,0],[2,0],[3,1],[3,2]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a total of 4 courses to take. To take course &lt;code&gt;3&lt;/code&gt; you should have finished both courses &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;. Both courses &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; should be taken after you finished course 0. So one correct course order is &lt;code&gt;[0,1,2,3]&lt;/code&gt;. Another correct ordering is &lt;code&gt;[0,2,1,3]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;solution-topological-sort-1:cc6cec0f55bbe04713d85b21b1b7c478&#34;&gt;Solution #Topological Sort&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        if(prerequisites == null || prerequisites.length == 0)
            return new int[0];
            
        HashMap&amp;lt;Integer, Course&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(int[] pair : prerequisites) {
            int pre = pair[1];
            int cur = pair[0];
            if(!map.containsKey(pre))
                map.put(pre, new Course(pre));
            if(!map.containsKey(cur))
                map.put(cur, new Course(cur));
            map.get(pre).nexts.add(map.get(cur));
            map.get(cur).preq++;
        }
        Queue&amp;lt;Course&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
        for(Course c : map.values()) {
            if(c.preq == 0)
                queue.offer(c);
        }
        int[] res = new int[numCourses];
        int index = 0;
        while(!queue.isEmpty()) {
            Course cur = queue.poll();
            res[index++] = cur.idx;
            map.remove(cur.idx);
            for(Course next : cur.nexts) {
                next.preq--;
                if(next.preq == 0)
                    queue.offer(next);
            }
        }
        return map.size() == 0 ? res : new int[0];
    }
}
class Course{
    int idx;
    int preq;
    ArrayList&amp;lt;Course&amp;gt; nexts;
    public Course(int index) {
        this.idx = index;
        this.preq = 0;
        this.nexts = new ArrayList&amp;lt;&amp;gt;();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Repeated DNA Sequences</title>
      <link>http://xmruibi.github.io/2015/11/14/repeated-dna-sequences/</link>
      <pubDate>Sat, 14 Nov 2015 13:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/repeated-dna-sequences/</guid>
      <description>

&lt;p&gt;All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: &amp;ldquo;ACGAATTCCG&amp;rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.&lt;/p&gt;

&lt;p&gt;Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.&lt;/p&gt;

&lt;h3 id=&#34;example:86c36611807a867e11fbbb9582b6e9b6&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;s&lt;/code&gt; = &lt;code&gt;&amp;quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&amp;quot;&lt;/code&gt;, Return:  &lt;code&gt;[&amp;quot;AAAAACCCCC&amp;quot;, &amp;quot;CCCCCAAAAA&amp;quot;]&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think-rolling-hash:86c36611807a867e11fbbb9582b6e9b6&#34;&gt;Think #Rolling Hash&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The idea based on the rolling hash, we store each segment as a hash code.&lt;/li&gt;
&lt;li&gt;If the segment repeated, its hashcode should be the same.&lt;/li&gt;
&lt;li&gt;Iterate through the input String, find each segment and its hashcode.&lt;/li&gt;
&lt;li&gt;Check the index map where has a index list more than one size.&lt;/li&gt;
&lt;li&gt;Just record a substring by the index bound from &lt;code&gt;list.get(0)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;O(n) time complexity&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-rolling-hash:86c36611807a867e11fbbb9582b6e9b6&#34;&gt;Solution #Rolling Hash&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public List&amp;lt;String&amp;gt; findRepeatedDnaSequences(String s) {
        Set&amp;lt;String&amp;gt; res = new HashSet&amp;lt;&amp;gt;();
        if(s==null||s.length()==0)
            return new ArrayList(res);
        Map&amp;lt;Character, Integer&amp;gt; dict = new HashMap&amp;lt;&amp;gt;();
        dict.put(&#39;A&#39;,0); dict.put(&#39;C&#39;,1); dict.put(&#39;G&#39;,2); dict.put(&#39;T&#39;,3);
       //int A_SIZE_POW_9 = (int) Math.pow(dict.size(), 9);
        Set&amp;lt;Integer&amp;gt; hashCodes = new HashSet&amp;lt;&amp;gt;();
        int hashCode = 0;
        for(int i=0;i&amp;lt;s.length();i++){
            if(i&amp;gt;9) // remove first 
                hashCode -= Math.pow(4,9)*dict.get(s.charAt(i-10));
            hashCode = 4*hashCode + dict.get(s.charAt(i));
            if(i&amp;gt;8&amp;amp;&amp;amp;!hashCodes.add(hashCode)) // set add operation return true
                res.add(s.substring(i-9,i+1));
        }
        return new ArrayList(res);
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Can I Win</title>
      <link>http://xmruibi.github.io/2015/11/14/can-i-win/</link>
      <pubDate>Sat, 14 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/can-i-win/</guid>
      <description>

&lt;p&gt;Given an array of positive integers and two players. In each turn, one player picks up one number and if the sum of all the picked up numbers is greater than a target number, the player wins. Write a program &lt;code&gt;canIWin()&lt;/code&gt; to print the result.&lt;/p&gt;

&lt;h2 id=&#34;think:20042e86952d9768f73636e75bf69c3b&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This question is pretty tricky.&lt;/li&gt;
&lt;li&gt;It&amp;rsquo;s not just choose the largest number in number pool. Instead of, for each turn, player has two choice:

&lt;ul&gt;
&lt;li&gt;If current pool has number can just make the sum larger than target, pick that number&lt;/li&gt;
&lt;li&gt;If not number can added to make the sum exceed target, try to make current pick with the minimum number from the pool.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:20042e86952d9768f73636e75bf69c3b&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;        public static Result canIWin(int[] nums, int target) {
                if (target &amp;lt;= 0)
                        return Result.Lose;
                // first iterate - find any number larger than remain target, or check
                // all number in pool has taken
                boolean hasNum = false;
                for (int num : nums) {
                        if (num &amp;gt;= target)
                                return Result.Win;
                        else if (num &amp;gt; 0)
                                hasNum = true;
                }
                if (!hasNum)
                        return Result.Draw;
                for (int i = 0; i &amp;lt; nums.length; i++) {
                        if (nums[i] &amp;gt; 0) {
                                int data = nums[i];
                                nums[i] = -1;
                                Result rivalResult = canIWin(nums, target - data);
                                if (rivalResult == Result.Win)
                                        return Result.Lose;
                                if (rivalResult == Result.Lose)
                                        return Result.Win;
                                nums[i] = data;
                        }
                }
                return Result.Draw;
        }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Product of Array Except Self</title>
      <link>http://xmruibi.github.io/2015/11/14/product-of-array-except-self/</link>
      <pubDate>Sat, 14 Nov 2015 10:43:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/product-of-array-except-self/</guid>
      <description>

&lt;p&gt;Given an array of &lt;code&gt;n&lt;/code&gt; integers where &lt;code&gt;n&lt;/code&gt; &amp;gt; 1, nums, return an array output such that &lt;code&gt;output[i]&lt;/code&gt; is equal to the product of all the elements of nums except &lt;code&gt;nums[i]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Solve it &lt;strong&gt;without division&lt;/strong&gt; and in &lt;code&gt;O(n)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, given &lt;code&gt;[1,2,3,4]&lt;/code&gt;, return &lt;code&gt;[24,12,8,6]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Follow up:
Could you solve it with constant space complexity? (Note: The &lt;strong&gt;output array does not count&lt;/strong&gt; as extra space for the purpose of space complexity analysis.)&lt;/p&gt;

&lt;h2 id=&#34;think-1:475ac2d302270bdb12a33bec7e726fb7&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;$$O(n)$$ Space and Two pass, recording the left part or right part product.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:475ac2d302270bdb12a33bec7e726fb7&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public int[] productExceptSelf(int[] input) {
        int[] res = new int[input.length];
        int tmp = 1;
        for (int i = 0; i &amp;lt; input.length; i++) {
            res[i] = tmp;
            tmp *= input[i];
        }
        tmp = 1;
        for (int i = input.length - 1; i &amp;gt;= 0; i--) {
            res[i] *= tmp;
            tmp *= input[i];
        }
        return res;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Constant Time Random Picker</title>
      <link>http://xmruibi.github.io/2015/11/14/constant-time-random-picker/</link>
      <pubDate>Sat, 14 Nov 2015 00:30:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/constant-time-random-picker/</guid>
      <description>

&lt;p&gt;Design a data structure that supports insert, delete, search and getRandom in constant time.&lt;/p&gt;

&lt;p&gt;Design a data structure that supports following operations in Θ(1) time.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;insert(x)&lt;/code&gt;: Inserts an item x to the data structure if not already present.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove(x)&lt;/code&gt;: Removes an item x from the data structure if present.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;search(x)&lt;/code&gt;: Searches an item x in the data structure.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getRandom()&lt;/code&gt;: Returns a random element from current set of elements&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;think:fbe9fdf4f7686b0780359874c12ae63a&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;We can use hashing to support first 3 operations in Θ(1) time. How to do the 4th operation? The idea is to use a resizable array (ArrayList in Java, vector in C) together with hashing. Resizable arrays support insert in Θ(1) amortized time complexity. To implement getRandom(), we can simply pick a random number from 0 to size-1 (size is number of current elements) and return the element at that index. The hash map stores array values as keys and array indexes as values.&lt;/p&gt;

&lt;p&gt;Following are detailed operations.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;insert(x)&lt;/li&gt;
&lt;li&gt;Check if x is already present by doing a hash map lookup.&lt;/li&gt;
&lt;li&gt;If not present, then insert it at the end of the array.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Add in hash table also, x is added as key and last array index as index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;remove(x)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check if x is present by doing a hash map lookup.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If present, then find its index and remove it from hash map.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swap the last element with this element in array and remove the last element.
Swapping is done because the last element can be removed in O(1) time.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Update index of last element in hash map.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getRandom()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Generate a random number from 0 to last index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Return the array element at the randomly generated index.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;search(x)
Do a lookup for x in hash map.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:fbe9fdf4f7686b0780359874c12ae63a&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ConstantTimeRandomPicker {
	
	private final ArrayList&amp;lt;Integer&amp;gt; arr;
	private final HashMap&amp;lt;Integer, Integer&amp;gt; map; // value - index
    Random r;
	
	public ConstantTimeRandomPicker() {
		this.arr = new ArrayList&amp;lt;Integer&amp;gt;();
		this.map = new HashMap&amp;lt;Integer, Integer&amp;gt;();
	}
	
	public void add(int val) {
		arr.add(val);
		map.put(arr.size() - 1, val);
	}
	
	public void remove(int val) {
		remove(map.get(val), val);
	}
	
	public void removeRandom() {
		int val = arr.get(r.nextInt(arr.size()));
		remove(map.get(val), val);
	}
	
	public int getRandom() {
		return arr.get(r.nextInt(arr.size()));
	}
	
	public int search(int val) {
		return arr.get(map.get(val));
	}

	private void remove(int idx, int val) {
		
		// swap with the last element
		int last = arr.get(arr.size() - 1);
		// put the last element to the current index
		arr.set(idx, last);
		// remove the last element
		arr.remove(arr.size() - 1);
				
		// update the last element&#39;s index in hashmap
		map.put(last, idx);		
		// remove the removal value
		map.remove(val);
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Intervals and Covered Length</title>
      <link>http://xmruibi.github.io/2015/11/14/intervals-and-covered-length/</link>
      <pubDate>Sat, 14 Nov 2015 00:30:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/14/intervals-and-covered-length/</guid>
      <description>

&lt;p&gt;Design a structrue can get interval pair and a function which can return the total cover length.&lt;/p&gt;

&lt;h2 id=&#34;partial-code:a398446ee2bc7e4d0eef3e4051fe083f&#34;&gt;Partial Code&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Intervals {

	/**
	 * Adds an interval [from, to] into internal structure.
	 */
	void addInterval(int from, int to);

	/**
	 * Returns a total length covered by intervals. If several intervals
	 * intersect, intersection should be counted only once. Example:
	 *
	 * addInterval(3, 6) addInterval(8, 9) addInterval(1, 5)
	 *
	 * getTotalCoveredLength() -&amp;gt; 6 i.e. [1,5] and [3,6] intersect and give a
	 * total covered interval [1,6] [1,6] and [8,9] don&#39;t intersect so total
	 * covered length is a sum for both intervals, that is 6.
	 *
	 * _________ ___ ____________
	 *
	 * 0 1 2 3 4 5 6 7 8 9 10
	 *
	 */
	int getTotalCoveredLength();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution:a398446ee2bc7e4d0eef3e4051fe083f&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class IntervalProblem implements Intervals {

    private class Interval {
        int from, to;

        public Interval(int from, int to) {
            this.from = from;
            this.to = to;
        }
    }

    List&amp;lt;Interval&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();

    @Override
    public void addInterval(int start, int end) {
        if (list.size() == 0) {
            list.add(new Interval(start, end));
            return;
        }       

        ListIterator&amp;lt;Interval&amp;gt; li = list.listIterator();

        while(li.hasNext()){
            Interval itv = li.next();
            if(start &amp;lt;= itv.to){
                if(end &amp;lt; itv.from){ //newInterval does not overlap with current itv, time to insert
                    li.remove();
                    li.add(new Interval(start, end));
                    li.add(itv);
                    return;
                }
                // still some overlap so compare start &amp;amp; end
                start = Math.min(start, itv.from);
                end = Math.max(end, itv.to);
                li.remove();
            }
        }
        list.add(new Interval(start, end));
    }

    @Override
    public int getTotalCoveredLength() {
        if (list.size() == 0) 
            return 0;
        int sum = 0;
        for (int i = 0; i &amp;lt; list.size(); i++) {
            sum += (list.get(i).to - list.get(i).from);
        }
        return sum;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>K Nearest Points</title>
      <link>http://xmruibi.github.io/2015/11/13/k-nearest-points/</link>
      <pubDate>Fri, 13 Nov 2015 23:50:13 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/k-nearest-points/</guid>
      <description>

&lt;p&gt;Find K nearest Points by given the central point. Complete the class design for Point as implementing Comparable interface.&lt;/p&gt;

&lt;h2 id=&#34;think:8857fa3e9119e0ac4dde82275e35c3e7&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Comparable interface and Max heap&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:8857fa3e9119e0ac4dde82275e35c3e7&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class KNearestPoints {

    // finding k nearest neighbor from the original point using a MAX heap, each
    // time if the dist is less than the MAX we put it into the q.
    public Collection&amp;lt;Point&amp;gt; getClosestPoints(Collection&amp;lt;Point&amp;gt; points, int k) {
        PriorityQueue&amp;lt;Point&amp;gt; queue = new PriorityQueue&amp;lt;Point&amp;gt;(k);
        int i = 0;
        for(Point p:points) {
            if(i &amp;lt; k) {
                queue.add(p);
            }else{
                if(p.compareTo(queue.peek()) &amp;lt; 0) {
                    queue.poll();
                    queue.offer(p);
                }
            }
            i++;
        }
        return queue;
    }
}

class Point implements Comparable&amp;lt;Point&amp;gt; {
    final int x, y;
    final double dist;

    public Point(int x, int y, Point origin) {
        this.x = x;
        this.y = y;
        this.dist = Math.hypot(x - origin.x, y - origin.y);
    }

    @Override
    public int compareTo(Point o) {
        return Double.compare(this.dist, o.dist);
    }

    @Override
    public String toString() {
        return &amp;quot;x: &amp;quot; + x + &amp;quot; y: &amp;quot; + y;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Text File Iterator</title>
      <link>http://xmruibi.github.io/2015/11/13/text-file-iterator/</link>
      <pubDate>Fri, 13 Nov 2015 20:40:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/text-file-iterator/</guid>
      <description>

&lt;p&gt;Implement a (Java) Iterable object that iterates lines one by one from a text file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** A reference to a file. */
public class TextFile implements Iterable&amp;lt;String&amp;gt; {
  public TextFile(String fileName) { 
  	// please implement this
  }
  /** Begin reading the file, line by line. The returned Iterator.next() will return a line. */ 
  @Override
  public Iterator&amp;lt;String&amp;gt; iterator() { 
  	// please implement this
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-1:c8747d864080a32ac128d8a7bbaf43e1&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Keep maintain a BufferedReader&lt;/li&gt;
&lt;li&gt;The tricky part is the hasNext function, we should not use checking &lt;code&gt;br.readline() != null&lt;/code&gt; in this function, since it will cause the line skipping.&lt;/li&gt;
&lt;li&gt;So notice the &lt;code&gt;mark()&lt;/code&gt; and &lt;code&gt;reset()&lt;/code&gt; method in bufferedreader.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1:c8747d864080a32ac128d8a7bbaf43e1&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TextFileIterator implements Iterable&amp;lt;String&amp;gt; {

	private final BufferedReader br;

	public TextFileIterator(String path) throws FileNotFoundException {
		br = new BufferedReader(new InputStreamReader(new FileInputStream(
				new File(path))));

	}

	public Iterator&amp;lt;String&amp;gt; iterator() {
		return new Iterator&amp;lt;String&amp;gt;() {
			@Override
			public boolean hasNext() {
				try {
					br.mark(1);
					if (br.read() &amp;lt; 0) 
						return false;					
					br.reset();
					return true;
				} catch (IOException e) {
					return false;
				}
			}

			@Override
			public String next() {
				try {
					return br.readLine();
				} catch (IOException e) {
					return null;
				}
			}
		};
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2:c8747d864080a32ac128d8a7bbaf43e1&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Scanner&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2:c8747d864080a32ac128d8a7bbaf43e1&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TextFileIterator implements Iterable&amp;lt;String&amp;gt; {

	private final Scanner sc;
	
	public TextFileIterator(String path) throws FileNotFoundException {
			sc = new Scanner(new File(path));
	}

	public Iterator&amp;lt;String&amp;gt; iterator() {
		return new Iterator&amp;lt;String&amp;gt;() {
			@Override
			public boolean hasNext() {
				return sc.hasNext();
			}

			@Override
			public String next() {
				return sc.nextLine();
			}
		};
	}
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Zigzag Iterator</title>
      <link>http://xmruibi.github.io/2015/11/13/zigzag-iterator/</link>
      <pubDate>Fri, 13 Nov 2015 20:40:29 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/zigzag-iterator/</guid>
      <description>

&lt;p&gt;Given two 1d vectors, implement an iterator to return their elements alternately.&lt;/p&gt;

&lt;h3 id=&#34;example:c39b4a8138ca1f78be5fe1b3f188b037&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given two 1d vectors:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;v1&lt;/code&gt; = &lt;code&gt;[1, 2]&lt;/code&gt;
&lt;code&gt;v2&lt;/code&gt; = &lt;code&gt;[3, 4, 5, 6]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: &lt;code&gt;[1, 3, 2, 4, 5, 6]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;follow-up:c39b4a8138ca1f78be5fe1b3f188b037&#34;&gt;Follow up&lt;/h3&gt;

&lt;p&gt;What if you are given k 1d vectors? How well can your code be extended to such cases?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reverse a Stack using Recursion</title>
      <link>http://xmruibi.github.io/2015/11/13/reverse-a-stack-using-recursion/</link>
      <pubDate>Fri, 13 Nov 2015 20:39:16 -0700</pubDate>
      
      <guid>http://xmruibi.github.io/2015/11/13/reverse-a-stack-using-recursion/</guid>
      <description>

&lt;p&gt;Reverse a stack using recursion.&lt;/p&gt;

&lt;p&gt;You are not allowed to use loop constructs like while, for..etc, and you can only use the following ADT functions on Stack S:
- &lt;code&gt;isEmpty(S)&lt;/code&gt;
- &lt;code&gt;push(S)&lt;/code&gt;
- &lt;code&gt;pop(S)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think:67652d66ff3aed8bc58d000794c76ecc&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Very very trick problem&lt;/li&gt;
&lt;li&gt;The idea of the solution is to hold all values in Function Call Stack until the stack becomes empty. When the stack becomes empty, insert all held items one by one at the bottom of the stack.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution:67652d66ff3aed8bc58d000794c76ecc&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void recrusion(Stack&amp;lt;Integer&amp;gt; stack) {
        if (stack.isEmpty())
            return;
        int tmp = stack.pop();
        recrusion(stack);
        helper(stack, tmp);
    }

    private static void helper(Stack&amp;lt;Integer&amp;gt; stack, int val) {
        if (stack.isEmpty())
            stack.push(val);
        else {
            int tmp = stack.pop();
            helper(stack, val);
            stack.push(tmp);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>