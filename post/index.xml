<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/post/</link>
    <description>Recent content in Posts on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Tue, 20 Oct 2015 19:13:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Interleaving String</title>
      <link>http://xmruibi.github.io/2015/10/20/interleaving-string/</link>
      <pubDate>Tue, 20 Oct 2015 19:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/interleaving-string/</guid>
      <description>

&lt;p&gt;Given three strings: s1, s2, s3, determine whether s3 is formed by the interleaving of s1 and s2.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For s1 = &lt;code&gt;&amp;quot;aabcc&amp;quot;&lt;/code&gt;, s2 = &lt;code&gt;&amp;quot;dbbca&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;When s3 = &lt;code&gt;&amp;quot;aadbbcbcac&amp;quot;&lt;/code&gt;, return true.
When s3 = &lt;code&gt;&amp;quot;aadbbbaccc&amp;quot;&lt;/code&gt;, return false.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n2) time or better&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Typical dynamic programming with subsequence problem.&lt;/li&gt;
&lt;li&gt;Set up a 2-D dp boolean table to memorized:

&lt;ul&gt;
&lt;li&gt;Initial: memo[0][0] = true;&lt;/li&gt;
&lt;li&gt;two conditions: s1 find matched or s2 find matched;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memo[i][j] = ( i &amp;gt; 0 &amp;amp;&amp;amp; s1.charAt(i - 1) == s3.charAt(i + j - 1) &amp;amp;&amp;amp; memo[i - 1][j]) || (s2.charAt(j - 1) == s3.charAt(i + j - 1) &amp;amp;&amp;amp; memo[i][j - 1])&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * Determine whether s3 is formed by interleaving of s1 and s2.
     * @param s1, s2, s3: As description.
     * @return: true or false.
     */
    public boolean isInterleave(String s1, String s2, String s3) {

        if(s1 == null || s2 == null)
            return false;
        if(s1.length() + s2.length() != s3.length())
            return false;
            
        boolean[][] memo = new boolean[s1.length() + 1][s2.length() + 1];
        for(int i = 0; i &amp;lt;= s1.length(); i++) {
            for(int j = 0; j &amp;lt;= s2.length(); j++) {
                if(i == 0 &amp;amp;&amp;amp; j == 0)
                    memo[i][j] = true;
                else{
                    if(i &amp;gt; 0 &amp;amp;&amp;amp; s1.charAt(i - 1) == s3.charAt(i + j - 1))
                        memo[i][j] = memo[i - 1][j];
                    if(j &amp;gt; 0 &amp;amp;&amp;amp;s2.charAt(j - 1) == s3.charAt(i + j - 1))
                        memo[i][j] |= memo[i][j - 1];
                }
            }
        }
        
        return memo[s1.length()][s2.length()];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Binary Search Tree Iterator</title>
      <link>http://xmruibi.github.io/2015/10/20/binary-search-tree-iterator/</link>
      <pubDate>Tue, 20 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/binary-search-tree-iterator/</guid>
      <description>

&lt;p&gt;Design an iterator over a binary search tree with the following rules:&lt;/p&gt;

&lt;p&gt;Elements are visited in ascending order (i.e. an in-order traversal)
next() and hasNext() queries run in O(1) time in average.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For the following binary search tree, in-order traversal by using iterator is [1, 6, 10, 11, 12]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   10
 /    \
1      11
 \       \
  6       12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###Challenge
Extra memory usage O(h), h is the height of the tree.&lt;/p&gt;

&lt;p&gt;Super Star: Extra memory usage O(1)&lt;/p&gt;

&lt;h2 id=&#34;think-1&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Stack: Preorder&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    // O(height of tree) space to store current left branch nodes
    Stack&amp;lt;TreeNode&amp;gt; stack;

    //@param root: The root of binary tree.
    public Solution(TreeNode root) {

        stack = new Stack&amp;lt;&amp;gt;();
        if(root == null)
            return;
        stack.push(root);
        TreeNode left = root.left;
        while(left != null) {
            stack.push(left);
            left = left.left;
        }
    }

    //@return: True if there has next node, or false
    public boolean hasNext() {
        return !stack.isEmpty();
    }
    
    //@return: return next node
    public TreeNode next() {
        TreeNode pop = stack.pop();

        // each time pop a node, push left branch nodes for current pop node&#39;s right child
        TreeNode left = pop.right;
        while(left != null) {
            stack.push(left);
            left = left.left;
        }
        return pop;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Find the Weak Connected Component in the Directed Graph</title>
      <link>http://xmruibi.github.io/2015/10/20/find-the-weak-connected-component-in-the-directed-graph/</link>
      <pubDate>Tue, 20 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/find-the-weak-connected-component-in-the-directed-graph/</guid>
      <description>

&lt;p&gt;Find the number Weak Connected Component in the directed graph. Each node in the graph contains a label and a list of its neighbors. (a connected set of a directed graph is a subgraph in which any two vertices are connected by direct edge path.)&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given graph:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A-----&amp;gt;B  C
 \     |  | 
  \    |  |
   \   |  |
    \  v  v
     -&amp;gt;D  E &amp;lt;- F
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Return &lt;code&gt;{A,B,D}&lt;/code&gt;, &lt;code&gt;{C,E,F}&lt;/code&gt;. Since there are two connected component which are &lt;code&gt;{A,B,D}&lt;/code&gt; and &lt;code&gt;{C,E,F}&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;Sort the element in the set in increasing order&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Union Find&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class UnionFind{
	// child - parent pair table:
	HashMap&amp;lt;Integer, Integer&amp;gt; pairTab;

	public UnionFind(HashSet&amp;lt;Integer&amp;gt; set) {
		pairTab = new HashMap&amp;lt;&amp;gt;();
		for(Integer i : set) 
			pairTab.put(i, i);
	}

	public int find(int x) {
		int parent = pairTab.get(x);
		while(parent != pairTab.get(parent)){
			parent = pairTab.get(parent);
		}
		return parent;
	}

	public void union(int x, int y) {
		int parent_x = find(x);
		int parent_y = find(y);
		if(parent_x != parent_y)
			pairTab.put(parent_x, parent_y);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nodes a array of Directed graph node
     * @return a connected set of a directed graph
     */
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; connectedSet2(ArrayList&amp;lt;DirectedGraphNode&amp;gt; nodes) {
        
        HashSet&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        for(DirectedGraphNode node : nodes) 
            set.add(node.label);
        
        // to make union
        UnionFind uf = new UnionFind(set);
        for(DirectedGraphNode x : nodes) {
            for(DirectedGraphNode y : x.neighbors) {
                uf.union(x.label, y.label);
            }
        }
        
        HashMap&amp;lt;Integer, ArrayList&amp;lt;Integer&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(Integer label : set) {
            int parent = uf.find(label);
            if(!map.containsKey(parent)) 
                map.put(parent, new ArrayList&amp;lt;Integer&amp;gt;());
            ArrayList&amp;lt;Integer&amp;gt; cur = map.get(parent);
            cur.add(label);
            map.put(parent, cur);
        }
        
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        for(Map.Entry&amp;lt;Integer, ArrayList&amp;lt;Integer&amp;gt;&amp;gt; entry : map.entrySet()) {
            Collections.sort(entry.getValue());
            res.add(entry.getValue());
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Digit Counts</title>
      <link>http://xmruibi.github.io/2015/10/20/digit-counts/</link>
      <pubDate>Tue, 20 Oct 2015 10:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/digit-counts/</guid>
      <description>

&lt;p&gt;Count the number of k&amp;rsquo;s between 0 and n. k can be 0 - 9.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;if n=12, k=1 in &lt;code&gt;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]&lt;/code&gt;, we have &lt;code&gt;FIVE&lt;/code&gt; 1&amp;rsquo;s &lt;code&gt;(1, 10, 11, 12)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think-1&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Brute Force: Check each digit in number form (0 -&amp;gt; n) then get the count;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1&#34;&gt;Solution #1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	public int digitCounts(int k, int n) {
        int[] record = new int[10];
        Arrays.fill(record,0);
        for (int i=0;i&amp;lt;=n;i++){
            String temp = Integer.toString(i);
            for (int j=0;j &amp;lt; temp.length();j++){
                int ind = (int) (temp.charAt(j)-&#39;0&#39;);
                record[ind]++;
            }
        }
        return record[k];            
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Math:

&lt;ul&gt;
&lt;li&gt;When current digit less than &lt;code&gt;k&lt;/code&gt;, the current count should be &lt;code&gt;higher digits x digit position&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;When current digit equal to &lt;code&gt;k&lt;/code&gt;, the current count should be &lt;code&gt;higher digits x digit position + lower digits + 1&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;When current digit larger than &lt;code&gt;k&lt;/code&gt;, the current count should be &lt;code&gt;higher digits + 1(itself) x digit position&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;When &lt;code&gt;k&lt;/code&gt; == 0 and the current digit larger than &lt;code&gt;k&lt;/code&gt;, the higher digits x digit position and it need to add one in the last result;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-2&#34;&gt;Solution #2&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /*
     * param k : As description.
     * param n : As description.
     * return: An integer denote the count of digit k in 1..n
     */
    public int digitCounts(int k, int n) {
        int digit = 1;
        int cnt = 0;
        while(digit &amp;lt;= n) {
            int low = n % digit; // lower digits;
            int high = n / (digit*10); // higher digits;
            int cur = n / digit % 10;
            if(cur == k) {
                // higher digits * digit + lower digits + 1;
                cnt += ((high * digit) + low + 1);
            }else if(cur &amp;lt; k) {
                // higher digits * digit
                cnt += (high * digit);
            }else{
                // (higher digits + 1: itself) * digit
                cnt += ((high + (k == 0?0:1)) * digit);   
            }
            digit *= 10;
        }
        
        return cnt + (k == 0 ? 1 : 0);
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Divide Two Integers</title>
      <link>http://xmruibi.github.io/2015/10/20/divide-two-integers/</link>
      <pubDate>Tue, 20 Oct 2015 10:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/20/divide-two-integers/</guid>
      <description>

&lt;p&gt;Divide two integers without using multiplication, division and mod operator.&lt;/p&gt;

&lt;p&gt;If it is overflow, return &lt;code&gt;2147483647&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given dividend = &lt;code&gt;100&lt;/code&gt; and divisor = &lt;code&gt;9&lt;/code&gt;, return &lt;code&gt;11&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Bitwise Idea:

&lt;ul&gt;
&lt;li&gt;Get the result sign (negative or positive) by &lt;code&gt;((dividend ^ divisor) &amp;gt;&amp;gt;&amp;gt; 31) == 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;This question contains many corner cases!&lt;/li&gt;
&lt;li&gt;Firstly, check the corner cases in following steps:

&lt;ul&gt;
&lt;li&gt;Divisor is zero? return &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Dividend is &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;?

&lt;ul&gt;
&lt;li&gt;if divisor is negative one? you cannot get the positive &lt;code&gt;MIN_VALUE&lt;/code&gt; so return &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dividend += Math.abs(divisor)&lt;/code&gt; so that the dividend become away from overflow but that leads the res increase one;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Divisor is &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;? return res; To avoid the inaccurate from above operation;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Make dividend and divisor both positive;&lt;/li&gt;
&lt;li&gt;Then, the main operation to do the binary substraction;

&lt;ul&gt;
&lt;li&gt;Get the most higher position(&lt;code&gt;digit&lt;/code&gt;) for bit one with increasing the divisor until it is just larger than (&lt;code&gt;dividend &amp;gt;&amp;gt; 1&lt;/code&gt;): divisor cannot larger than dividend so that we use the &lt;code&gt;dividend&amp;gt;&amp;gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Get result by add the &lt;code&gt;1&amp;lt;&amp;lt;digit&lt;/code&gt; (current bit position should be one) and &lt;code&gt;dividend -= divisor&lt;/code&gt; but if divisor larger than dividend which means current bit position should be zero so just reduce digit and divisor should shift right one position each time;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param dividend the dividend
     * @param divisor the divisor
     * @return the result
     */
    public int divide(int dividend, int divisor) {
        int res = 0;
        if(divisor == 0)
            return Integer.MAX_VALUE;
        boolean neg = ((dividend ^ divisor) &amp;gt;&amp;gt;&amp;gt; 31) == 1;  
        if(dividend == Integer.MIN_VALUE) {
            // since the dividend is negative number now so we plus the abs(divisor)
            dividend += Math.abs(divisor);
            if(divisor == -1)
                return Integer.MAX_VALUE;
            res++;
        }
        
        if(divisor == Integer.MIN_VALUE)
            return res;
        
        // the highest position for bit in result   
        int digit = 0;
        dividend = Math.abs(dividend);  
        divisor = Math.abs(divisor);
        while(divisor &amp;lt;= (dividend&amp;gt;&amp;gt;1)) {
            divisor &amp;lt;&amp;lt;= 1;
            digit ++;
        }
        
        while(digit&amp;gt;=0){
            if(dividend&amp;gt;=divisor){
                res += (1&amp;lt;&amp;lt;digit);
                dividend-=divisor;
            }
            divisor&amp;gt;&amp;gt;=1;
            digit--;
        }
        return neg?-res:res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Number of Airplanes in the Sky</title>
      <link>http://xmruibi.github.io/2015/10/19/number-of-airplanes-in-the-sky/</link>
      <pubDate>Mon, 19 Oct 2015 22:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/number-of-airplanes-in-the-sky/</guid>
      <description>

&lt;p&gt;Given an interval list which are flying and landing time of the flight. How many airplanes are on the sky at most?&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For interval list &lt;code&gt;[[1,10],[2,3],[5,8],[4,7]]&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;If landing and flying happens at the same time, we consider landing should happen at first.&lt;/p&gt;

&lt;h2 id=&#34;think-1&#34;&gt;Think #1&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Array Method (Naive):

&lt;ul&gt;
&lt;li&gt;Use an integer array to count segment occurence.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    /**
     * Array Method:
     * @param intervals: An interval array
     * @return: Count of airplanes are in the sky.
     */
    public int countOfAirplanes(List&amp;lt;Interval&amp;gt; airplanes) { 
        
        // find the min and max value in interval list;
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        for(Interval interval : airplanes) {
            min = Math.min(min, interval.start);
            max = Math.max(max, interval.end);
        }

        int maxCnt = 0;
        int[] segment = new int[max - min + 1];
        for(Interval interval : airplanes) {
            for(int i = interval.start; i &amp;lt; interval.end; i++) {
                segment[i - min]++;
                maxCnt = Math.max(maxCnt, segment[i - min]);
            }
        }
        return maxCnt;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think-2&#34;&gt;Think #2&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Customized Structure:

&lt;ul&gt;
&lt;li&gt;Point Class: mark &lt;code&gt;int time&lt;/code&gt; and (&lt;code&gt;boolean start/end&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Mark those Points ordered by time.&lt;/li&gt;
&lt;li&gt;One pass all points and count increase when touch start but decrease when end;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution-1&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    /**
     * Point Method:
     * @param intervals: An interval array
     * @return: Count of airplanes are in the sky.
     */
    public int countOfAirplanes(List&amp;lt;Interval&amp;gt; airplanes) { 

    	// create a list with point class
    	List&amp;lt;Point&amp;gt; points = new ArrayList&amp;lt;&amp;gt;();
    	for(Interval interval : airplanes) {
    		points.add(new Point(interval.start, 1));
    		points.add(new Point(interval.end, 0));
    	}

    	// sort
    	Collections.sort(points, new Comparator&amp;lt;Point&amp;gt;(){
    	    @Override
    	    public int compare(Point p1, Point p2) {
    	         if(p1.time == p2.time) return p1.flag - p2.flag;
                 else return p1.time - p2.time;
    	    }
    	});

    	// one pass for count
    	int count = 0;
    	int max = 0; // record the peak count;
    	for(Point p : points) {
    		if(p.flag == 1)
    			count++;
    		else
    			count--;
    		max = Math.max(max, count);
    	}

    	return max;
	}

	private class Point{
		int time;
		int flag;
		public Point(int time, int flag) {
			this.time = time;
			this.flag = flag;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Array Method (Naive):&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Two pass and one of pass has one more inner loop (segment size: k): o(n + n*k) -&amp;gt; O(n^2);
An array to store occurence frequence: Space: O(n);&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Next Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/next-permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/next-permutation/</guid>
      <description>

&lt;p&gt;Given a list of integers, which denote a permutation.&lt;/p&gt;

&lt;p&gt;Find the next permutation in ascending order.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;[1,3,2,3]&lt;/code&gt;, the next permutation is &lt;code&gt;[1,3,3,2]&lt;/code&gt;
For &lt;code&gt;[4,3,2,1]&lt;/code&gt;, the next permutation is &lt;code&gt;[1,2,3,4]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The list may contains duplicate integers.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;字典序算法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从后往前寻找索引满足 a[k] &amp;lt; a[k + 1], 如果此条件不满足，则说明已遍历到最后一个。&lt;/li&gt;
&lt;li&gt;如 k == 0, 说明是字典序最后一位， 因此直接倒置整个数组即可.&lt;/li&gt;
&lt;li&gt;从后往前遍历，找到第一个比a[k]大的数a[l], 即a[k] &amp;lt; a[l].&lt;/li&gt;
&lt;li&gt;交换a[k]与a[l].&lt;/li&gt;
&lt;li&gt;反转k + 1 ~ n之间的元素.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nums: an array of integers
     * @return: return nothing (void), do not return anything, modify nums in-place instead
     */
    public int[] nextPermutation(int[] nums) {
        if(nums == null || nums.length == 1)
            return nums;
        
        // step1: find nums[i] &amp;lt; nums[i + 1]
        int i = 0;
        for (i = nums.length - 2; i &amp;gt;= 0; i--) {
            if (nums[i] &amp;lt; nums[i + 1]) {
                break;
            } else if (i == 0) {
                // reverse nums if reach maximum
                reverse(nums, 0, nums.length - 1);
                return nums;
            }
        }
        // step2: find nums[i] &amp;lt; nums[j]
        int j = 0;
        for (j = nums.length - 1; j &amp;gt; i; j--) {
            if (nums[i] &amp;lt; nums[j]) {
                break;
            }
        }
        // step3: swap betwenn nums[i] and nums[j]
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
        
        // step4: reverse between [i + 1, n - 1]
        reverse(nums, i + 1, nums.length - 1);

        return nums;
    }
    
    private void reverse(int[] nums, int l, int r) {
        while(l &amp;lt; r) {
            int tmp = nums[l];
            nums[l++] = nums[r];
            nums[r--] = tmp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis&lt;/h2&gt;

&lt;p&gt;At most, two pass o(2*n) -&amp;gt; O(n); Constant Space Complexity: O(1)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation/</guid>
      <description>

&lt;p&gt;Given a list of numbers, return all possible permutations.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For nums = [1,2,3], the permutations are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it without recursion.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;h4 id=&#34;method-one&#34;&gt;Method One:&lt;/h4&gt;

&lt;p&gt;Backtracking, with memorized the element usage, which takes space, or we can search on arraylist(more time);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /**
     * @param nums: A list of integers.
     * @return: A list of permutations.
     */
    public ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; permute(ArrayList&amp;lt;Integer&amp;gt; nums) {

        ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(nums == null || nums.size() == 0)
            return res;
        helper(res, new ArrayList&amp;lt;Integer&amp;gt;(), nums);
        return res;
    }
    
    private void helper(ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; res, ArrayList&amp;lt;Integer&amp;gt; list,  ArrayList&amp;lt;Integer&amp;gt; nums ) {
        
        if(list.size() == nums.size()) {
            res.add(new ArrayList&amp;lt;Integer&amp;gt;(list));
            return;
        }
        
        for(int i = 0; i&amp;lt;nums.size(); i++){
        	// to check if this number already taken
            if(list.contains(nums.get(i)))
                continue;
            
            list.add(nums.get(i));
            helper(res, list, nums);
            list.remove(list.size() - 1);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;method-two&#34;&gt;Method Two:&lt;/h4&gt;

&lt;p&gt;Swap: &lt;a href=&#34;https://www.cs.princeton.edu/~rs/talks/perms.pdf&#34;&gt;Reference&lt;/a&gt;;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://xmruibi.github.io/media/PermutationSwap.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
  private static Set&amp;lt;Integer&amp;gt; exchPermutation(int[] arr) {
    Set&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
    int i = 0, num = 0;
    outer: while(true) {
      
      while(i &amp;lt; arr.length - 1) {
        num = exchGenerate(arr, i, ++i);
        if(set.contains(num))
          break outer;
        set.add(num);
      }
      
      num = exchGenerate(arr, 0, 1);
      if(set.contains(num))
        break outer;
      set.add(num);
      
      while(i &amp;gt; 0) {
        num = exchGenerate(arr, --i, i+1);
        if(set.contains(num))
          break outer;
        set.add(num);
      }
      
      num = exchGenerate(arr, arr.length - 2, arr.length - 1);
      if(set.contains(num))
        break outer;
      set.add(num);
    }
    return set;
  }
  
  private static int exchGenerate(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
    
    int res = 0;
    for(int n : arr){
      res = res*10 + n;
    }
    return res;
  }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Previous Permutation</title>
      <link>http://xmruibi.github.io/2015/10/19/previous-permutation/</link>
      <pubDate>Mon, 19 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/previous-permutation/</guid>
      <description>

&lt;p&gt;Given a list of integers, which denote a permutation.&lt;/p&gt;

&lt;p&gt;Find the previous permutation in ascending order.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;[1,3,2,3]&lt;/code&gt;, the previous permutation is &lt;code&gt;[1,2,3,3]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For &lt;code&gt;[1,2,3,4]&lt;/code&gt;, the previous permutation is [&lt;code&gt;4,3,2,1]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The list may contains duplicate integers.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;step 1: find last nums[k] &amp;gt; nums[k + 1];&lt;/li&gt;
&lt;li&gt;step 2: find last nums[i] &amp;gt; nums[k];&lt;/li&gt;
&lt;li&gt;step 3: swap i, j;&lt;/li&gt;
&lt;li&gt;step 4: reverse num after i;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param nums: A list of integers
     * @return: A list of integers that&#39;s previous permuation
     */
    public ArrayList&amp;lt;Integer&amp;gt; previousPermuation(ArrayList&amp;lt;Integer&amp;gt; nums) {
        if(nums == null || nums.size() &amp;lt;= 1)
            return nums;
            
        // step 1: find last nums[k] &amp;gt; nums[k + 1]
        int i = nums.size() - 2;
        for (; i &amp;gt;= 0; i--) {
            if (nums.get(i) &amp;gt; nums.get(i + 1)) {
                break;
            }
            if(i &amp;lt;= 0) {
                reverse(nums, 0, nums.size() - 1);
                return nums;
            }
        }

        // step 2: find last nums[i] &amp;gt; nums[k]
        int j = nums.size() - 1;
        for (; j &amp;gt; i; j--) {
            if (nums.get(i) &amp;gt; nums.get(j)) {
                break;
            }
        }
        
        // step 3: swap i, j
        Collections.swap(nums, i, j);
        
        // step 4: reverse num after i
        reverse(nums, i + 1, nums.size() - 1);
        
        return nums;
    }
    
    private void reverse(ArrayList&amp;lt;Integer&amp;gt; nums,  int start, int end) {
        for (int i = start, j = end; i &amp;lt; j; i++, j--) {
            Collections.swap(nums, i, j);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Permutation Index II</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation-index-ii/</link>
      <pubDate>Mon, 19 Oct 2015 11:45:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation-index-ii/</guid>
      <description>

&lt;p&gt;Given a permutation which may contain repeated numbers, find its index in all the permutations of these numbers, which are ordered in lexicographical order. The index begins at 1.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given the permutation &lt;code&gt;[1, 4, 2, 2]&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;The key is counting from low digit(right) to higher digit(left), and checking how many digits are less than current digits. Then using that count as the coefficient with positional weight. However, there are duplicates occured. So that means we can use a hash map to do the count.
But the positional system should be modified. The multiple of the factorial of the duplicates occurence should be divided by original position system. That means the &lt;code&gt;entry.value&lt;/code&gt; need to to the factorial and multiply those factors.
Why? For example, n numbers with 2 duplicates, like &lt;code&gt;2,4,3,3&lt;/code&gt;, when &lt;code&gt;4&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param A an integer array
     * @return a long integer
     */
    public long permutationIndexII(int[] A) {
        if(A == null || A.length == 0)
            return 0L;
        
        int pos = 2;
        long factor = 1;
        long index = 1;
        for(int i = A.length - 2; i &amp;gt;= 0; i--) {
            HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
            int cnt = 0;
            // count itself
            map.put(A[i], 1);
            for(int j = i + 1; j &amp;lt; A.length; j++) {
                // count all occurence on following element in Array
                map.put(A[j], map.containsKey(A[j])?map.get(A[j])+1:1);
                if(A[i] &amp;gt; A[j])
                    cnt++;
            }
            index += (cnt*factor)/factorialMultiple(map);
            factor *= pos;
            pos++;
        }
        
        return index;
    }
    
    private int factorialMultiple(HashMap&amp;lt;Integer, Integer&amp;gt; map) {
        int res = 1;
        for(int value : map.values()) {
            // do the factor on occurence
            int factor = 1;
            for(int i = 1; i &amp;lt;= value; i++)
                factor*= i;
            // get the multiple of occurence factor
            res *= factor;
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Permutation Sequence</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation-sequence/</link>
      <pubDate>Mon, 19 Oct 2015 11:45:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation-sequence/</guid>
      <description>

&lt;p&gt;Given n and k, return the k-th permutation sequence.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For n = 3, all permutations are listed as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;123&amp;quot;
&amp;quot;132&amp;quot;
&amp;quot;213&amp;quot;
&amp;quot;231&amp;quot;
&amp;quot;312&amp;quot;
&amp;quot;321&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If k = &lt;code&gt;4&lt;/code&gt;, the fourth permutation is &amp;laquo;&lt;code&gt;231&lt;/code&gt;&amp;laquo;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;n will be between 1 and 9 inclusive.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n*k) in time complexity is easy, can you do it in O(n^2) or less?&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;p&gt;a1,a2,a3&amp;hellip;..an的permutation 如果确定了a1,那么剩下的permutation就有(n-1)!种 所以 a1 = k / (n-1)! k2 = k % (n-1)! a2 = k2 / (n-2)!&lt;/p&gt;

&lt;p&gt;要注意的是&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;得到的应该是剩下选择数字的index,而不是value,所以要建一个存储可用数字的list&lt;/li&gt;
&lt;li&gt;在用完一个数字后要将它从list中删去&lt;/li&gt;
&lt;li&gt;array是0-based index, 那么K也应该减去1变为0-based的 (&lt;code&gt;k--&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /**
      * @param n: n
      * @param k: the kth permutation
      * @return: return the k-th permutation
      */
    public String getPermutation(int n, int k) {
        
        int[] factors = new int[n + 1];
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        factors[0] = 1;
        for(int i = 1; i &amp;lt;= n; i++) {
            factors[i] = i * factors[i-1];
            list.add(i);
        }
        
        StringBuilder sb = new StringBuilder();
        // for index alignment： e.g: k == 12, k / 6 = 2, 
        // however, it should still belong the number start for list.get(1); So here need to make a alignment
        k--;
        while(n &amp;gt; 1) {
            int index = k / factors[n-1];
            sb.append(list.remove(index));
            k %= factors[n-1];
            n--;
        }
        sb.append(list.get(0));
        return sb.toString();
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Permutation Index</title>
      <link>http://xmruibi.github.io/2015/10/19/permutation-index/</link>
      <pubDate>Mon, 19 Oct 2015 11:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/19/permutation-index/</guid>
      <description>

&lt;p&gt;Given a permutation which contains no repeated number, find its index in all the permutations of these numbers, which are ordered in lexicographical order. The index begins at 1.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;[1,2,4]&lt;/code&gt;, return &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;thinking&#34;&gt;Thinking&lt;/h2&gt;

&lt;p&gt;Illustrating by manually getting the index of {2, 4, 3, 1}. Since this is a 4-element set, we know there are 4! permutations (4! = 4*3*2*1). If the set only had 3 elements, we would have 3*2*1 permutations. If the set only had 2 elements, we would have 2!=2*1 permutations; and so on.&lt;/p&gt;

&lt;p&gt;ASIDE: The decimal system of counting is a positional system. A 3-element decimal number, for instance, has the following three positional weights: hundred, ten, unit. Hence, we know the value of the number 472 because we understand: 4*hundred + 7*ten + 2*unit.&lt;/p&gt;

&lt;p&gt;If we treat our 4-element set as a positional system, then we get the following positional weights: 3!, 2!, 1!, 0. So that the index of {2, 4, 3, 1} is: x*3!+y*2!+z*1!+w*0. Presently it suffices to find the values of x,y,z to calculate the index (we ignore w because it is paired with 0). x,y,z are counters: the number of succeeding elements less than the element being considered. For example, in {2, 4, 3, 1}, there are two succeeding elements less than 4 (namely 3 and 1). For 2 it&amp;rsquo;s 1 (1); for 4 it&amp;rsquo;s 2 (3 and 1); for 3 it&amp;rsquo;s 1 (1); for 1 it&amp;rsquo;s 0. Now we can calculate the index of {2, 4, 3, 1} as: x=1, y=2, z=1:
    &lt;code&gt;x*3!+y*2!+z*1!+w*0 = 1*3! + 2*2! + 1*1! = 6 + 4 + 1 = 11&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The key is counting from low digit(right) to higher digit(left), and checking how many digits are less than current digits. Then using that count as the coefficient with positional weight.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param A an integer array
     * @return a long integer
     */
    public long permutationIndex(int[] A) {
        
        if(A == null || A.length == 0)
            return 0L;
        
        int pos = 2;
        long factor = 1;
        long index = 1;
        for(int i = A.length - 2; i &amp;gt;= 0; i--) {
            int cnt = 0;
            for(int j = i + 1; j &amp;lt; A.length; j++) {
                if(A[i] &amp;gt; A[j])
                    cnt++;
            }
            index += (cnt*factor);
            factor *= pos;
            pos++;
        }
        
        return index;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis&lt;/h2&gt;

&lt;p&gt;Two loop: &lt;code&gt;i range 0 -&amp;gt; length - 2&lt;/code&gt; and &lt;code&gt;j range i + 1 -&amp;gt; length - 1&lt;/code&gt;, So it is &lt;code&gt;O(n^2)&lt;/code&gt;;
Constant Space with some integer variable, Space: &lt;code&gt;O(1)&lt;/code&gt;;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Max Points on a Line</title>
      <link>http://xmruibi.github.io/2015/10/18/max-points-on-a-line/</link>
      <pubDate>Sun, 18 Oct 2015 20:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/max-points-on-a-line/</guid>
      <description>

&lt;p&gt;Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given 4 points: &lt;code&gt;(1,2)&lt;/code&gt;, &lt;code&gt;(3,6)&lt;/code&gt;, &lt;code&gt;(0,0)&lt;/code&gt;, &lt;code&gt;(1,3)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The maximum number is &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use one point as a baseline. (&lt;code&gt;Point pa&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Iterate other points (&lt;code&gt;Point pb&lt;/code&gt;) (index greater than &lt;code&gt;pa&lt;/code&gt;): &lt;code&gt;j = i + 1&lt;/code&gt; and&lt;/li&gt;
&lt;li&gt;Use Hash Map to record the ratio and count&lt;/li&gt;
&lt;li&gt;Note:

&lt;ul&gt;
&lt;li&gt;Ratio is &lt;code&gt;double radio = (double)(pa.y - pb.y) / (double)(pa.x - pb.x)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;When pa.x == pb.x &amp;amp;&amp;amp; pa.y == pb.y, consider two points are the same, also need to count the same point.&lt;/li&gt;
&lt;li&gt;When only &lt;code&gt;pa.x == pb.x&lt;/code&gt;, that means the ratio is infinity as &lt;code&gt;(double)Integer.MAX_VALUE&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;When only &lt;code&gt;pa.y == pb.y&lt;/code&gt;, that means the ratio is zero;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Iterate Hash Map and get the local max with updating the global max;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param points an array of point
     * @return an integer
     */
    public int maxPoints(Point[] points) {
        if(points == null || points.length == 0)
            return 0;
        
       
        int maxLine = 0;
        for(int i = 0; i &amp;lt; points.length; i++) {
            Map&amp;lt;Double, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
            Point pa = points[i];
            int same = 0;
            for(int j = i + 1; j &amp;lt; points.length; j++) {
                    Point pb = points[j];
                    int cnt = 0;
                    if(pa.x == pb.x &amp;amp;&amp;amp; pa.y == pb.y)
                        same ++;
                    else if(pa.x == pb.x) {
                        map.put((double)Integer.MAX_VALUE, map.containsKey((double)Integer.MAX_VALUE)?map.get((double)Integer.MAX_VALUE) + 1 : 2);
                    }else if(pa.y == pb.y)
                        map.put((double)0, map.containsKey((double)0)?map.get((double)0) + 1 : 2);
                    else{
                        double radio = (double)(pa.y - pb.y) / (double)(pa.x - pb.x);
                        map.put(radio, map.containsKey(radio)?map.get(radio) + 1 : 2);
                    }
            }
            int localMax = 1;
            for (Integer value : map.values())   
                localMax = Math.max(localMax, value);
            localMax += same;  
            maxLine = Math.max(maxLine, localMax); 
        }
        
        return maxLine;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Count of Smaller Number</title>
      <link>http://xmruibi.github.io/2015/10/18/count-of-smaller-number/</link>
      <pubDate>Sun, 18 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/count-of-smaller-number/</guid>
      <description>

&lt;p&gt;Give you an integer array (index from 0 to n-1, where n is the size of this array, value from 0 to 10000) and an query list. For each query, give you an integer, return the number of element in the array that are smaller that the given integer.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For array &lt;code&gt;[1,2,7,8,5]&lt;/code&gt;, and queries &lt;code&gt;[1,8,5]&lt;/code&gt;, return &lt;code&gt;[0,4,2]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Could you use three ways to do it.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Just loop&lt;/li&gt;
&lt;li&gt;Sort and binary search&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;1-solution-by-loop-with-o-n-2&#34;&gt;1. Solution by Loop with O(n^2)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;

   /** O(n^2) Loop implement
     * @param A: An integer array
     * @return: The number of element in the array that 
     *          are smaller that the given integer
     */
    public ArrayList&amp;lt;Integer&amp;gt; countOfSmallerNumber(int[] A, int[] queries) {
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(A == null || queries == null)
            return res;
            
        for(int i = 0; i &amp;lt; queries.length; i++) {
            int cnt = 0;
            for(int j = 0; j &amp;lt; A.length; j++) {
                if(A[j] &amp;lt; queries[i])
                    cnt++;
            }
            res.add(cnt);
        }
        return res;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-solution-by-sort-and-binary-search-with-o-nlogn&#34;&gt;2. Solution by Sort and Binary search with O(nlogn)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    /** O(nlogn) Sort and Binary search
     * @param A: An integer array
     * @return: The number of element in the array that 
     *          are smaller that the given integer
     */
    public ArrayList&amp;lt;Integer&amp;gt; countOfSmallerNumber(int[] A, int[] queries) {
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(queries == null)
            return res;
         
        Arrays.sort(A);
        for(int i = 0; i &amp;lt; queries.length; i++) {
            int cnt = binarySearch(A, queries[i]);
            res.add(cnt);
        }
        return res;
    }
    
    private int binarySearch(int[] A, int value) {
        if(A == null || A.length == 0)
            return 0;
        int l = 0, r = A.length - 1;
        while(l + 1 &amp;lt; r) {
            int m = l + ((r - l) &amp;gt;&amp;gt; 1);
            if(value &amp;gt; A[m])
                l = m;
            else
                r = m;
        }
        if(A[l] &amp;lt; value)
            return l + 1;
        else
            return l; 
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Smallest Difference</title>
      <link>http://xmruibi.github.io/2015/10/18/smallest-difference/</link>
      <pubDate>Sun, 18 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/smallest-difference/</guid>
      <description>

&lt;p&gt;Given two array of integers(the first array is array A, the second array is array B), now we are going to find a element in array A which is A[i], and another element in array B which is B[j], so that the difference between A[i] and B&lt;a href=&#34;|A[i] - B[j]|&#34;&gt;j&lt;/a&gt; is as small as possible, return their smallest difference.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For example, given array A = &lt;code&gt;[3,6,7,4]&lt;/code&gt;, B = &lt;code&gt;[2,8,9,3]&lt;/code&gt;, return &lt;code&gt;0&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n log n) time&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Do sort on one of array&lt;/li&gt;
&lt;li&gt;One pass on another array and do binary search on the sorted array.&lt;/li&gt;
&lt;li&gt;Search the target value from passing array and get the minimum difference on sorted array&lt;/li&gt;
&lt;li&gt;Update the global minimum difference each time.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param A, B: Two integer arrays.
     * @return: Their smallest difference.
     */
    public int smallestDifference(int[] A, int[] B) {
        if(A == null || B == null || A.length == 0 || B.length == 0)
            return 0;
        Arrays.sort(B);
        int mindiff = Integer.MAX_VALUE;
        for(int i = 0; i &amp;lt; A.length; i++) {
            int curdiff = binarySearch(B, A[i]);
            mindiff = Math.min(mindiff, curdiff);
        }
        return mindiff;
    }
    
    
    private int binarySearch(int[] A, int value) {
        if(A == null || A.length == 0)
            return 0;
        int l = 0, r = A.length - 1;
        while(l + 1 &amp;lt; r) {
            int m = l + ((r - l) &amp;gt;&amp;gt; 1);
            if(value &amp;gt; A[m])
                l = m;
            else
                r = m;
        }
        return Math.min(Math.abs(A[l] - value), Math.abs(A[r] - value));
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>