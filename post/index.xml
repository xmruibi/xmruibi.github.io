<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/post/</link>
    <description>Recent content in Posts on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Sun, 18 Oct 2015 16:13:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Count of Smaller Number</title>
      <link>http://xmruibi.github.io/2015/10/18/count-of-smaller-number/</link>
      <pubDate>Sun, 18 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/count-of-smaller-number/</guid>
      <description>

&lt;p&gt;Give you an integer array (index from 0 to n-1, where n is the size of this array, value from 0 to 10000) and an query list. For each query, give you an integer, return the number of element in the array that are smaller that the given integer.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For array &lt;code&gt;[1,2,7,8,5]&lt;/code&gt;, and queries &lt;code&gt;[1,8,5]&lt;/code&gt;, return &lt;code&gt;[0,4,2]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Could you use three ways to do it.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Just loop&lt;/li&gt;
&lt;li&gt;Sort and binary search&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;1-solution-by-loop-with-o-n-2&#34;&gt;1. Solution by Loop with O(n^2)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;

   /** O(n^2) Loop implement
     * @param A: An integer array
     * @return: The number of element in the array that 
     *          are smaller that the given integer
     */
    public ArrayList&amp;lt;Integer&amp;gt; countOfSmallerNumber(int[] A, int[] queries) {
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(A == null || queries == null)
            return res;
            
        for(int i = 0; i &amp;lt; queries.length; i++) {
            int cnt = 0;
            for(int j = 0; j &amp;lt; A.length; j++) {
                if(A[j] &amp;lt; queries[i])
                    cnt++;
            }
            res.add(cnt);
        }
        return res;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-solution-by-sort-and-binary-search-with-o-nlogn&#34;&gt;2. Solution by Sort and Binary search with O(nlogn)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    /** O(nlogn) Sort and Binary search
     * @param A: An integer array
     * @return: The number of element in the array that 
     *          are smaller that the given integer
     */
    public ArrayList&amp;lt;Integer&amp;gt; countOfSmallerNumber(int[] A, int[] queries) {
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(queries == null)
            return res;
         
        Arrays.sort(A);
        for(int i = 0; i &amp;lt; queries.length; i++) {
            int cnt = binarySearch(A, queries[i]);
            res.add(cnt);
        }
        return res;
    }
    
    private int binarySearch(int[] A, int value) {
        if(A == null || A.length == 0)
            return 0;
        int l = 0, r = A.length - 1;
        while(l + 1 &amp;lt; r) {
            int m = l + ((r - l) &amp;gt;&amp;gt; 1);
            if(value &amp;gt; A[m])
                l = m;
            else
                r = m;
        }
        if(A[l] &amp;lt; value)
            return l + 1;
        else
            return l; 
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Interval Minimum Number</title>
      <link>http://xmruibi.github.io/2015/10/18/interval-minimum-number/</link>
      <pubDate>Sun, 18 Oct 2015 15:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/interval-minimum-number/</guid>
      <description>

&lt;p&gt;Given an integer array (index from 0 to n-1, where n is the size of this array), and an query list. Each query has two integers [start, end]. For each query, calculate the minimum number between index start and end in the given array, return the result list.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For array &lt;code&gt;[1,2,7,8,5]&lt;/code&gt;, and queries &lt;code&gt;[(1,2),(0,4),(2,4)]&lt;/code&gt;, return &lt;code&gt;[2,1,5]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(logN) time for each query (Segment Tree)&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     *@param A, queries: Given an integer array and an query list
     *@return: The result list
     */
    public ArrayList&amp;lt;Integer&amp;gt; intervalMinNumber(int[] A, 
                                                ArrayList&amp;lt;Interval&amp;gt; queries) {
        IntervalTree tree = new IntervalTree(A);
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        for(Interval interval : queries) {
            res.add(tree.query(interval.start, interval.end));
        }
        return res;
    }
}

/**
* Build Interval Tree with Min of segment!
*
*/
class IntervalTree{
        IntervalNode root;
        
        public IntervalTree(int[] A) {
            root = build(A, 0, A.length - 1);
        }
        
        private IntervalNode build(int[] A, int start, int end) {
            if(start &amp;gt; end)
                return null;
            IntervalNode node = new IntervalNode(start, end);
            
            if(start == end) {
                node.min = A[start];
                return node;
            }
            
            int m = start + ((end - start)&amp;gt;&amp;gt;1);
            node.left = build(A, start, m);
            node.right = build(A, m+1, end);
            node.min = Math.min(node.left.min, node.right.min);
            return node;
        }
        
        public int query(int start, int end) {
            return queryhelper(root, start, end);
        }
        
        private int queryhelper(IntervalNode node, int start, int end) {
            if(start &amp;lt;= node.start &amp;amp;&amp;amp; end &amp;gt;= node.end)
                return node.min;
            
            int m = node.start + ((node.end - node.start)&amp;gt;&amp;gt;1);
            if(m &amp;lt; start) {
                return queryhelper(node.right, start, end);
            }else if(m &amp;gt;= end){
                return queryhelper(node.left, start, end);
            }else
                return Math.min(queryhelper(node.left, start, m), queryhelper(node.right, m+1, end));
        }

        private class IntervalNode {
            int start, end, min;
            IntervalNode left, right;
            IntervalNode(int start, int end) {
                this.start = start;
                this.end = end;
            }
        }
}


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Interval Sum</title>
      <link>http://xmruibi.github.io/2015/10/18/interval-sum/</link>
      <pubDate>Sun, 18 Oct 2015 15:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/interval-sum/</guid>
      <description>

&lt;p&gt;Given an integer array (index from 0 to n-1, where n is the size of this array), and an query list. Each query has two integers [start, end]. For each query, calculate the sum number between index start and end in the given array, return the result list.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For array &lt;code&gt;[1,2,7,8,5]&lt;/code&gt;, and queries &lt;code&gt;[(0,4),(1,2),(2,4)]&lt;/code&gt;, return &lt;code&gt;[23,9,20]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(logN) time for each query&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// Segment tree for sum
class IntervalTree{
        IntervalNode root;
        
        public IntervalTree(int[] A) {
            root = build(A, 0, A.length - 1);
        }
        
        private IntervalNode build(int[] A, int start, int end) {
            if(start &amp;gt; end)
                return null;
            IntervalNode node = new IntervalNode(start, end);
            
            if(start == end) {
                node.val = (long)A[start];
                return node;
            }
            
            int m = start + ((end - start)&amp;gt;&amp;gt;1);
            node.left = build(A, start, m);
            node.right = build(A, m+1, end);
            node.val = node.left.val + node.right.val;
            return node;
        }
        
        public long query(int start, int end) {
            return queryhelper(root, start, end);
        }
        
        private long queryhelper(IntervalNode node, int start, int end) {
            if(start &amp;lt;= node.start &amp;amp;&amp;amp; end &amp;gt;= node.end)
                return node.val;
            
            int m = node.start + ((node.end - node.start)&amp;gt;&amp;gt;1);
            if(m &amp;lt; start) {
                return queryhelper(node.right, start, end);
            }else if(m &amp;gt;= end){
                return queryhelper(node.left, start, end);
            }else
                return queryhelper(node.left, start, m) + queryhelper(node.right, m+1, end);
        }

        private class IntervalNode {
            int start, end;
            long val;
            IntervalNode left, right;
            IntervalNode(int start, int end) {
                this.start = start;
                this.end = end;
            }
        }
}

public class Solution {
    /**
     *@param A, queries: Given an integer array and an query list
     *@return: The result list
     */
    public ArrayList&amp;lt;Long&amp;gt; intervalSum(int[] A, 
                                       ArrayList&amp;lt;Interval&amp;gt; queries) {
        IntervalTree tree = new IntervalTree(A);
        ArrayList&amp;lt;Long&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        for(Interval interval : queries) {
            res.add(tree.query(interval.start, interval.end));
        }
        return res;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Interval Sum II</title>
      <link>http://xmruibi.github.io/2015/10/18/interval-sum-ii/</link>
      <pubDate>Sun, 18 Oct 2015 15:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/interval-sum-ii/</guid>
      <description>

&lt;p&gt;Given an integer array in the construct method, implement two methods query(start, end) and modify(index, value):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;For query(start, end), return the sum from index start to index end in the given array.&lt;/li&gt;
&lt;li&gt;For modify(index, value), modify the number in the given index to value.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given array A = &lt;code&gt;[1,2,7,8,5]&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;query(0, 2)&lt;/code&gt;, return &lt;code&gt;10&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modify(0, 4)&lt;/code&gt;, change &lt;code&gt;A[0]&lt;/code&gt; from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;4&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;query(0, 1)&lt;/code&gt;, return &lt;code&gt;6&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modify(2, 1)&lt;/code&gt;, change &lt;code&gt;A[2]&lt;/code&gt; from &lt;code&gt;7&lt;/code&gt;to &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;query(2, 4)&lt;/code&gt;, return &lt;code&gt;14&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(logN) time for query and modify.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /* you may need to use some attributes here */
    
    IntervalNode root;
    /**
     * @param A: An integer array
     */
    public Solution(int[] A) {
        root = build(A, 0, A.length - 1);
    }
    
    private IntervalNode build(int[] A, int start, int end) {
            if(start &amp;gt; end)
                return null;
            IntervalNode node = new IntervalNode(start, end);
            
            if(start == end) {
                node.val = (long)A[start];
                return node;
            }
                
            int m = start + ((end - start)&amp;gt;&amp;gt;1);
            node.left = build(A, start, m);
            node.right = build(A, m+1, end);
            node.val = node.left.val + node.right.val;
            return node;
    }
        
    /**
     * @param start, end: Indices
     * @return: The sum from start to end
     */
    public long query(int start, int end) {
        return query(root, start, end);
    }
        
    private long query(IntervalNode node, int start, int end) {
        if(start &amp;lt;= node.start &amp;amp;&amp;amp; end &amp;gt;= node.end)
            return node.val;
            
        int m = node.start + ((node.end - node.start)&amp;gt;&amp;gt;1);
        if(m &amp;lt; start) {
            return query(node.right, start, end);
        }else if(m &amp;gt;= end){
            return query(node.left, start, end);
        }else
            return query(node.left, start, m) + query(node.right, m+1, end);
    }
    
    /**
     * @param index, value: modify A[index] to value.
     */
    public void modify(int index, int value) {
        modify(root, index, value);
    }
    
    private void modify(IntervalNode node, int index, int value) {
        if(node.start == node.end) {
            node.val = value;
            return;
        }
        
        int m = node.start + ((node.end - node.start)&amp;gt;&amp;gt;1);
         if(m &amp;lt; index) 
            modify(node.right, index, value);
        else
            modify(node.left, index, value);
        node.val = node.right.val + node.left.val;
    }
    
    
    
    private class IntervalNode {
        int start, end;
        long val;
        IntervalNode left, right;
        IntervalNode(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Segment Tree Build</title>
      <link>http://xmruibi.github.io/2015/10/18/segment-tree-build/</link>
      <pubDate>Sun, 18 Oct 2015 14:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/segment-tree-build/</guid>
      <description>

&lt;p&gt;The structure of Segment Tree is a binary tree which each node has two attributes &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; denote an segment / interval.&lt;/p&gt;

&lt;p&gt;start and end are both integers, they should be assigned in following rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The root&amp;rsquo;s start and end is given by &lt;code&gt;build&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;The left child of node A has &lt;code&gt;start=A.left, end=(A.left + A.right) / 2&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The right child of node A has &lt;code&gt;start=(A.left + A.right) / 2 + 1, end=A.right&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;if start equals to end, there will be no children for this node.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Implement a &lt;code&gt;build&lt;/code&gt; method with two parameters start and end, so that we can create a corresponding segment tree with every node has the correct start and end value, return the root of this segment tree.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given start=0, end=3. The segment tree will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;               [0,  3]
             /        \
      [0,  1]           [2, 3]
      /     \           /     \
   [0, 0]  [1, 1]     [2, 2]  [3, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given start=1, end=6. The segment tree will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;               [1,  6]
             /        \
      [1,  3]           [4,  6]
      /     \           /     \
   [1, 2]  [3,3]     [4, 5]   [6,6]
   /    \           /     \
[1,1]   [2,2]     [4,4]   [5,5]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;clarification&#34;&gt;Clarification&lt;/h3&gt;

&lt;p&gt;Segment Tree (a.k.a Interval Tree) is an advanced data structure which can support queries like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;which of these intervals contain a given point&lt;/li&gt;
&lt;li&gt;which of these points are in a given interval&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class SegmentTreeNode {
    public int start, end, max;
    public SegmentTreeNode left, right;
    public SegmentTreeNode(int start, int end, int max) {
        this.start = start;
        this.end = end;
        this.max = max
        this.left = this.right = null;
    }
}

public class Solution {
    /**
     *@param start, end: Denote an segment / interval
     *@return: The root of Segment Tree
     */
    public SegmentTreeNode build(int start, int end) {
        if(end &amp;lt; start)
            return null;
        SegmentTreeNode node = new SegmentTreeNode(start, end);
        if(start == end)
            return node;
        int m = left + ((right - left)&amp;gt;&amp;gt;1);
        node.left = build(start, m);
        node.right = build(m+1,end);
        return node;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Segment Tree Build II</title>
      <link>http://xmruibi.github.io/2015/10/18/segment-tree-build-ii/</link>
      <pubDate>Sun, 18 Oct 2015 14:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/segment-tree-build-ii/</guid>
      <description>

&lt;p&gt;The structure of Segment Tree is a binary tree which each node has two attributes &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; denote an segment / interval.&lt;/p&gt;

&lt;p&gt;start and end are both integers, they should be assigned in following rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The root&amp;rsquo;s start and end is given by &lt;code&gt;build&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;The left child of node A has &lt;code&gt;start=A.left, end=(A.left + A.right) / 2&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The right child of node A has &lt;code&gt;start=(A.left + A.right) / 2 + 1, end=A.right&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;if start equals to end, there will be no children for this node.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Implement a build method with a given array, so that we can create a corresponding segment tree with every node value represent the corresponding interval max value in the array, return the root of this segment tree.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given [3,2,1,4]. The segment tree will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                 [0,  3] (max = 4)
                  /            \
        [0,  1] (max = 3)     [2, 3]  (max = 4)
        /        \               /             \
[0, 0](max = 3)  [1, 1](max = 2)[2, 2](max = 1) [3, 3] (max = 4)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;clarification&#34;&gt;Clarification&lt;/h3&gt;

&lt;p&gt;Segment Tree (a.k.a Interval Tree) is an advanced data structure which can support queries like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;which of these intervals contain a given point&lt;/li&gt;
&lt;li&gt;which of these points are in a given interval&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     *@param A: a list of integer
     *@return: The root of Segment Tree
     */
    public SegmentTreeNode build(int[] A) {
        return builder(A, 0, A.length - 1);
    }
    
    private SegmentTreeNode builder(int[] A, int left, int right) {
        if(left &amp;gt; right)
            return null;
        if(left == right)
            return new SegmentTreeNode(left, right, A[left]);
        int m = left + ((right - left)&amp;gt;&amp;gt;1);
        SegmentTreeNode leftNode = builder(A, left, m);
        SegmentTreeNode rightNode = builder(A, m+1, right);
        SegmentTreeNode node = new SegmentTreeNode(left, right, Math.max(leftNode.max, rightNode.max));
        node.left = leftNode;
        node.right = rightNode;
        return node;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Segment Tree Modify</title>
      <link>http://xmruibi.github.io/2015/10/18/segment-tree-modify/</link>
      <pubDate>Sun, 18 Oct 2015 14:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/segment-tree-modify/</guid>
      <description>

&lt;p&gt;For a Maximum Segment Tree, which each node has an extra value max to store the maximum value in this node&amp;rsquo;s interval.&lt;/p&gt;

&lt;p&gt;Implement a modify function with three parameter root, index and value to change the node&amp;rsquo;s value with [start, end] = [index, index] to the new given value. Make sure after this change, every node in segment tree still has the max attribute with the correct value.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For segment tree:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                      [1, 4, max=3]
                    /                \
        [1, 2, max=2]                [3, 4, max=3]
       /              \             /             \
[1, 1, max=2], [2, 2, max=1], [3, 3, max=0], [4, 4, max=3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if call modify(root, 2, 4), we can get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                      [1, 4, max=4]
                    /                \
        [1, 2, max=4]                [3, 4, max=3]
       /              \             /             \
[1, 1, max=2], [2, 2, max=4], [3, 3, max=0], [4, 4, max=3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or call modify(root, 4, 0), we can get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                      [1, 4, max=2]
                    /                \
        [1, 2, max=2]                [3, 4, max=0]
       /              \             /             \
[1, 1, max=2], [2, 2, max=1], [3, 3, max=0], [4, 4, max=0]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;We suggest you finish problem Segment Tree Build and Segment Tree Query first.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it in O(h) time, h is the height of the segment tree.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     *@param root, index, value: The root of segment tree and 
     *@ change the node&#39;s value with [index, index] to the new given value
     *@return: void
     */
    public void modify(SegmentTreeNode root, int index, int value) {
        if(root.start == root.end) {
            root.max = value;
            return;
        }
        int m = root.start + ((root.end - root.start)&amp;gt;&amp;gt;1);
        if(m &amp;lt; index)
            modify(root.right, index, value);
        else
            modify(root.left, index, value);
            
        // update max each time, this is important
        root.max = Math.max(root.left.max, root.right.max);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Segment Tree Query</title>
      <link>http://xmruibi.github.io/2015/10/18/segment-tree-query/</link>
      <pubDate>Sun, 18 Oct 2015 14:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/segment-tree-query/</guid>
      <description>

&lt;p&gt;For an integer array (index from 0 to n-1, where n is the size of this array), in the corresponding SegmentTree, each node stores an extra attribute max to denote the maximum number in the interval of the array (index from start to end).&lt;/p&gt;

&lt;p&gt;Design a query method with three parameters root, start and end, find the maximum number in the interval [start, end] by the given root of segment tree.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For array [1, 4, 2, 3], the corresponding Segment Tree is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                  [0, 3, max=4]
                 /             \
          [0,1,max=4]        [2,3,max=3]
          /         \        /         \
   [0,0,max=1] [1,1,max=4] [2,2,max=2], [3,3,max=3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;query(root, 1, 1)&lt;/code&gt;, return &lt;code&gt;4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;query(root, 1, 2)&lt;/code&gt;, return &lt;code&gt;4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;query(root, 2, 3)&lt;/code&gt;, return &lt;code&gt;3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;query(root, 0, 2)&lt;/code&gt;, return &lt;code&gt;4&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;It is much easier to understand this problem if you finished Segment Tree Build first.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class SegmentTreeNode {
    public int start, end, max;
    public SegmentTreeNode left, right;
    public SegmentTreeNode(int start, int end, int max) {
        this.start = start;
        this.end = end;
        this.max = max
        this.left = this.right = null;
    }
}

public class Solution {
    /**
     *@param root, start, end: The root of segment tree and 
     *                         an segment / interval
     *@return: The maximum number in the interval [start, end]
     */
    public int query(SegmentTreeNode root, int start, int end) {
        if(root == null)
            return Integer.MIN_VALUE;
            
        if(root.start &amp;gt;= start &amp;amp;&amp;amp; root.end &amp;lt;= end)
            return root.max;
        int m = root.start + ((root.end - root.start)&amp;gt;&amp;gt;1);
        if(start &amp;gt; m)
            return query(root.right, start, end);
        else if(end &amp;lt;= m)
            return query(root.left, start, end);
        else
            return Math.max(query(root.left, start, m), query(root.right, m+1, end));
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Segment Tree Query II</title>
      <link>http://xmruibi.github.io/2015/10/18/segment-tree-query-ii/</link>
      <pubDate>Sun, 18 Oct 2015 14:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/segment-tree-query-ii/</guid>
      <description>

&lt;p&gt;For an array, we can build a SegmentTree for it, each node stores an extra attribute count to denote the number of elements in the the array which value is between interval start and end. (The array may not fully filled by elements)&lt;/p&gt;

&lt;p&gt;Design a query method with three parameters root, start and end, find the number of elements in the in array&amp;rsquo;s interval [start, end] by the given root of value SegmentTree.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For array [0, 2, 3], the corresponding value Segment Tree is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                     [0, 3, count=3]
                     /             \
          [0,1,count=1]             [2,3,count=2]
          /         \               /            \
   [0,0,count=1] [1,1,count=0] [2,2,count=1], [3,3,count=1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;query(1, 1)&lt;/code&gt;, return &lt;code&gt;0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;query(1, 2)&lt;/code&gt;, return &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;query(2, 3)&lt;/code&gt;, return &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;query(0, 2)&lt;/code&gt;, return &lt;code&gt;2&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;It is much easier to understand this problem if you finished Segment Tree Buildand Segment Tree Query first.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class SegmentTreeNode {
    public int start, end, max;
    public SegmentTreeNode left, right;
    public SegmentTreeNode(int start, int end, int max) {
        this.start = start;
        this.end = end;
        this.max = max
        this.left = this.right = null;
    }
}

public class Solution {
    /**
     *@param root, start, end: The root of segment tree and 
     *                         an segment / interval
     *@return: The count number in the interval [start, end]
     */
    public int query(SegmentTreeNode root, int start, int end) {
        // write your code here
        if(root == null)
            return 0;
            
        if(root.start &amp;gt;= start &amp;amp;&amp;amp; root.end &amp;lt;= end)
            return root.count;
            
        int m = root.start + ((root.end - root.start)&amp;gt;&amp;gt;1);
        
        if(start &amp;gt; m)
            return query(root.right, start, end);
        else if(end &amp;lt;= m)
            return query(root.left, start, end);
        else
            return query(root.left, start, m) + query(root.right, m+1, end);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Intersection of Two Linked Lists</title>
      <link>http://xmruibi.github.io/2015/10/18/intersection-of-two-linked-lists/</link>
      <pubDate>Sun, 18 Oct 2015 11:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/intersection-of-two-linked-lists/</guid>
      <description>

&lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;The following two linked lists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;begin to intersect at node c1.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;If the two linked lists have no intersection at all, return null.
The linked lists must retain their original structure after the function returns.
You may assume there are no cycles anywhere in the entire linked structure.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Count the length of each linked list&lt;/li&gt;
&lt;li&gt;Make two counts to be equal, then start moving and check if there are two nodes the same as each other.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param headA: the first list
     * @param headB: the second list
     * @return: a ListNode 
     */
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        
        ListNode a = headA;
        ListNode b = headB;
        int alen = 0, blen = 0;
        
        while(a!=null) {
            a = a.next;
            alen++;
        }
        while(b!=null) {
            b = b.next;
            blen++;
        }
        
        while(alen &amp;gt; blen) {
            headA = headA.next;
            alen--;
        }
        
        while(alen &amp;lt; blen) {
            headB = headB.next;
            blen--;
        }
        
        while(headA != null &amp;amp;&amp;amp; headB != null) {
            if(headA == headB)
                return headA;
            headA = headA.next;
            headB = headB.next;
        }
        return null;
    }  
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ugly Number</title>
      <link>http://xmruibi.github.io/2015/10/18/ugly-number/</link>
      <pubDate>Sun, 18 Oct 2015 11:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/ugly-number/</guid>
      <description>

&lt;p&gt;Write a program to check whether a given number is an ugly number.&lt;/p&gt;

&lt;p&gt;Ugly numbers are positive numbers whose prime factors only include &lt;code&gt;2, 3, 5&lt;/code&gt;. For example, &lt;code&gt;6, 8&lt;/code&gt; are ugly while &lt;code&gt;14&lt;/code&gt; is not ugly since it includes another prime factor &lt;code&gt;7&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that 1 is typically treated as an ugly number.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    public boolean isUgly(int num) {
        if(num&amp;lt;=0)
            return false;
        int[] factors = {2,3,5};
        for(int i = factors.length - 1; i &amp;gt;= 0; i--) {
            while(num % factors[i] == 0) {
                num /= factors[i];
            }
        }
        return num == 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ugly Number II</title>
      <link>http://xmruibi.github.io/2015/10/18/ugly-number-ii/</link>
      <pubDate>Sun, 18 Oct 2015 11:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/18/ugly-number-ii/</guid>
      <description>

&lt;p&gt;Write a program to find the n-th ugly number.&lt;/p&gt;

&lt;p&gt;Ugly numbers are positive numbers whose prime factors only include &lt;code&gt;2, 3, 5&lt;/code&gt;. For example, &lt;code&gt;1, 2, 3, 4, 5, 6, 8, 9, 10, 12&lt;/code&gt; is the sequence of the first &lt;code&gt;10&lt;/code&gt; ugly numbers.&lt;/p&gt;

&lt;p&gt;Note that &lt;code&gt;1&lt;/code&gt; is typically treated as an ugly number.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Declare an array for ugly numbers:  ugly[150]&lt;/li&gt;
&lt;li&gt;Initialize first ugly no:  ugly[1] = 1&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Initialize three array index variables t2, t3, t5 to point to
1st element of the ugly array:
    i2 = i3 = i5 = 1;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Initialize 3 choices for the next ugly no:
     next_mulitple_of_2 = ugly[i2]*2;
     next_mulitple_of_3 = ugly[i3]*3
     next_mulitple_of_5 = ugly[i5]*5;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Choose the minimum from the aboved 3 choices as the next ugly number.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check which choice and increase that index.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    public long nthUglyNumber(int k) {
        long[] memo = new long[k + 1];
            memo[1] = 1;
            int t2 = 1, t3 = 1, t5 = 1;
            for(int i = 2; i &amp;lt;= k; i++) {
                memo[i] = Math.min(memo[t2]*2, Math.min(memo[t3]*3, memo[t5]*5));
                if(memo[i] == memo[t2]*2)
                    t2++;
                if(memo[i] == memo[t3]*3)
                    t3++;
                if(memo[i] == memo[t5]*5)
                    t5++;
            }
            return memo[k];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Submatrix Sum</title>
      <link>http://xmruibi.github.io/2015/10/17/submatrix-sum/</link>
      <pubDate>Sat, 17 Oct 2015 21:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/17/submatrix-sum/</guid>
      <description>

&lt;p&gt;Given an integer matrix, find a submatrix where the sum of numbers is zero. Your code should return the coordinate of the left-up and right-down number.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given matrix&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [1 ,5 ,7],
  [3 ,7 ,-8],
  [4 ,-8 ,9],
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return &lt;code&gt;[(1,1), (2,2)]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n3) time.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Flatten Binary Tree to Linked List</title>
      <link>http://xmruibi.github.io/2015/10/17/flatten-binary-tree-to-linked-list/</link>
      <pubDate>Sat, 17 Oct 2015 17:50:34 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/17/flatten-binary-tree-to-linked-list/</guid>
      <description>

&lt;p&gt;Flatten a binary tree to a fake &amp;laquo;linked list&amp;raquo; in pre-order traversal.&lt;/p&gt;

&lt;p&gt;Here we use the right pointer in TreeNode as the next pointer in ListNode.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;              1
               \
     1          2
    / \          \
   2   5    =&amp;gt;    3
  / \   \          \
 3   4   6          4
                     \
                      5
                       \
                        6
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;Don&amp;rsquo;t forget to mark the left child of each node to null. Or you will get Time Limit Exceeded or Memory Limit Exceeded.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it in-place without any extra memory.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;One pass with iterate each right node.&lt;/li&gt;
&lt;li&gt;Put left node to right node.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param root: a TreeNode, the root of the binary tree
     * @return: nothing
     */
    public void flatten(TreeNode root) {
        TreeNode node = root;
        while(node!=null) {
            if(node.left != null) {
                TreeNode left = node.left;
                while(left.right != null) {
                    left = left.right;
                }
                left.right = node.right;
                node.right = node.left;
                node.left = null;
            }
            node = node.right;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Remove Linked List Elements</title>
      <link>http://xmruibi.github.io/2015/10/17/remove-linked-list-elements/</link>
      <pubDate>Sat, 17 Oct 2015 17:50:34 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/17/remove-linked-list-elements/</guid>
      <description>&lt;p&gt;Remove all elements from a linked list of integers that have value &lt;code&gt;val&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param head a ListNode
     * @param val an integer
     * @return a ListNode
     */
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        while(head!=null) {
            if(head.val != val) {
                pre.next = head;
                pre = pre.next;
            }
            head = head.next;
        }
        // this is important
        pre.next = null;
        return dummy.next;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>