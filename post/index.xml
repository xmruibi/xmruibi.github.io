<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Rui&#39;s Home Page</title>
    <link>http://xmruibi.github.io/post/</link>
    <description>Recent content in Posts on Rui&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Sat, 31 Oct 2015 10:10:29 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Even Iterator</title>
      <link>http://xmruibi.github.io/2015/10/31/even-iterator/</link>
      <pubDate>Sat, 31 Oct 2015 10:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/31/even-iterator/</guid>
      <description>

&lt;p&gt;Implements an iterator only output the even number.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class EvenIterator implements Iterator&amp;lt;Integer&amp;gt; {
    public static void main(String[] args) {
		List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
		list.add(1); list.add(4); list.add(3); list.add(5);
		list.add(6); list.add(7); list.add(9); list.add(2);
		EvenIterator it = new EvenIterator(list.listIterator());
		while(it.hasNext()){
			System.out.println(it.next());
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;output&#34;&gt;Output&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;4
6
2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class EvenIterator implements Iterator&amp;lt;Integer&amp;gt; {

    Iterator&amp;lt;Integer&amp;gt; iterator;

    public EvenIterator(Iterator&amp;lt;Integer&amp;gt; iterator) {
        this.iterator = iterator;
    }

    @Override
    public boolean hasNext() {
        return iterator.hasNext();
    }

    @Override
    public Integer next() {
        int res = 0;
        while (iterator.hasNext() &amp;amp;&amp;amp; (res = iterator.next()) % 2 != 0)
            ;
        return res;
    }

    
    public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        list.add(1); list.add(4);
        list.add(3); list.add(5);
        list.add(6); list.add(7);
        list.add(9); list.add(2);
        EvenIterator it = new EvenIterator(list.listIterator());
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Iterator for Merging Sorted Stream</title>
      <link>http://xmruibi.github.io/2015/10/31/iterator-for-merging-sorted-stream/</link>
      <pubDate>Sat, 31 Oct 2015 10:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/31/iterator-for-merging-sorted-stream/</guid>
      <description>

&lt;p&gt;Given a &lt;code&gt;Merge Sorted Stream&lt;/code&gt; class contains some sorted stream which implements iterator interface. Each sorted stream class has some methods: &lt;code&gt;hasNext()&lt;/code&gt;, &lt;code&gt;next()&lt;/code&gt;. Sorted Stream defines the stream read data by ascending order, so that in &lt;code&gt;Merge Sorted Stream&lt;/code&gt; when call &lt;code&gt;next()&lt;/code&gt; method, it will return values by ascending order. Pleas complete the following codes.&lt;/p&gt;

&lt;h3 id=&#34;partital-code&#34;&gt;Partital Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class SortedStream implments Iterator&amp;lt;Integer&amp;gt;{
	List&amp;lt;Integer&amp;gt; content;
	int cursor;
	public SortedStream(List&amp;lt;Integer&amp;gt; content){
		if(content == null)
			throw new IllegalArgumentException(&amp;quot;Null Input&amp;quot;);
		this.content = content;
		this.cursor = 0;
	}

	public boolean hasNext(){return cursor &amp;lt; content.size();}

	public int next(){return content.get(cursor++);}
}

class MergeSortedStream implments Iterator&amp;lt;SortedStream&amp;gt;{
    List&amp;lt;SortedStream&amp;gt; content;
	SortedStream cursor;
	public MergeSortedStream(List&amp;lt;SortedStream&amp;gt; content){...}
	
	public boolean hasNext(){...};

	public int next(){...};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Merge Sorted data by Heap!&lt;/li&gt;
&lt;li&gt;Peek Iterator&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MergeSortedStream implments Iterator&amp;lt;SortedStream&amp;gt;{
    List&amp;lt;SortedStream&amp;gt; content;
    PriorityQueue&amp;lt;Integer&amp;gt; minheap;
    public MergeSortedStream(List&amp;lt;SortedStream&amp;gt; content){
        this.minheap = new PriorityQueue&amp;lt;&amp;gt;();
        this.content = content;
        for(SortedStream ss : content) {
            if(ss != null &amp;amp;&amp;amp; ss.hasNext())
                minheap.add(ss.next());
        }
    }
    
    public boolean hasNext() {
        for (SortedStream ss : content) {
            if (ss != null &amp;amp;&amp;amp; ss.hasNext())
                minheap.add(ss.next());
        }
        return !minheap.isEmpty();
    }

    public int next(){
        return minheap.poll();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Jump Iterator</title>
      <link>http://xmruibi.github.io/2015/10/31/jump-iterator/</link>
      <pubDate>Sat, 31 Oct 2015 10:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/31/jump-iterator/</guid>
      <description>

&lt;p&gt;Implements an iterator in each output it print the number and skip the next one.&lt;/p&gt;

&lt;h3 id=&#34;partial-code&#34;&gt;Partial Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JumpIterator implements Iterator&amp;lt;Integer&amp;gt; {
    public static void main(String[] args) {
		List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
		list.add(1); list.add(4);
		list.add(3); list.add(5);
		list.add(6); list.add(7);
		list.add(2);
		JumpIterator it = new JumpIterator(list.listIterator());
		while(it.hasNext()){
			System.out.println(it.next());
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;output&#34;&gt;Output&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1
3
6
2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class JumpIterator implements Iterator&amp;lt;Integer&amp;gt; {

    Iterator&amp;lt;Integer&amp;gt; iterator;

    public JumpIterator(Iterator&amp;lt;Integer&amp;gt; iterator) {
        this.iterator = iterator;
    }

    @Override
    public boolean hasNext() {
        return iterator.hasNext();
    }

    @Override
    public Integer next() {
        int res = iterator.next();
        if (iterator.hasNext())
            iterator.next();
        return res;
    }

    public static void main(String[] args) {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        list.add(1); list.add(4);
        list.add(3); list.add(5);
        list.add(6); list.add(7);
        list.add(2);
        JumpIterator it = new JumpIterator(list.listIterator());
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Peeking Iterator</title>
      <link>http://xmruibi.github.io/2015/10/31/peeking-iterator/</link>
      <pubDate>Sat, 31 Oct 2015 10:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/31/peeking-iterator/</guid>
      <description>

&lt;p&gt;Given an Iterator class interface with methods: &lt;code&gt;next()&lt;/code&gt; and &lt;code&gt;hasNext()&lt;/code&gt;, design and implement a PeekingIterator that support the peek() operation &amp;ndash; it essentially &lt;code&gt;peek()&lt;/code&gt; at the element that will be returned by the next call to &lt;code&gt;next()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is an example. Assume that the iterator is initialized to the beginning of the list: &lt;code&gt;[1, 2, 3]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Call &lt;code&gt;next()&lt;/code&gt; gets you 1, the first element in the list.&lt;/p&gt;

&lt;p&gt;Now you call &lt;code&gt;peek()&lt;/code&gt; and it returns 2, the next element. Calling &lt;code&gt;next()&lt;/code&gt; after that still return 2.&lt;/p&gt;

&lt;p&gt;You call &lt;code&gt;next()&lt;/code&gt;the final time and it returns 3, the last element. Calling &lt;code&gt;hasNext()&lt;/code&gt; after that should return false.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class PeekingIterator implements Iterator&amp;lt;Integer&amp;gt; {
    
    int cur;
    Iterator&amp;lt;Integer&amp;gt; it;
    public PeekingIterator(Iterator&amp;lt;Integer&amp;gt; iterator) {
        this.it = iterator;
        cur = it.hasNext() ? it.next() : null;
    }

    // Returns the next element in the iteration without advancing the iterator.
    public Integer peek() {
        return cur;
    }

    // hasNext() and next() should behave the same as in the Iterator interface.
    // Override them if needed.
    @Override
    public Integer next() {
        int res = curl
        cur = it.next() ? it.next() : null;
        return res;
    }

    @Override
    public boolean hasNext() {
        return it.hasNext();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Search Range in Binary Search Tree</title>
      <link>http://xmruibi.github.io/2015/10/27/search-range-in-binary-search-tree/</link>
      <pubDate>Tue, 27 Oct 2015 13:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/27/search-range-in-binary-search-tree/</guid>
      <description>

&lt;p&gt;Given two values k1 and k2 (where k1 &amp;lt; k2) and a root pointer to a Binary Search Tree. Find all the keys of tree in range k1 to k2. i.e. print all x such that k1&amp;lt;=x&amp;lt;=k2 and x is a key of given BST. Return all the keys in ascending order.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;If k1 = 10 and k2 = 22, then your function should return [12, 20, 22].&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    20
   /  \
  8   22
 / \
4   12
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Recursion on each valid node.&lt;/li&gt;
&lt;li&gt;For invalid node, if it is less than k1, check its right child, while if it is larger than k2, check its left child&lt;/li&gt;
&lt;li&gt;Add the result from left and itself and right&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param root: The root of the binary search tree.
     * @param k1 and k2: range k1 to k2.
     * @return: Return all keys that k1&amp;lt;=key&amp;lt;=k2 in ascending order.
     */
    public ArrayList&amp;lt;Integer&amp;gt; searchRange(TreeNode root, int k1, int k2) {
        ArrayList&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(root == null)
            return res;
        ArrayList&amp;lt;Integer&amp;gt; left = searchRange(root.left, k1, k2);
        ArrayList&amp;lt;Integer&amp;gt; right = searchRange(root.right, k1, k2);
        // current value is less than k1, check its right child
        if(root.val &amp;lt; k1)
            return right;
        // current value is larger than k2, check its left child
        if(root.val &amp;gt; k2)
            return left;
        // add left branch first then itself and then right branch
        res.addAll(left);
        res.add(root.val);
        res.addAll(right);
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Print Numbers by Recursion</title>
      <link>http://xmruibi.github.io/2015/10/26/print-numbers-by-recursion/</link>
      <pubDate>Mon, 26 Oct 2015 16:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/26/print-numbers-by-recursion/</guid>
      <description>

&lt;p&gt;Print numbers from 1 to the largest number with &lt;code&gt;N&lt;/code&gt; digits by recursion.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;N = 1&lt;/code&gt;, return &lt;code&gt;[1,2,3,4,5,6,7,8,9]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Given &lt;code&gt;N = 2&lt;/code&gt;, return &lt;code&gt;[1,2,3,4,5,6,7,8,9,10,11,12,...,99]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s pretty easy to do recursion like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;recursion(i) {
    if i &amp;gt; largest number:
        return
    results.add(i)
    recursion(i + 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However this cost a lot of recursion memory as the recursion depth maybe very large ($$10^n - 1$$). Can you do it in another way to recursive with at most N depth?&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Do it in recursion, not for-loop.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Think from bottom to top.&lt;/li&gt;
&lt;li&gt;Build the result list from number with one digits to N digits.&lt;/li&gt;
&lt;li&gt;Since we considering with digits as its deep, we have to set a loop to add the number in list on the new-generated base number (1 - 9 with following digits):&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;when zero digit, none;
when one digit, new-generated base number is 1, add 1,2,...9;
when two digit, new-generated base number is 10, add 10,20,...90;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Each time when having the new-generated base number, we need to pass through the original result list to fill the rest of number with beginning as new-generated base number.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;when one digit, new-generated base number is 1, add 1,2,...9, but original result list has nothing. so just add itself;
when two digit, new-generated base number is 10, when add 10, go back the original result list with &amp;quot;1, 2, 3,..., 9&amp;quot;, add them as 11, 12, 13, ..., 19, when add 20, go back the original result list with &amp;quot;1, 2, 3,..., 9&amp;quot;, add them as 21, 22, 23, ..., 29;
so the same as for 30,..., 90, 100, ..., 900, ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param n: An integer.
     * return : An array storing 1 to the largest number with n digits.
     */
    public List&amp;lt;Integer&amp;gt; numbersByRecursion(int n) {
        List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(n &amp;gt;= 0)
            add(res, n);
        return res;
    }
    
    private int add(List&amp;lt;Integer&amp;gt; res, int n){
        if(n == 0)
            return 1;
        
        int cur = add(res, n - 1);
        int size = res.size();
        for(int i = 1; i &amp;lt;= 9; i ++) {
            int digit = i * cur;
            res.add(digit);
            for(int j = 0; j &amp;lt; size; j++) {
                res.add(digit + res.get(j));
            }
        }
        return cur * 10;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;complexity-analysis&#34;&gt;Complexity Analysis&lt;/h2&gt;

&lt;p&gt;Time: $$O(10^n - 1)$$&lt;/p&gt;

&lt;p&gt;Space: $$O(n)$$&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Boggle Game</title>
      <link>http://xmruibi.github.io/2015/10/25/boggle-game/</link>
      <pubDate>Sun, 25 Oct 2015 20:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/boggle-game/</guid>
      <description>

&lt;p&gt;Given a dictionary, a method to do lookup in dictionary and a M x N board where every cell has one character. Find all possible words that can be formed by a sequence of adjacent characters. Note that we can move to any of 8 adjacent characters, but a word should not have multiple instances of same cell.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;DFS on character board to do backtracking.&lt;/li&gt;
&lt;li&gt;Searching the character for 8 directions.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {

    public List&amp;lt;String&amp;gt; findWords(HashSet&amp;lt;String&amp;gt; dict, char[][] board) {
        List&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        boolean[][] visited = new boolean[board.length][board[0].length];
        for(int i = 0; i &amp;lt; board.length; i++) {
            for(int j = 0; j &amp;lt; board[i].length; j++) {
                findUtil(res, dict, board, visited, &amp;quot;&amp;quot;, i, j);
            }
        }
        return res;
    }

    private void findUtil(List&amp;lt;String&amp;gt; res, HashSet&amp;lt;String&amp;gt; dict, char[][] board, boolean[][] visited, String cur, int x, int y) {
        visited[x][y] = true;
        cur += board[x][y];

        if(dict.contains(cur)) {
            res.add(cur);
            dict.remvoe(cur);
            return;
        }
        
        int[] xs = {1,1,1,0,0,-1,-1,-1};
        int[] ys = {1,-1,0,1,-1,0,1,-1};
        for(int i = 0; i &amp;lt; 8; i++) {
            int nx = xs[i] + x;
            int ny = ys[i] + y;
            if(nx &amp;gt;= 0 &amp;amp;&amp;amp; nx &amp;lt; board.length &amp;amp;&amp;amp; ny &amp;gt;= 0 &amp;amp;&amp;amp; ny &amp;lt; board[nx].length &amp;amp;&amp;amp; !visited[nx][ny])
                findUtil(res, dict, board, visited, cur, nx, ny);
        }
        visited[x][y] = false;
        cur = cur.substring(0, cur.length() - 1);
    }

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Convert Sorted List to Binary Search Tree</title>
      <link>http://xmruibi.github.io/2015/10/25/convert-sorted-list-to-binary-search-tree/</link>
      <pubDate>Sun, 25 Oct 2015 20:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/convert-sorted-list-to-binary-search-tree/</guid>
      <description>

&lt;p&gt;Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;               2
1-&amp;gt;2-&amp;gt;3  =&amp;gt;   / \
             1   3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Find the middle point in list&lt;/li&gt;
&lt;li&gt;Divide and Conquer to build left child and right child node&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head: The first node of linked list.
     * @return: a tree node
     */
    public TreeNode sortedListToBST(ListNode head) {  
        // write your code here
        if(head == null)
            return null;
        if(head.next == null)
            return new TreeNode(head.val);
            
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode runner = head;
        ListNode walker = dummy;
        while(runner!=null &amp;amp;&amp;amp; runner.next!=null) {
            runner = runner.next.next;
            walker = walker.next;
        }
        
        ListNode m = walker.next;
        TreeNode root = new TreeNode(m.val);
        ListNode left = dummy.next;
        ListNode right = walker.next.next;
        walker.next = null;
        root.left = sortedListToBST(left);
        root.right = sortedListToBST(right);
        return root;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Remove Duplicates from Sorted List II</title>
      <link>http://xmruibi.github.io/2015/10/25/remove-duplicates-from-sorted-list-ii/</link>
      <pubDate>Sun, 25 Oct 2015 20:33:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/remove-duplicates-from-sorted-list-ii/</guid>
      <description>

&lt;p&gt;Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5&lt;/code&gt;, return &lt;code&gt;1-&amp;gt;2-&amp;gt;5&lt;/code&gt;.
Given &lt;code&gt;1-&amp;gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3&lt;/code&gt;, return &lt;code&gt;2-&amp;gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param ListNode head is the head of the linked list
     * @return: ListNode head of the linked list
     */
    public static ListNode deleteDuplicates(ListNode head) {
        // write your code here
        if(head == null || head.next == null)
            return head;
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        while(head != null){
            ListNode cur = head;
            while(head.next != null &amp;amp;&amp;amp; cur.val == head.next.val)
                head = head.next;
            
            if(head != cur){
                pre.next = head.next;
            }else
                pre = pre.next;
            head = head.next;
        }
        
        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Copy List with Random Pointer</title>
      <link>http://xmruibi.github.io/2015/10/25/copy-list-with-random-pointer/</link>
      <pubDate>Sun, 25 Oct 2015 20:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/copy-list-with-random-pointer/</guid>
      <description>

&lt;p&gt;Merge k sorted linked lists and return it as one sorted list.&lt;/p&gt;

&lt;p&gt;Analyze and describe its complexity.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given lists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  2-&amp;gt;4-&amp;gt;null,
  null,
  -1-&amp;gt;null
],
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return &lt;code&gt;-1-&amp;gt;2-&amp;gt;4-&amp;gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use a heap to receive element from linked list&lt;/li&gt;
&lt;li&gt;Tricky part:

&lt;ul&gt;
&lt;li&gt;Just entered k node in heap instead of pass all nodes in lists.&lt;/li&gt;
&lt;li&gt;When poll out element, it also need to push back the next node of polled node.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param lists: a list of ListNode
     * @return: The head of one sorted list.
     */
    public ListNode mergeKLists(List&amp;lt;ListNode&amp;gt; lists) {  
        if(lists == null)
            return null;
        
        PriorityQueue&amp;lt;ListNode&amp;gt; queue = new PriorityQueue&amp;lt;ListNode&amp;gt;(10, new Comparator&amp;lt;ListNode&amp;gt;(){
            @Override
            public int compare(ListNode o1, ListNode o2){
                return Integer.compare(o1.val, o2.val);
            }
        });
        // O(n) : n total nodes 
        for(ListNode node : lists){
            if(node != null)
                queue.offer(node);
        }
        
        ListNode dummy = new ListNode(0);
        ListNode pre = dummy;
        while(!queue.isEmpty()){
            ListNode cur = queue.remove();
            if(cur.next != null)
                queue.offer(cur.next);
            pre.next = cur;
            pre = cur;
        }
        
        return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Remove Nth Node From End of List</title>
      <link>http://xmruibi.github.io/2015/10/25/remove-nth-node-from-end-of-list/</link>
      <pubDate>Sun, 25 Oct 2015 16:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/remove-nth-node-from-end-of-list/</guid>
      <description>

&lt;p&gt;Given a linked list, remove the nth node from the end of list and return its head.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given linked list: &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;null&lt;/code&gt;, and n = &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After removing the second node from the end, the linked list becomes &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;5-&amp;gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The minimum number of nodes in list is n.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n) time&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Typical idea on runner and walker linked list question&lt;/li&gt;
&lt;li&gt;Let runner node run for N step further than walker node.&lt;/li&gt;
&lt;li&gt;Get the N + 1 th position from end of list.&lt;/li&gt;
&lt;li&gt;Remove walker.next which is the target node.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head: The first node of linked list.
     * @param n: An integer.
     * @return: The head of linked list.
     */
    ListNode removeNthFromEnd(ListNode head, int n) {
        if(head==null)
            return head;
        ListNode runner = head;
        ListNode pre = new ListNode(0);
        pre.next = head;
        ListNode walker = pre;
        while(n&amp;gt;0&amp;amp;&amp;amp;runner!=null){
            runner = runner.next;
            n--;
        }
        while(runner!=null){
            runner = runner.next;
            walker = walker.next;
        }
        walker.next = walker.next.next;
        return pre.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Copy List with Random Pointer</title>
      <link>http://xmruibi.github.io/2015/10/25/copy-list-with-random-pointer/</link>
      <pubDate>Sun, 25 Oct 2015 15:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/copy-list-with-random-pointer/</guid>
      <description>

&lt;p&gt;A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.&lt;/p&gt;

&lt;p&gt;Return a deep copy of the list.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Could you solve it with O(1) space?&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Three pass:

&lt;ul&gt;
&lt;li&gt;Clone every node and attach it right next of original node,&lt;/li&gt;
&lt;li&gt;Copy the random pointer for clone node (the next of origianl node&amp;rsquo;s random pointer)&lt;/li&gt;
&lt;li&gt;Cut down the original and clone one&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head: The head of linked list with a random pointer.
     * @return: A new head of a deep copy of the list.
     */
    public RandomListNode copyRandomList(RandomListNode head) {
        // write your code here
        if(head == null)
            return null;
        RandomListNode dummyHead = head;
        while(head != null) {
            RandomListNode clone = new RandomListNode(head.label);
            RandomListNode next = head.next;
            head.next = clone;
            clone.next = next;
            head = next;
        }
        head = dummyHead;
        while(head != null) {
            RandomListNode clone = head.next;
            if(head.random != null)
                clone.random = head.random.next;
            head = clone.next;
        }
        head = dummyHead;
        RandomListNode resHead = dummyHead.next;
        while(head != null) {
            RandomListNode clone = head.next;
            head.next = clone.next;
            head = head.next;
            if(head != null)
                clone.next = head.next;
        }
        
        return resHead;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Expression Tree Build</title>
      <link>http://xmruibi.github.io/2015/10/25/expression-tree-build/</link>
      <pubDate>Sun, 25 Oct 2015 15:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/expression-tree-build/</guid>
      <description>

&lt;p&gt;The structure of Expression Tree is a binary tree to evaluate certain expressions. All leaves of the Expression Tree have an number string value. All non-leaves of the Expression Tree have an operator string value.&lt;/p&gt;

&lt;p&gt;Now, given an expression array, build the expression tree of this expression, return the root of this expression tree.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For the expression &lt;code&gt;(2*6-(23+7)/(1+2))&lt;/code&gt; (which can be represented by &lt;code&gt;[&amp;quot;2&amp;quot; &amp;quot;*&amp;quot; &amp;quot;6&amp;quot; &amp;quot;-&amp;quot; &amp;quot;(&amp;quot; &amp;quot;23&amp;quot; &amp;quot;+&amp;quot; &amp;quot;7&amp;quot; &amp;quot;)&amp;quot; &amp;quot;/&amp;quot; &amp;quot;(&amp;quot; &amp;quot;1&amp;quot; &amp;quot;+&amp;quot; &amp;quot;2&amp;quot; &amp;quot;)&amp;quot;]&lt;/code&gt;). The expression tree will be like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                 [ - ]
             /          \
        [ * ]              [ / ]
      /     \           /         \
    [ 2 ]  [ 6 ]      [ + ]        [ + ]
                     /    \       /      \
                   [ 23 ][ 7 ] [ 1 ]   [ 2 ] .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After building the tree, you just need to return root node &lt;code&gt;[-]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;clarification&#34;&gt;Clarification&lt;/h3&gt;

&lt;p&gt;A binary expression tree is a specific application of a binary tree to evaluate certain expressions. Two common types of expressions that a binary expression tree can represent are algebraic[1] and boolean. These trees can represent expressions that contain both unary and binary operators.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ExpressionTreeNode {
    public String symbol;
     public ExpressionTreeNode left, right;
     public ExpressionTreeNode(String symbol) {
        this.symbol = symbol;
        this.left = this.right = null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Two stacks, one is only for operator, another is for build the result tree.&lt;/li&gt;
&lt;li&gt;The idea is similar with RPN.&lt;/li&gt;
&lt;li&gt;One pass the expression array, when it get a operand, insert as new treenode in result tree, when it get a operator, insert as new treenode in operator tree and compare the priority, if the current is less than stack top element, build a new node with operator in stack top and two node from result tree as its right and left child, then insert back to result tree with this new node.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;


public class Solution {
    /**
     * @param expression: A string array
     * @return: The root of expression tree
     */
    public ExpressionTreeNode build(String[] expression) {
        Stack&amp;lt;ExpressionTreeNode&amp;gt; ops = new Stack&amp;lt;&amp;gt;();
        Stack&amp;lt;ExpressionTreeNode&amp;gt; data = new Stack&amp;lt;&amp;gt;();
        for( int i = 0; i &amp;lt; expression.length; i++) {
            String str = expression[i];
            if(str.equals(&amp;quot;+&amp;quot;) || str.equals(&amp;quot;-&amp;quot;) ||str.equals(&amp;quot;*&amp;quot;) ||str.equals(&amp;quot;/&amp;quot;)) {
                while(!ops.isEmpty() &amp;amp;&amp;amp; operatorLevel(ops.peek().symbol) &amp;gt;= operatorLevel(str)) {
                    newNodeGtr(ops, data);
                }
                ops.push(new ExpressionTreeNode(str));
            }else if(str.equals(&amp;quot;(&amp;quot;)){
                ops.push(new ExpressionTreeNode(str));
            }else if(str.equals(&amp;quot;)&amp;quot;)) {
                while(!ops.isEmpty() &amp;amp;&amp;amp; !ops.peek().symbol.equals(&amp;quot;(&amp;quot;))
                    newNodeGtr(ops, data);
                if(!ops.isEmpty()) 
                    ops.pop(); // pop the &amp;quot;(&amp;quot;
            }else
                data.push(new ExpressionTreeNode(str));
        }
        
        while(!ops.isEmpty())
            newNodeGtr(ops, data);
        
        return data.isEmpty()? null : data.pop();
    }
    
    private void newNodeGtr(Stack&amp;lt;ExpressionTreeNode&amp;gt; ops, Stack&amp;lt;ExpressionTreeNode&amp;gt; data) {
        if(ops.isEmpty())
            return;
        ExpressionTreeNode node = ops.pop();
        node.right = data.isEmpty() ? null : data.pop();
        node.left = data.isEmpty() ? null : data.pop();
        data.push(node);
    }
    
    private int operatorLevel(String op) {
        if(op.equals(&amp;quot;+&amp;quot;) || op.equals(&amp;quot;-&amp;quot;)) 
            return 1;
        else if(op.equals(&amp;quot;*&amp;quot;) ||op.equals(&amp;quot;/&amp;quot;))
            return 2;
        else
            return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Insertion Sort for Linked List</title>
      <link>http://xmruibi.github.io/2015/10/25/insertion-sort-for-linked-list/</link>
      <pubDate>Sun, 25 Oct 2015 15:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/insertion-sort-for-linked-list/</guid>
      <description>

&lt;p&gt;Sort a linked list using insertion sort.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;1-&amp;gt;3-&amp;gt;2-&amp;gt;0-&amp;gt;null&lt;/code&gt;, return &lt;code&gt;0-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Pass nodes from head to end.&lt;/li&gt;
&lt;li&gt;Once it get an element larger than its next one, do a swap.&lt;/li&gt;
&lt;li&gt;Then return to the head and to do the passing again.&lt;/li&gt;
&lt;li&gt;Loop until get all sorted.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head: The first node of linked list.
     * @return: The head of linked list.
     */
    public ListNode insertionSortList(ListNode head) {
        if(head == null || head.next == null)
            return head;
            
            ListNode dummy = new ListNode(0);
            ListNode pre = dummy;
            ListNode cur = head;
            while(cur != null){
                pre = dummy;
                ListNode next = cur.next;
                while(pre.next != null &amp;amp;&amp;amp; pre.next.val &amp;lt; cur.val)
                    pre = pre.next;
                cur.next = pre.next;
                pre.next = cur;
                cur = next;
            }
            
            return dummy.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Reverse Nodes in k-Group</title>
      <link>http://xmruibi.github.io/2015/10/25/reverse-nodes-in-k-group/</link>
      <pubDate>Sun, 25 Oct 2015 15:13:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/25/reverse-nodes-in-k-group/</guid>
      <description>

&lt;p&gt;Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.&lt;/p&gt;

&lt;p&gt;If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.&lt;/p&gt;

&lt;p&gt;You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given this linked list: &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For k = &lt;code&gt;2&lt;/code&gt;, you should return: &lt;code&gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;For k = &lt;code&gt;3&lt;/code&gt;, you should return: &lt;code&gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;think&#34;&gt;Think&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Consider the list like following:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;	
	dummy(pre) -&amp;gt; l1 -&amp;gt; l2 -&amp;gt; l3 -&amp;gt; l4 -&amp;gt; l5 -&amp;gt; null
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Get the reversed segment:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt; when cnt % k == 0:

		pre.next	  node  node.next
		   |            |     |
	pre -&amp;gt; l1 -&amp;gt; l2 -&amp;gt; l3 -&amp;gt; l4 -&amp;gt; l5 -&amp;gt; null

		  last	  ----&amp;gt;	     end
		    |		          |
	pre -&amp;gt; l1 -&amp;gt; l2 -&amp;gt; l3 -&amp;gt; l4 -&amp;gt; l5 -&amp;gt; null
			|     |	    
		pre.next pre.next(final status)	
			   \     \
			      |  -&amp;gt; |     |
				 cur   cur	 cur.next (final status)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    /**
     * @param head a ListNode
     * @param k an integer
     * @return a ListNode
     */
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head == null || head.next == null)
            return head;
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        int cnt = 1;
        ListNode front = head;
        while(head != null) {
            if(cnt % k == 0) {
                pre = reverse(pre, head.next);
                head = pre.next;
            }else
                head = head.next;
            cnt++;
        }
        return dummy.next;
    }
    
    private ListNode reverse(ListNode pre, ListNode end) {
        ListNode last = pre.next, cur = last.next;
        while(cur != end) {
            last.next = cur.next;
            cur.next = pre.next;
            pre.next = cur;
            cur = last.next;
        }
        return last;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>