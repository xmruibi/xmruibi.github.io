<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Coder Thinking -- Home Page</title>
    <link>http://xmruibi.github.io/post/</link>
    <description>Recent content in Posts on Coder Thinking -- Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>xmruibi@gmail.com (Rui Bi)</managingEditor>
    <webMaster>xmruibi@gmail.com (Rui Bi)</webMaster>
    <copyright>(c) 2015 Rui Bi.</copyright>
    <lastBuildDate>Sat, 17 Oct 2015 21:43:13 -0700</lastBuildDate>
    <atom:link href="http://xmruibi.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Submatrix Sum</title>
      <link>http://xmruibi.github.io/2015/10/17/submatrix-sum/</link>
      <pubDate>Sat, 17 Oct 2015 21:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/17/submatrix-sum/</guid>
      <description>

&lt;p&gt;Given an integer matrix, find a submatrix where the sum of numbers is zero. Your code should return the coordinate of the left-up and right-down number.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given matrix&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [1 ,5 ,7],
  [3 ,7 ,-8],
  [4 ,-8 ,9],
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return &lt;code&gt;[(1,1), (2,2)]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n3) time.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>N Queen I</title>
      <link>http://xmruibi.github.io/2015/10/17/n-queen-i/</link>
      <pubDate>Sat, 17 Oct 2015 17:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/17/n-queen-i/</guid>
      <description>

&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.&lt;/p&gt;

&lt;p&gt;Given an integer n, return all distinct solutions to the n-queens puzzle.&lt;/p&gt;

&lt;p&gt;Each solution contains a distinct board configuration of the n-queens&amp;rsquo; placement, where &amp;lsquo;Q&amp;rsquo; and &amp;lsquo;.&amp;rsquo; both indicate a queen and an empty space respectively.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;There exist two distinct solutions to the 4-queens puzzle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[

    [&amp;quot;.Q..&amp;quot;, // Solution 1

     &amp;quot;...Q&amp;quot;,

     &amp;quot;Q...&amp;quot;,

     &amp;quot;..Q.&amp;quot;],

    [&amp;quot;..Q.&amp;quot;, // Solution 2

     &amp;quot;Q...&amp;quot;,

     &amp;quot;...Q&amp;quot;,

     &amp;quot;.Q..&amp;quot;]

]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Use one diamension int array to represent board: index -&amp;gt; num, value -&amp;gt; col;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /**
     * Get all distinct N-Queen solutions
     * @param n: The number of queens
     * @return: All distinct solutions
     * For example, A string &#39;...Q&#39; shows a queen on forth position
     */
    ArrayList&amp;lt;ArrayList&amp;lt;String&amp;gt;&amp;gt; solveNQueens(int n) {
        ArrayList&amp;lt;ArrayList&amp;lt;String&amp;gt;&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        int[] board = new int[n]; 
        recursion(res, board, 0);
        return res;
    }
    
    
    private void recursion(ArrayList&amp;lt;ArrayList&amp;lt;String&amp;gt;&amp;gt; res, int[] board, int row) {
        if(row == board.length) {
            // encode the board from 1-d array to string list
            ArrayList&amp;lt;String&amp;gt; cur = new ArrayList&amp;lt;&amp;gt;();
            for(int i = 0 ; i &amp;lt; board.length; i++){
                StringBuilder sb = new StringBuilder();
                for(int j = 0 ; j &amp;lt; board.length; j++) {
                    if(j == board[i])
                        sb.append(&amp;quot;Q&amp;quot;);
                    else
                        sb.append(&amp;quot;.&amp;quot;);
                }
                cur.add(sb.toString());
            }
            res.add(cur);
            return;
        }
        // recursion
        for(int i = 0; i &amp;lt; board.length; i++) {
            board[row] = i;
            if(isSafe(board, row))
                recursion(res, board, row+1);
        }
            
    }
    
    /**
    * Check the current board is safe.
    */
    private boolean isSafe(int[] board, int row) {
        for(int i = 0; i &amp;lt; row; i++) {
            // difference on col value shouldn&#39;t equal to the difference on row value;
            if((board[i]==board[row]) || (Math.abs(i - row) == Math.abs(board[i] - board[row])))
                return false;
        }
        return true;
    }
};

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>N Queen II</title>
      <link>http://xmruibi.github.io/2015/10/17/n-queen-ii/</link>
      <pubDate>Sat, 17 Oct 2015 17:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/17/n-queen-ii/</guid>
      <description>&lt;p&gt;Follow up for N-Queens problem.&lt;/p&gt;

&lt;p&gt;Now, instead outputting board configurations, return the total number of distinct solutions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Solution {
    /**
     * Calculate the total number of distinct N-Queen solutions.
     * @param n: The number of queens.
     * @return: The total number of distinct solutions.
     */
    private int solutions = 0;
    public int totalNQueens(int n) {
        //write your code here
        int[] board = new int[n]; 
        recursion(board, 0);
        return solutions;
    }
    
    private void recursion(int[] board, int row) {
        // when valid solution found
        if(row == board.length) {
            solutions++;
            return;
        }
        // recursion
        for(int i = 0; i &amp;lt; board.length; i++) {
            board[row] = i;
            if(isSafe(board, row))
                recursion(board, row+1);
        }
            
    }
    
    private boolean isSafe(int[] board, int row) {
        for(int i = 0; i &amp;lt; row; i++) {
            if((board[i]==board[row]) || (Math.abs(i - row) == Math.abs(board[i] - board[row])))
                return false;
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Integer to Roman</title>
      <link>http://xmruibi.github.io/2015/10/16/integer-to-roman/</link>
      <pubDate>Fri, 16 Oct 2015 21:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/16/integer-to-roman/</guid>
      <description>

&lt;p&gt;Given an integer, convert it to a roman numeral.&lt;/p&gt;

&lt;p&gt;The number is guaranteed to be within the range from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;3999&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;4&lt;/code&gt; -&amp;gt; &lt;code&gt;IV&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;12&lt;/code&gt; -&amp;gt; &lt;code&gt;XII&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;21&lt;/code&gt; -&amp;gt; &lt;code&gt;XXI&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;99&lt;/code&gt; -&amp;gt; &lt;code&gt;XCIX&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param n The integer
     * @return Roman representation
     */
    public String intToRoman(int n) {
        int[] numTab = {1,4,5,9,10,40,50,90,100,400,500,900,1000};
        String[] romanTab = {&amp;quot;I&amp;quot;, &amp;quot;IV&amp;quot;, &amp;quot;V&amp;quot;, &amp;quot;IX&amp;quot;, &amp;quot;X&amp;quot;, &amp;quot;XL&amp;quot;, &amp;quot;L&amp;quot;, &amp;quot;LC&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;CD&amp;quot;, &amp;quot;D&amp;quot;, &amp;quot;DM&amp;quot;,&amp;quot;M&amp;quot;};
        
        StringBuilder sb = new StringBuilder();
        for(int i = numTab.length - 1; i &amp;gt;= 0; i--) {
            while(n &amp;gt;= numTab[i]) {
                sb.append(romanTab[i]);
                n -= numTab[i];
            }
        }
        return sb.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Roman to Integer</title>
      <link>http://xmruibi.github.io/2015/10/16/roman-to-integer/</link>
      <pubDate>Fri, 16 Oct 2015 21:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/16/roman-to-integer/</guid>
      <description>

&lt;p&gt;Given a roman numeral, convert it to an integer.&lt;/p&gt;

&lt;p&gt;The answer is guaranteed to be within the range from 1 to 3999.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;IV&lt;/code&gt; -&amp;gt; &lt;code&gt;4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;XII&lt;/code&gt; -&amp;gt; &lt;code&gt;12&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;XXI&lt;/code&gt; -&amp;gt; &lt;code&gt;21&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;XCIX&lt;/code&gt; -&amp;gt; &lt;code&gt;99&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;clarification&#34;&gt;Clarification&lt;/h3&gt;

&lt;p&gt;|&amp;mdash;&amp;ndash;|&amp;mdash;&amp;mdash;|
|Symbol | Value|
| I | 1 |
|V  | 5 |
|X  | 10 |
|L  | 50 |
|C  | 100 |
|D  | 500 |
|M  | 1,000 |&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;同一数码最多只能出现三次，如40不可表示为XXXX，而要表示为XL。&lt;/li&gt;
&lt;li&gt;在较大的罗马数字的右边记上较小的罗马数字，表示大数字加小数字。&lt;/li&gt;
&lt;li&gt;在较大的罗马数字的左边记上较小的罗马数字，表示大数字减小数字。&lt;/li&gt;
&lt;li&gt;左减的数字有限制，仅限于I、X、C。比如45不可以写成VL，只能是XLV。&lt;/li&gt;
&lt;li&gt;但是，左减时不可跨越一个位数。比如，99不可以用IC（100 - 1）表示，是用XCIX（[100 - 10] + [10 - 1]）表示。&lt;/li&gt;
&lt;li&gt;左减数字必须为一位，比如8写成VIII，而非IIX。&lt;/li&gt;
&lt;li&gt;右加数字不可连续超过三位，比如14写成XIV，而非XIIII。（见下方“数码限制”一项。）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param s Roman representation
     * @return an integer
     */
    public int romanToInt(String s) {
        // Write your code here
        HashMap&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&#39;I&#39;, 1);map.put(&#39;V&#39;, 5);
        map.put(&#39;X&#39;, 10);map.put(&#39;L&#39;, 50);
        map.put(&#39;C&#39;, 100);map.put(&#39;D&#39;, 500);
        map.put(&#39;M&#39;, 1000);
        
        int res = 0;
        for (int i = 0; i &amp;lt; s.length() ; i++) {
            if(i &amp;lt; s.length() - 1 &amp;amp;&amp;amp; map.get(s.charAt(i)) &amp;lt; map.get(s.charAt(i+1)) )
                res -= map.get(s.charAt(i));
            else
                res += map.get(s.charAt(i));
        }
        
        return res;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Common Subsequence</title>
      <link>http://xmruibi.github.io/2015/10/16/longest-common-subsequence/</link>
      <pubDate>Fri, 16 Oct 2015 09:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/16/longest-common-subsequence/</guid>
      <description>

&lt;p&gt;Given two strings, find the longest common subsequence (LCS).&lt;/p&gt;

&lt;p&gt;Your code should return the length of LCS.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;ABCD&lt;/code&gt; and &lt;code&gt;EDCA&lt;/code&gt;, the LCS is &lt;code&gt;A&lt;/code&gt; (or &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;), return 1.&lt;/p&gt;

&lt;p&gt;For &lt;code&gt;ABCD&lt;/code&gt; and &lt;code&gt;EACB&lt;/code&gt;, the LCS is &lt;code&gt;AC&lt;/code&gt;, return 2.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param A, B: Two strings.
     * @return: The length of longest common subsequence of A and B.
     */
    public int longestCommonSubsequence(String A, String B) {
        if(A == null || B == null)
            return 0;
        
        int[][] memo = new int[A.length()+1][B.length()+1];
        for(int i = 0; i &amp;lt;= A.length(); i ++) {
            for(int j = 0; j &amp;lt;= B.length(); j ++) {
                if(i == 0 || j == 0)
                    memo[i][j] = 0;
                else
                    memo[i][j] = (A.charAt(i-1) == B.charAt(j-1) ? memo[i-1][j-1] + 1 : Math.max(memo[i][j-1],memo[i-1][j]));
            }
        }
        return memo[A.length()][B.length()];
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Increasing Continuous Subsequence II</title>
      <link>http://xmruibi.github.io/2015/10/16/longest-increasing-continuous-subsequence-ii/</link>
      <pubDate>Fri, 16 Oct 2015 09:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/16/longest-increasing-continuous-subsequence-ii/</guid>
      <description>

&lt;p&gt;Give you an integer matrix (with row size n, column size m)，find the longest increasing continuous subsequence in this matrix. (The definition of the longest increasing continuous subsequence here can start at any row or column and go up/down/right/left any direction).&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given a matrix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[
  [1 ,2 ,3 ,4 ,5],
  [16,17,24,23,6],
  [15,18,25,22,7],
  [14,19,20,21,8],
  [13,12,11,10,9]
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;return &lt;code&gt;25&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(nm) time and memory.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This is great question with DFS, Dynamic Problem and Subsequence idea.&lt;/li&gt;
&lt;li&gt;The idea is also simple. Recursively search by DFS while we can do some memorized stuff.&lt;/li&gt;
&lt;li&gt;Each time we figure out the maximum length with reversed increasing sequence from each element in matrix.&lt;/li&gt;
&lt;li&gt;Note that the searching is by decreasing way.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param A an integer matrix
     * @return  an integer
     */
    // memorized the local maximum length
    int[][] memo;

    boolean[] visited;
    int n ,m;

    // stepping way for dfs
    int[] dx = {1,-1,0,0}; 
    int[] dy = {0,0,1,-1};

    public int longestIncreasingContinuousSubsequenceII(int[][] A) {
        if(A.length == 0)
            return 0;
        n = A.length;
        m  = A[0].length;
        
        memo = new int[n][m];
        visited = new boolean[n*m];
        
        int res = 0;
        for(int i = 0; i &amp;lt; n; i++) {
            for(int j = 0; j &amp;lt; m; j++) { 
                memo[i][j] = helper(i, j, A);
                res = Math.max(res, memo[i][j]);
            }
        }
        return res;
    }
    
    private int helper(int x, int y, int[][] A) {
        // once it touched the visited element, return that value
        if(visited[x * m + y])
            return memo[x][y];
        
        int res = 1; 
        for(int i = 0; i &amp;lt; 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if(0&amp;lt;= nx &amp;amp;&amp;amp; nx &amp;lt; n &amp;amp;&amp;amp; 0&amp;lt;= ny &amp;amp;&amp;amp; ny &amp;lt; m ) {
                // this is tricky point, we search by decreasing
                if( A[x][y] &amp;gt; A[nx][ny]) 
                    res = Math.max(res,  helper(nx, ny, A) + 1);
            }
        }
        visited[x * m + y] = true;
        memo[x][y] = res;
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Increasing Continuous subsequence</title>
      <link>http://xmruibi.github.io/2015/10/16/longest-increasing-continuous-subsequence/</link>
      <pubDate>Fri, 16 Oct 2015 09:03:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/16/longest-increasing-continuous-subsequence/</guid>
      <description>

&lt;p&gt;Give you an integer array (index from 0 to n-1, where n is the size of this array)，find the longest increasing continuous subsequence in this array. (The definition of the longest increasing continuous subsequence here can be from right to left or from left to right)&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For &lt;code&gt;[5, 4, 2, 1, 3]&lt;/code&gt;, the LICS is &lt;code&gt;[5, 4, 2, 1]&lt;/code&gt;, return &lt;code&gt;4&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For &lt;code&gt;[5, 1, 2, 3, 4]&lt;/code&gt;, the LICS is &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;, return &lt;code&gt;4&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;O(n) time and O(1) extra space.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This is O(1) space dynamic programming. Just maintain one local max and one global max variable.&lt;/li&gt;
&lt;li&gt;The default value of local maximum variable is 2.&lt;/li&gt;
&lt;li&gt;The condition for growing the local maximum is by &lt;code&gt;(A[i] - A[i-1])*(A[i-1] - A[i-2]) &amp;gt; 0&lt;/code&gt;, which means &lt;code&gt;[i-2] &amp;lt; [i-1] &amp;lt; [i]&lt;/code&gt; or &lt;code&gt;[i-2] &amp;gt; [i-1] &amp;gt; [i]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param A an array of Integer
     * @return  an integer
     */
    public int longestIncreasingContinuousSubsequence(int[] A) {
        if( A == null )
            return 0;
        if( A.length &amp;lt;= 1)
            return A.length;
        
        int max = 2;
        int cur = 2;
        for(int i = 2; i &amp;lt; A.length; i++) {
            if((A[i] - A[i-1])*(A[i-1] - A[i-2]) &amp;gt; 0){
                cur ++;   
            }else
                cur = 2;
            max = Math.max(max, cur);
        }
        return max;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Substring Without Repeating Characters</title>
      <link>http://xmruibi.github.io/2015/10/15/longest-substring-without-repeating-characters/</link>
      <pubDate>Thu, 15 Oct 2015 09:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/15/longest-substring-without-repeating-characters/</guid>
      <description>

&lt;p&gt;Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For example, the longest substring without repeating letters for &lt;code&gt;abcabcbb&lt;/code&gt; is &lt;code&gt;abc&lt;/code&gt;, which the length is 3.&lt;/p&gt;

&lt;p&gt;For &lt;code&gt;bbbbb&lt;/code&gt; the longest substring is &lt;code&gt;b&lt;/code&gt;, with the length of 1.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n) time&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Set two pointers as a windows for input string.&lt;/li&gt;
&lt;li&gt;Very simple idea, to use a hashset to store the characters in a window (substring) in string.&lt;/li&gt;
&lt;li&gt;While the repeat detect, move forward the previous pointer.&lt;/li&gt;
&lt;li&gt;Update the max window size each time.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param s: a string
     * @return: an integer 
     */
    public int lengthOfLongestSubstring(String s) {
        Set&amp;lt;Character&amp;gt; disc = new HashSet&amp;lt;&amp;gt;();
        
        int maxLen = 0;
        int prev = 0;
        for(int i = 0; i &amp;lt; s.length(); i++) {
            char c = s.charAt(i);
            
            while(disc.contains(c)){
                disc.remove(s.charAt(prev++));
            }
            maxLen = Math.max(maxLen, i - prev + 1);
            disc.add(c);
        }
        return maxLen;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Letter Combinations of a Phone Number</title>
      <link>http://xmruibi.github.io/2015/10/14/letter-combinations-of-a-phone-number/</link>
      <pubDate>Wed, 14 Oct 2015 20:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/14/letter-combinations-of-a-phone-number/</guid>
      <description>

&lt;p&gt;Given a digit string, return all possible letter combinations that the number could represent.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;Given &lt;code&gt;23&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Return &lt;code&gt;[&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;Although the above answer is in lexicographical order, your answer could be in any order you want.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param digits A digital string
     * @return all posible letter combinations
     */
    public ArrayList&amp;lt;String&amp;gt; letterCombinations(String digits) {
        ArrayList&amp;lt;String&amp;gt; res = new ArrayList&amp;lt;&amp;gt;();
        if(digits == null ||digits.length() == 0)
            return res;
        HashMap&amp;lt;Character, String&amp;gt; dict = new HashMap&amp;lt;&amp;gt;();
        dict.put(&#39;2&#39;,&amp;quot;abc&amp;quot;);dict.put(&#39;3&#39;,&amp;quot;def&amp;quot;);dict.put(&#39;4&#39;,&amp;quot;ghi&amp;quot;);dict.put(&#39;5&#39;,&amp;quot;jkl&amp;quot;);
        dict.put(&#39;6&#39;,&amp;quot;mno&amp;quot;);dict.put(&#39;7&#39;,&amp;quot;pqrs&amp;quot;);dict.put(&#39;8&#39;,&amp;quot;tuv&amp;quot;);dict.put(&#39;9&#39;,&amp;quot;wxyz&amp;quot;);

        helper(dict, res, &amp;quot;&amp;quot;, digits, 0);
        return res;
    }
    
    private void helper(HashMap&amp;lt;Character, String&amp;gt; dict, ArrayList&amp;lt;String&amp;gt; res, String str, String digits, int idx) {
        if(idx == digits.length()) {
            res.add(new String(str));
            return;
        }
        String letters = dict.get(digits.charAt(idx));
        for(int i = 0; i &amp;lt; letters.length(); i++) {
            str += letters.charAt(i);
            helper(dict, res, str, digits, idx + 1);
            str = str.substring(0, idx);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Closest Number</title>
      <link>http://xmruibi.github.io/2015/10/12/closest-number/</link>
      <pubDate>Mon, 12 Oct 2015 21:43:13 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/12/closest-number/</guid>
      <description>

&lt;p&gt;Given an unsorted array, find out the most closest two elements in this array. Output&lt;/p&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Sort is important here! You must think about sort first. Since other may may cost&lt;/li&gt;
&lt;li&gt;Then the gap between adjacent elements are the&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
&lt;code class=&#34;java&#34;&gt;
public ArrayList&lt;int[]&gt; closestNumber(int[] arr){
    ArrayList&lt;int[]&gt; res = new ArrayList&lt;&gt;();
    if(arr == null || arr.length == 0)
        return res;
    Arrays.sort(arr);

    int mindiff = Integer.MAX_VALUE;
    for(int i = 1; i &lt; arr.length; i++) {
        int curdiff = arr[i] - arr[i - 1];
        if(curdiff &gt;= mindiff) {
            if(curdiff &gt; mindiff)
                res.clear();
            int[] cres = new int[]{arr[i - 1], arr[i]};
            res.add(cres);
        }
    }
    return res;
}
&lt;/code&gt;
&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Route Between Two Nodes in Directed Graph</title>
      <link>http://xmruibi.github.io/2015/10/11/route-between-two-nodes-in-directed-graph/</link>
      <pubDate>Sun, 11 Oct 2015 15:14:18 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/11/route-between-two-nodes-in-directed-graph/</guid>
      <description>

&lt;p&gt;Given a directed graph, design an algorithm to find out whether there is a route between two nodes.&lt;/p&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Most typical Graph algorithm question!&lt;/li&gt;
&lt;li&gt;Try two ways: DFS, BFS.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
&lt;code class=&#34;java&#34;&gt;
public class Solution {
   /**
     * @param graph: A list of Directed graph node
     * @param s: the starting Directed graph node
     * @param t: the terminal Directed graph node
     * @return: a boolean value
     */
     
     // BFS
     public boolean hasRoute(ArrayList&lt;DirectedGraphNode&gt; graph, 
                            DirectedGraphNode s, DirectedGraphNode t) {
        
        if(s == t)
            return true;

        Queue&lt;DirectedGraphNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(s);
        graph.remove(s);
        while(!queue.isEmpty()) {
            DirectedGraphNode cur = queue.remove();
            graph.remove(cur);
            for(DirectedGraphNode next : cur.neighbors) {
                if(!graph.contains(next))
                    continue;
                if(next == t)
                    return true;
                queue.offer(next);
            }
        }
        return false;
    }
     
     
    // DFS
    public boolean hasRoute(ArrayList&lt;DirectedGraphNode&gt; graph, 
                            DirectedGraphNode s, DirectedGraphNode t) {
        // write your code here
        if(s == t)
            return true;
            
        graph.remove(s);
        for(DirectedGraphNode next : s.neighbors) {
            if(!graph.contains(next))
                    continue;
            if(hasRoute(graph, next, t))
                return true;
        }
        graph.add(s);
        return false;
    }
}


&lt;/code&gt;
&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Substring with At Most K Distinct Characters Show result</title>
      <link>http://xmruibi.github.io/2015/10/08/longest-substring-with-at-most-k-distinct-characters-show-result/</link>
      <pubDate>Thu, 08 Oct 2015 22:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/08/longest-substring-with-at-most-k-distinct-characters-show-result/</guid>
      <description>

&lt;p&gt;Given a string s, find the length of the longest substring T that contains at most k distinct characters.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;For example, Given s = &lt;code&gt;eceba&lt;/code&gt;, k = 3,&lt;/p&gt;

&lt;p&gt;T is &lt;code&gt;eceb&lt;/code&gt; which its length is 4.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;O(n), n is the size of the string s.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Set two pointers as a windows for input string.&lt;/li&gt;
&lt;li&gt;Use a hashmap to store the characters in a window (substring) in string.&lt;/li&gt;
&lt;li&gt;However, we notice that we use hashmap for count the character appearance times.&lt;/li&gt;
&lt;li&gt;Remove the character as a key only if the count for this key is zero.&lt;/li&gt;
&lt;li&gt;Update the max window size each time.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * @param s : A string
     * @return : The length of the longest substring 
     *           that contains at most k distinct characters.
     */
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        if(s == null)
            return 0;
        
        HashMap&amp;lt;Character, Integer&amp;gt; dict = new HashMap&amp;lt;&amp;gt;();
        
        int prev = 0;
        int maxLen = 0;
        for(int i = 0; i &amp;lt; s.length(); i++) {
            char c = s.charAt(i);
            if(dict.containsKey(c)) {
                dict.put(c, dict.get(c) + 1);
            }else {
                dict.put(c, 1);
                while(dict.size() &amp;gt; k) {
                    char prevChar = s.charAt(prev++);
                    if(dict.get(prevChar) &amp;gt; 1)
                        dict.put(prevChar, dict.get(prevChar) - 1);
                    else
                        dict.remove(prevChar);
                }
            }
            maxLen = Math.max(maxLen, i - prev + 1);
        }
        
        return maxLen;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the first I made a mistake by using hashset. However, like the previous mentioned, we need to count the character appearance. Why? Since there is possible when the character on index &lt;code&gt;prev&lt;/code&gt; has another one in this window. But when you simply remove this element, there is still one inside this window. Tha makes the mistake happened!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Say, in &lt;code&gt;acdab&lt;/code&gt;, pointer &lt;code&gt;prev&lt;/code&gt; is on first &lt;code&gt;a&lt;/code&gt;, once we do &lt;code&gt;set.remove(a)&lt;/code&gt;, the &lt;code&gt;size()&lt;/code&gt; become 3, but in fact, it is still 4.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    // This is the wrong code!!!
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        // write your code here
        Set&amp;lt;Character&amp;gt; disc = new HashSet&amp;lt;&amp;gt;();
        
        int maxLen = 0;
        int prev = 0;
        for(int i = 0; i &amp;lt; s.length(); i++) {
            char c = s.charAt(i);
            disc.add(c);
            while(disc.size() &amp;gt; k){
                disc.remove(s.charAt(prev++));
            }
            maxLen = Math.max(maxLen, i - prev + 1);
        }
        return maxLen;
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Minimum Window Substring</title>
      <link>http://xmruibi.github.io/2015/10/08/minimum-window-substring/</link>
      <pubDate>Thu, 08 Oct 2015 22:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/08/minimum-window-substring/</guid>
      <description>

&lt;p&gt;Given a string source and a string target, find the minimum window in source which will contain all the characters in target.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;source = &amp;laquo;ADOBECODEBANC&amp;raquo; target = &amp;laquo;ABC&amp;raquo; Minimum window is &amp;laquo;BANC&amp;raquo;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;If there is no such window in source that covers all characters in target, return the emtpy string &amp;laquo;&amp;raquo;.&lt;/p&gt;

&lt;p&gt;If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in source.&lt;/p&gt;

&lt;h3 id=&#34;challenge&#34;&gt;Challenge&lt;/h3&gt;

&lt;p&gt;Can you do it in time complexity O(n) ?&lt;/p&gt;

&lt;h3 id=&#34;clarification&#34;&gt;Clarification&lt;/h3&gt;

&lt;p&gt;The characters in minimum window doesn&amp;rsquo;t need to has the same order in target.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution:&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public String minWindow(String source, String target) {
        // preload for target checking
        if(source == null || source.length() == 0 || target == null || target.length() == 0)
            return &amp;quot;&amp;quot;;
        
        
        int tarLen = target.length();
        HashMap&amp;lt;Character, Integer&amp;gt; dict = new HashMap&amp;lt;&amp;gt;();
        for(char c : target.toCharArray()) 
            dict.put(c, dict.containsKey(c)? dict.get(c) + 1 : 1);
        
        int hitCount = 0; // record current window hits how many characters in target
        int prevIdx = 0; // record the left bound of current window
        int minWindow = source.length() + 1; // initial the minimum window length
        int start = 0;
        for(int i = 0; i &amp;lt; source.length(); i++) {
            char cur = source.charAt(i);
            // if current char is not in dict, continue
            if(!dict.containsKey(cur))
                continue;
            
            dict.put(cur, dict.get(cur) - 1);
            if(dict.get(cur) &amp;gt;= 0)
                hitCount++;
            
            // check the windows has amount of this char more than it in target string
            // loop until the amount back to normal, but always reduce the prev index char
            while(hitCount == tarLen) {
                if( minWindow &amp;gt; i - prevIdx + 1) {
                    start = prevIdx;
                    minWindow = i - prevIdx + 1;
                }
                char prevChar = source.charAt(prevIdx);
                if(dict.containsKey(prevChar)) {
                    dict.put(prevChar, dict.get(prevChar)+1);
                    if(dict.get(prevChar) &amp;gt; 0)
                        hitCount--;
                }
                prevIdx++;
            }
        }
        // 
        if(minWindow &amp;gt; source.length())
            return &amp;quot;&amp;quot;;
        return source.substring(start, start + minWindow);
    }

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Partition Array</title>
      <link>http://xmruibi.github.io/2015/10/08/partition-array/</link>
      <pubDate>Thu, 08 Oct 2015 22:10:29 -0700</pubDate>
      <author>xmruibi@gmail.com (Rui Bi)</author>
      <guid>http://xmruibi.github.io/2015/10/08/partition-array/</guid>
      <description>&lt;p&gt;Given an array &lt;code&gt;nums&lt;/code&gt; of integers and an int &lt;code&gt;k&lt;/code&gt;, partition the array (i.e move the elements in &amp;laquo;nums&amp;raquo;) such that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All elements &amp;lt; k are moved to the left&lt;/li&gt;
&lt;li&gt;All elements &amp;gt;= k are moved to the right&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Return the partitioning index, i.e the first index i nums[i] &amp;gt;= k.&lt;/p&gt;

&lt;p&gt;Solution:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Typical index rotate two pointer problem, looks like the idea of quick sort .&lt;/li&gt;
&lt;li&gt;Set an index &lt;code&gt;pivot&lt;/code&gt; for marking the real position of element less than &lt;code&gt;k&lt;/code&gt; during pass the orginal array.&lt;/li&gt;
&lt;li&gt;Once the current passing index &lt;code&gt;i&lt;/code&gt; hits the element less than &lt;code&gt;k&lt;/code&gt;, we do the swap with &lt;code&gt;pivot&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Make sure the &lt;code&gt;pivot&lt;/code&gt; should add 1 after swap since the marked position is increase for next one.&lt;/li&gt;
&lt;li&gt;However in new &lt;code&gt;pivot&lt;/code&gt; position we not sure the element&amp;rsquo;s value, so&amp;hellip; we need to check in next procedure.&lt;/li&gt;
&lt;li&gt;Make sure the &lt;code&gt;i&lt;/code&gt; position decrease 1, because we just did a swap and we need to check the new &lt;code&gt;i&lt;/code&gt; is less than &amp;lsquo;k&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /** 
     *@param nums: The integer array you should partition
     *@param k: As description
     *return: The index after partition
     */
    public int partitionArray(int[] nums, int k) {
        if(nums == null || nums.length == 0)
            return 0;
            
        int pivot = 0;
        for(int i = 0; i &amp;lt; nums.length; i++) {
            if(i &amp;gt; pivot &amp;amp;&amp;amp; nums[i] &amp;lt; k) {
                int tmp = nums[pivot];
                nums[pivot++] = nums[i];
                nums[i--] = tmp;
            }
        }
        // this is just for corner case when the last element still less than k
        if(nums[nums.length - 1] &amp;lt; k)
            return nums.length;
        return pivot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>